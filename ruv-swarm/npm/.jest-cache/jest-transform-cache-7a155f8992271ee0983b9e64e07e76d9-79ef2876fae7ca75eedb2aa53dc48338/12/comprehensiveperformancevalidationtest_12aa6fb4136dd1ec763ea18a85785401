84d475c3e05d42665bb21ef8eae0e8ff
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
/**
 * Comprehensive Performance Validation Framework
 * Tests all performance targets and validates DAA integration
 */

const {
  RuvSwarm
} = require('../src/index-enhanced');
const {
  performanceCLI
} = require('../src/performance');
const fs = require('fs').promises;
const path = require('path');
const {
  spawn
} = require('child_process');
class PerformanceValidator {
  constructor() {
    this.testResults = {
      timestamp: new Date().toISOString(),
      tests: [],
      performance: {
        simd: {
          target: '6-10x',
          actual: null,
          passed: false
        },
        speed: {
          target: '2.8-4.4x',
          actual: null,
          passed: false
        },
        loadTesting: {
          target: '50+ agents',
          actual: null,
          passed: false
        },
        memoryEfficiency: {
          target: '<500MB@50agents',
          actual: null,
          passed: false
        },
        daaIntegration: {
          target: 'seamless',
          actual: null,
          passed: false
        }
      },
      coverage: {
        lines: 0,
        branches: 0,
        functions: 0,
        statements: 0
      },
      recommendations: []
    };
    this.baselines = {};
  }
  runComprehensiveValidation() {
    var _this = this;
    return _asyncToGenerator(function* () {
      console.log('🚀 Starting Comprehensive Performance Validation\n');

      // 1. Establish baselines
      yield _this.establishBaselines();

      // 2. SIMD Performance Tests
      yield _this.validateSIMDPerformance();

      // 3. Speed Optimization Tests
      yield _this.validateSpeedOptimizations();

      // 4. Load Testing with 50+ Agents
      yield _this.validateLoadTesting();

      // 5. Memory Efficiency Tests
      yield _this.validateMemoryEfficiency();

      // 6. DAA Integration Tests
      yield _this.validateDAAIntegration();

      // 7. Cross-Platform Compatibility
      yield _this.validateCrossPlatform();

      // 8. Generate Comprehensive Report
      yield _this.generateValidationReport();
      return _this.testResults;
    })();
  }
  establishBaselines() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      console.log('📊 Establishing Performance Baselines...');
      const startTime = Date.now();
      try {
        // Initialize RuvSwarm for baseline measurements
        const ruvSwarm = yield RuvSwarm.initialize({
          enableNeuralNetworks: true,
          enableForecasting: true,
          loadingStrategy: 'progressive'
        });

        // Baseline: Single agent task execution
        const singleAgentStart = Date.now();
        const swarm = yield ruvSwarm.createSwarm({
          topology: 'mesh',
          maxAgents: 1,
          strategy: 'balanced'
        });
        const agent = yield swarm.spawn({
          type: 'coder'
        });
        yield agent.execute({
          task: 'Simple arithmetic: 2+2',
          timeout: 5000
        });
        const singleAgentTime = Date.now() - singleAgentStart;

        // Baseline: Memory usage
        const memUsage = process.memoryUsage();

        // Baseline: WASM loading time
        const wasmStart = Date.now();
        const wasmSupport = yield ruvSwarm.detectSIMDSupport();
        const wasmLoadTime = Date.now() - wasmStart;
        _this2.baselines = {
          singleAgentExecution: singleAgentTime,
          baseMemoryUsage: memUsage.heapUsed,
          wasmLoadTime: wasmLoadTime,
          simdSupport: wasmSupport
        };
        console.log(`✅ Baselines established in ${Date.now() - startTime}ms`);
        console.log(`   Single Agent: ${singleAgentTime}ms`);
        console.log(`   Memory: ${(memUsage.heapUsed / 1024 / 1024).toFixed(1)}MB`);
        console.log(`   WASM Load: ${wasmLoadTime}ms`);
        console.log(`   SIMD Support: ${wasmSupport}\n`);
      } catch (error) {
        console.error('❌ Failed to establish baselines:', error.message);
        throw error;
      }
    })();
  }
  validateSIMDPerformance() {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      console.log('⚡ Validating SIMD Performance (Target: 6-10x improvement)...');
      const testResult = {
        test: 'SIMD Performance',
        target: '6-10x improvement',
        startTime: Date.now(),
        passed: false,
        metrics: {}
      };
      try {
        const ruvSwarm = yield RuvSwarm.initialize({
          enableNeuralNetworks: true,
          enableSIMD: false
        });

        // Test without SIMD
        const noSIMDStart = Date.now();
        const swarmNoSIMD = yield ruvSwarm.createSwarm({
          topology: 'mesh',
          maxAgents: 4
        });
        for (let i = 0; i < 4; i++) {
          const agent = yield swarmNoSIMD.spawn({
            type: 'optimizer'
          });
          yield agent.execute({
            task: 'Matrix multiplication: 100x100',
            timeout: 10000
          });
        }
        const noSIMDTime = Date.now() - noSIMDStart;

        // Test with SIMD
        const ruvSwarmSIMD = yield RuvSwarm.initialize({
          enableNeuralNetworks: true,
          enableSIMD: true
        });
        const simdStart = Date.now();
        const swarmSIMD = yield ruvSwarmSIMD.createSwarm({
          topology: 'mesh',
          maxAgents: 4
        });
        for (let i = 0; i < 4; i++) {
          const agent = yield swarmSIMD.spawn({
            type: 'optimizer'
          });
          yield agent.execute({
            task: 'Matrix multiplication: 100x100 (SIMD)',
            timeout: 10000
          });
        }
        const simdTime = Date.now() - simdStart;
        const improvement = noSIMDTime / simdTime;
        testResult.metrics = {
          noSIMDTime,
          simdTime,
          improvement: improvement.toFixed(2) + 'x'
        };
        testResult.passed = improvement >= 6.0 && improvement <= 10.0;
        _this3.testResults.performance.simd.actual = improvement.toFixed(2) + 'x';
        _this3.testResults.performance.simd.passed = testResult.passed;
        console.log(`   No SIMD: ${noSIMDTime}ms`);
        console.log(`   With SIMD: ${simdTime}ms`);
        console.log(`   Improvement: ${improvement.toFixed(2)}x`);
        console.log(`   ${testResult.passed ? '✅ PASSED' : '❌ FAILED'} (Target: 6-10x)\n`);
      } catch (error) {
        testResult.error = error.message;
        console.error(`❌ SIMD test failed: ${error.message}\n`);
      }
      testResult.duration = Date.now() - testResult.startTime;
      _this3.testResults.tests.push(testResult);
    })();
  }
  validateSpeedOptimizations() {
    var _this4 = this;
    return _asyncToGenerator(function* () {
      console.log('🏃 Validating Speed Optimizations (Target: 2.8-4.4x improvement)...');
      const testResult = {
        test: 'Speed Optimizations',
        target: '2.8-4.4x improvement',
        startTime: Date.now(),
        passed: false,
        metrics: {}
      };
      try {
        // Test baseline speed (conservative settings)
        const baselineTime = yield _this4.measureExecutionTime({
          topology: 'star',
          maxAgents: 1,
          strategy: 'sequential',
          optimizations: false
        });

        // Test optimized speed
        const optimizedTime = yield _this4.measureExecutionTime({
          topology: 'mesh',
          maxAgents: 6,
          strategy: 'parallel',
          optimizations: true
        });
        const speedup = baselineTime / optimizedTime;
        testResult.metrics = {
          baselineTime,
          optimizedTime,
          speedup: speedup.toFixed(2) + 'x'
        };
        testResult.passed = speedup >= 2.8 && speedup <= 4.4;
        _this4.testResults.performance.speed.actual = speedup.toFixed(2) + 'x';
        _this4.testResults.performance.speed.passed = testResult.passed;
        console.log(`   Baseline: ${baselineTime}ms`);
        console.log(`   Optimized: ${optimizedTime}ms`);
        console.log(`   Speedup: ${speedup.toFixed(2)}x`);
        console.log(`   ${testResult.passed ? '✅ PASSED' : '❌ FAILED'} (Target: 2.8-4.4x)\n`);
      } catch (error) {
        testResult.error = error.message;
        console.error(`❌ Speed optimization test failed: ${error.message}\n`);
      }
      testResult.duration = Date.now() - testResult.startTime;
      _this4.testResults.tests.push(testResult);
    })();
  }
  validateLoadTesting() {
    var _this5 = this;
    return _asyncToGenerator(function* () {
      console.log('🔥 Validating Load Testing (Target: 50+ concurrent agents)...');
      const testResult = {
        test: 'Load Testing',
        target: '50+ concurrent agents',
        startTime: Date.now(),
        passed: false,
        metrics: {}
      };
      try {
        const ruvSwarm = yield RuvSwarm.initialize({
          enableNeuralNetworks: true,
          enableForecasting: true,
          loadingStrategy: 'progressive'
        });
        const swarm = yield ruvSwarm.createSwarm({
          topology: 'hierarchical',
          maxAgents: 60,
          strategy: 'parallel'
        });
        const agents = [];
        const startTime = Date.now();

        // Spawn 55 agents in parallel
        const spawnPromises = [];
        for (let i = 0; i < 55; i++) {
          spawnPromises.push(swarm.spawn({
            type: i % 5 === 0 ? 'coordinator' : 'coder',
            name: `agent-${i}`
          }));
        }
        const spawnedAgents = yield Promise.all(spawnPromises);
        agents.push(...spawnedAgents);

        // Execute tasks concurrently
        const taskPromises = agents.map((agent, i) => agent.execute({
          task: `Task ${i}: Calculate fibonacci(20)`,
          timeout: 15000
        }));
        yield Promise.all(taskPromises);
        const totalTime = Date.now() - startTime;
        const memUsage = process.memoryUsage();
        const memoryMB = memUsage.heapUsed / 1024 / 1024;
        testResult.metrics = {
          agentsSpawned: agents.length,
          executionTime: totalTime,
          memoryUsage: memoryMB.toFixed(1) + 'MB',
          avgTimePerAgent: (totalTime / agents.length).toFixed(1) + 'ms'
        };
        testResult.passed = agents.length >= 50 && totalTime < 30000; // 30 second limit
        _this5.testResults.performance.loadTesting.actual = `${agents.length} agents`;
        _this5.testResults.performance.loadTesting.passed = testResult.passed;
        console.log(`   Agents spawned: ${agents.length}`);
        console.log(`   Total time: ${totalTime}ms`);
        console.log(`   Memory usage: ${memoryMB.toFixed(1)}MB`);
        console.log(`   Avg per agent: ${(totalTime / agents.length).toFixed(1)}ms`);
        console.log(`   ${testResult.passed ? '✅ PASSED' : '❌ FAILED'} (Target: 50+ agents)\n`);
      } catch (error) {
        testResult.error = error.message;
        console.error(`❌ Load testing failed: ${error.message}\n`);
      }
      testResult.duration = Date.now() - testResult.startTime;
      _this5.testResults.tests.push(testResult);
    })();
  }
  validateMemoryEfficiency() {
    var _this6 = this;
    return _asyncToGenerator(function* () {
      console.log('💾 Validating Memory Efficiency (Target: <500MB @ 50 agents)...');
      const testResult = {
        test: 'Memory Efficiency',
        target: '<500MB @ 50 agents',
        startTime: Date.now(),
        passed: false,
        metrics: {}
      };
      try {
        const ruvSwarm = yield RuvSwarm.initialize({
          enableNeuralNetworks: true,
          memoryOptimization: true
        });
        const initialMemory = process.memoryUsage().heapUsed / 1024 / 1024;
        const swarm = yield ruvSwarm.createSwarm({
          topology: 'mesh',
          maxAgents: 50,
          strategy: 'balanced'
        });
        const agents = [];
        for (let i = 0; i < 50; i++) {
          const agent = yield swarm.spawn({
            type: 'coder'
          });
          agents.push(agent);
        }
        const peakMemory = process.memoryUsage().heapUsed / 1024 / 1024;
        const memoryIncrease = peakMemory - initialMemory;
        testResult.metrics = {
          initialMemory: initialMemory.toFixed(1) + 'MB',
          peakMemory: peakMemory.toFixed(1) + 'MB',
          memoryIncrease: memoryIncrease.toFixed(1) + 'MB',
          memoryPerAgent: (memoryIncrease / 50).toFixed(1) + 'MB'
        };
        testResult.passed = peakMemory < 500;
        _this6.testResults.performance.memoryEfficiency.actual = peakMemory.toFixed(1) + 'MB';
        _this6.testResults.performance.memoryEfficiency.passed = testResult.passed;
        console.log(`   Initial memory: ${initialMemory.toFixed(1)}MB`);
        console.log(`   Peak memory: ${peakMemory.toFixed(1)}MB`);
        console.log(`   Memory increase: ${memoryIncrease.toFixed(1)}MB`);
        console.log(`   Per agent: ${(memoryIncrease / 50).toFixed(1)}MB`);
        console.log(`   ${testResult.passed ? '✅ PASSED' : '❌ FAILED'} (Target: <500MB)\n`);
      } catch (error) {
        testResult.error = error.message;
        console.error(`❌ Memory efficiency test failed: ${error.message}\n`);
      }
      testResult.duration = Date.now() - testResult.startTime;
      _this6.testResults.tests.push(testResult);
    })();
  }
  validateDAAIntegration() {
    var _this7 = this;
    return _asyncToGenerator(function* () {
      console.log('🔗 Validating DAA Integration (Target: seamless integration)...');
      const testResult = {
        test: 'DAA Integration',
        target: 'seamless integration',
        startTime: Date.now(),
        passed: false,
        metrics: {}
      };
      try {
        // Test DAA AI module integration
        const daaPath = '/workspaces/ruv-FANN/daa-repository';
        const daaExists = yield _this7.checkPathExists(daaPath);
        if (!daaExists) {
          throw new Error('DAA repository not found');
        }

        // Test Rust integration
        const cargoTest = yield _this7.runCommand('cargo test --manifest-path /workspaces/ruv-FANN/daa-repository/Cargo.toml');

        // Test MCP integration
        const mcpTest = yield _this7.testMCPIntegration();
        testResult.metrics = {
          daaRepositoryExists: daaExists,
          cargoTestsPassed: cargoTest.success,
          mcpIntegrationWorking: mcpTest.success,
          integrationPoints: ['AI module', 'MCP server', 'WASM bindings']
        };
        testResult.passed = daaExists && cargoTest.success && mcpTest.success;
        _this7.testResults.performance.daaIntegration.actual = testResult.passed ? 'integrated' : 'partial';
        _this7.testResults.performance.daaIntegration.passed = testResult.passed;
        console.log(`   DAA Repository: ${daaExists ? '✅' : '❌'}`);
        console.log(`   Cargo Tests: ${cargoTest.success ? '✅' : '❌'}`);
        console.log(`   MCP Integration: ${mcpTest.success ? '✅' : '❌'}`);
        console.log(`   ${testResult.passed ? '✅ PASSED' : '❌ FAILED'} (Target: seamless)\n`);
      } catch (error) {
        testResult.error = error.message;
        console.error(`❌ DAA integration test failed: ${error.message}\n`);
      }
      testResult.duration = Date.now() - testResult.startTime;
      _this7.testResults.tests.push(testResult);
    })();
  }
  validateCrossPlatform() {
    var _this8 = this;
    return _asyncToGenerator(function* () {
      console.log('🌐 Validating Cross-Platform Compatibility...');
      const testResult = {
        test: 'Cross-Platform Compatibility',
        target: 'Linux, macOS, Windows support',
        startTime: Date.now(),
        passed: false,
        metrics: {}
      };
      try {
        const platform = process.platform;
        const arch = process.arch;
        const nodeVersion = process.version;

        // Test WASM compatibility
        const wasmCompatible = yield _this8.testWASMCompatibility();

        // Test SQLite compatibility
        const sqliteCompatible = yield _this8.testSQLiteCompatibility();

        // Test Node.js version compatibility
        const nodeCompatible = _this8.checkNodeCompatibility(nodeVersion);
        testResult.metrics = {
          platform,
          architecture: arch,
          nodeVersion,
          wasmCompatible,
          sqliteCompatible,
          nodeCompatible
        };
        testResult.passed = wasmCompatible && sqliteCompatible && nodeCompatible;
        console.log(`   Platform: ${platform} ${arch}`);
        console.log(`   Node.js: ${nodeVersion} ${nodeCompatible ? '✅' : '❌'}`);
        console.log(`   WASM: ${wasmCompatible ? '✅' : '❌'}`);
        console.log(`   SQLite: ${sqliteCompatible ? '✅' : '❌'}`);
        console.log(`   ${testResult.passed ? '✅ PASSED' : '❌ FAILED'}\n`);
      } catch (error) {
        testResult.error = error.message;
        console.error(`❌ Cross-platform test failed: ${error.message}\n`);
      }
      testResult.duration = Date.now() - testResult.startTime;
      _this8.testResults.tests.push(testResult);
    })();
  }
  generateValidationReport() {
    var _this9 = this;
    return _asyncToGenerator(function* () {
      console.log('📄 Generating Comprehensive Validation Report...');
      const passedTests = _this9.testResults.tests.filter(t => t.passed).length;
      const totalTests = _this9.testResults.tests.length;
      const successRate = (passedTests / totalTests * 100).toFixed(1);
      const report = _objectSpread(_objectSpread({}, _this9.testResults), {}, {
        summary: {
          totalTests,
          passedTests,
          failedTests: totalTests - passedTests,
          successRate: successRate + '%',
          overallPassed: successRate >= 90
        },
        recommendations: _this9.generateRecommendations()
      });

      // Save detailed report
      const reportPath = '/workspaces/ruv-FANN/ruv-swarm/npm/test/validation-report.json';
      yield fs.writeFile(reportPath, JSON.stringify(report, null, 2));

      // Generate readable summary
      console.log('\n📊 VALIDATION SUMMARY');
      console.log('=====================');
      console.log(`Tests Passed: ${passedTests}/${totalTests} (${successRate}%)`);
      console.log(`Overall Status: ${report.summary.overallPassed ? '✅ PASSED' : '❌ FAILED'}`);
      console.log('\n🎯 Performance Targets:');
      Object.entries(_this9.testResults.performance).forEach(([key, value]) => {
        console.log(`   ${key}: ${value.actual || 'N/A'} ${value.passed ? '✅' : '❌'} (Target: ${value.target})`);
      });
      if (report.recommendations.length > 0) {
        console.log('\n💡 Recommendations:');
        report.recommendations.forEach((rec, i) => {
          console.log(`   ${i + 1}. ${rec}`);
        });
      }
      console.log(`\n📄 Detailed report saved to: ${reportPath}`);
      return report;
    })();
  }

  // Helper methods
  measureExecutionTime(config) {
    return _asyncToGenerator(function* () {
      const ruvSwarm = yield RuvSwarm.initialize({
        enableNeuralNetworks: true,
        enableOptimizations: config.optimizations
      });
      const start = Date.now();
      const swarm = yield ruvSwarm.createSwarm(config);
      const agents = [];
      for (let i = 0; i < config.maxAgents; i++) {
        agents.push(yield swarm.spawn({
          type: 'coder'
        }));
      }
      const tasks = agents.map(agent => agent.execute({
        task: 'Calculate: sum(1..1000)',
        timeout: 10000
      }));
      if (config.strategy === 'parallel') {
        yield Promise.all(tasks);
      } else {
        for (const task of tasks) {
          yield task;
        }
      }
      return Date.now() - start;
    })();
  }
  checkPathExists(path) {
    return _asyncToGenerator(function* () {
      try {
        yield fs.access(path);
        return true;
      } catch {
        return false;
      }
    })();
  }
  runCommand(command) {
    return _asyncToGenerator(function* () {
      return new Promise(resolve => {
        const [cmd, ...args] = command.split(' ');
        const process = spawn(cmd, args, {
          stdio: 'pipe'
        });
        let output = '';
        process.stdout.on('data', data => output += data.toString());
        process.stderr.on('data', data => output += data.toString());
        process.on('close', code => {
          resolve({
            success: code === 0,
            output
          });
        });
        setTimeout(() => {
          process.kill();
          resolve({
            success: false,
            output: 'Timeout'
          });
        }, 30000);
      });
    })();
  }
  testMCPIntegration() {
    return _asyncToGenerator(function* () {
      try {
        // Test basic MCP functionality
        const {
          mcp
        } = require('../src/mcp-tools-enhanced');
        return {
          success: true
        };
      } catch {
        return {
          success: false
        };
      }
    })();
  }
  testWASMCompatibility() {
    return _asyncToGenerator(function* () {
      try {
        const ruvSwarm = yield RuvSwarm.initialize();
        return (yield ruvSwarm.detectSIMDSupport()) !== undefined;
      } catch {
        return false;
      }
    })();
  }
  testSQLiteCompatibility() {
    return _asyncToGenerator(function* () {
      try {
        const {
          PersistenceManager
        } = require('../src/persistence');
        const pm = new PersistenceManager(':memory:');
        yield pm.initialize();
        return true;
      } catch {
        return false;
      }
    })();
  }
  checkNodeCompatibility(version) {
    const major = parseInt(version.slice(1).split('.')[0]);
    return major >= 14; // Minimum Node.js 14
  }
  generateRecommendations() {
    const recommendations = [];
    this.testResults.tests.forEach(test => {
      if (!test.passed) {
        switch (test.test) {
          case 'SIMD Performance':
            recommendations.push('Enable SIMD optimizations and verify WASM module compilation');
            break;
          case 'Speed Optimizations':
            recommendations.push('Review parallel execution strategy and agent coordination');
            break;
          case 'Load Testing':
            recommendations.push('Optimize memory usage and consider agent pooling');
            break;
          case 'Memory Efficiency':
            recommendations.push('Implement memory pooling and garbage collection tuning');
            break;
          case 'DAA Integration':
            recommendations.push('Verify DAA repository setup and MCP server configuration');
            break;
        }
      }
    });
    return recommendations;
  }
}

// Main execution
function runValidation() {
  return _runValidation.apply(this, arguments);
}
function _runValidation() {
  _runValidation = _asyncToGenerator(function* () {
    try {
      const validator = new PerformanceValidator();
      const results = yield validator.runComprehensiveValidation();
      process.exit(results.summary.overallPassed ? 0 : 1);
    } catch (error) {
      console.error('💥 Validation failed:', error);
      process.exit(1);
    }
  });
  return _runValidation.apply(this, arguments);
}
if (require.main === module) {
  runValidation();
}
module.exports = {
  PerformanceValidator
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJSdXZTd2FybSIsInJlcXVpcmUiLCJwZXJmb3JtYW5jZUNMSSIsImZzIiwicHJvbWlzZXMiLCJwYXRoIiwic3Bhd24iLCJQZXJmb3JtYW5jZVZhbGlkYXRvciIsImNvbnN0cnVjdG9yIiwidGVzdFJlc3VsdHMiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ0ZXN0cyIsInBlcmZvcm1hbmNlIiwic2ltZCIsInRhcmdldCIsImFjdHVhbCIsInBhc3NlZCIsInNwZWVkIiwibG9hZFRlc3RpbmciLCJtZW1vcnlFZmZpY2llbmN5IiwiZGFhSW50ZWdyYXRpb24iLCJjb3ZlcmFnZSIsImxpbmVzIiwiYnJhbmNoZXMiLCJmdW5jdGlvbnMiLCJzdGF0ZW1lbnRzIiwicmVjb21tZW5kYXRpb25zIiwiYmFzZWxpbmVzIiwicnVuQ29tcHJlaGVuc2l2ZVZhbGlkYXRpb24iLCJfdGhpcyIsIl9hc3luY1RvR2VuZXJhdG9yIiwiY29uc29sZSIsImxvZyIsImVzdGFibGlzaEJhc2VsaW5lcyIsInZhbGlkYXRlU0lNRFBlcmZvcm1hbmNlIiwidmFsaWRhdGVTcGVlZE9wdGltaXphdGlvbnMiLCJ2YWxpZGF0ZUxvYWRUZXN0aW5nIiwidmFsaWRhdGVNZW1vcnlFZmZpY2llbmN5IiwidmFsaWRhdGVEQUFJbnRlZ3JhdGlvbiIsInZhbGlkYXRlQ3Jvc3NQbGF0Zm9ybSIsImdlbmVyYXRlVmFsaWRhdGlvblJlcG9ydCIsIl90aGlzMiIsInN0YXJ0VGltZSIsIm5vdyIsInJ1dlN3YXJtIiwiaW5pdGlhbGl6ZSIsImVuYWJsZU5ldXJhbE5ldHdvcmtzIiwiZW5hYmxlRm9yZWNhc3RpbmciLCJsb2FkaW5nU3RyYXRlZ3kiLCJzaW5nbGVBZ2VudFN0YXJ0Iiwic3dhcm0iLCJjcmVhdGVTd2FybSIsInRvcG9sb2d5IiwibWF4QWdlbnRzIiwic3RyYXRlZ3kiLCJhZ2VudCIsInR5cGUiLCJleGVjdXRlIiwidGFzayIsInRpbWVvdXQiLCJzaW5nbGVBZ2VudFRpbWUiLCJtZW1Vc2FnZSIsInByb2Nlc3MiLCJtZW1vcnlVc2FnZSIsIndhc21TdGFydCIsIndhc21TdXBwb3J0IiwiZGV0ZWN0U0lNRFN1cHBvcnQiLCJ3YXNtTG9hZFRpbWUiLCJzaW5nbGVBZ2VudEV4ZWN1dGlvbiIsImJhc2VNZW1vcnlVc2FnZSIsImhlYXBVc2VkIiwic2ltZFN1cHBvcnQiLCJ0b0ZpeGVkIiwiZXJyb3IiLCJtZXNzYWdlIiwiX3RoaXMzIiwidGVzdFJlc3VsdCIsInRlc3QiLCJtZXRyaWNzIiwiZW5hYmxlU0lNRCIsIm5vU0lNRFN0YXJ0Iiwic3dhcm1Ob1NJTUQiLCJpIiwibm9TSU1EVGltZSIsInJ1dlN3YXJtU0lNRCIsInNpbWRTdGFydCIsInN3YXJtU0lNRCIsInNpbWRUaW1lIiwiaW1wcm92ZW1lbnQiLCJkdXJhdGlvbiIsInB1c2giLCJfdGhpczQiLCJiYXNlbGluZVRpbWUiLCJtZWFzdXJlRXhlY3V0aW9uVGltZSIsIm9wdGltaXphdGlvbnMiLCJvcHRpbWl6ZWRUaW1lIiwic3BlZWR1cCIsIl90aGlzNSIsImFnZW50cyIsInNwYXduUHJvbWlzZXMiLCJuYW1lIiwic3Bhd25lZEFnZW50cyIsIlByb21pc2UiLCJhbGwiLCJ0YXNrUHJvbWlzZXMiLCJtYXAiLCJ0b3RhbFRpbWUiLCJtZW1vcnlNQiIsImFnZW50c1NwYXduZWQiLCJsZW5ndGgiLCJleGVjdXRpb25UaW1lIiwiYXZnVGltZVBlckFnZW50IiwiX3RoaXM2IiwibWVtb3J5T3B0aW1pemF0aW9uIiwiaW5pdGlhbE1lbW9yeSIsInBlYWtNZW1vcnkiLCJtZW1vcnlJbmNyZWFzZSIsIm1lbW9yeVBlckFnZW50IiwiX3RoaXM3IiwiZGFhUGF0aCIsImRhYUV4aXN0cyIsImNoZWNrUGF0aEV4aXN0cyIsIkVycm9yIiwiY2FyZ29UZXN0IiwicnVuQ29tbWFuZCIsIm1jcFRlc3QiLCJ0ZXN0TUNQSW50ZWdyYXRpb24iLCJkYWFSZXBvc2l0b3J5RXhpc3RzIiwiY2FyZ29UZXN0c1Bhc3NlZCIsInN1Y2Nlc3MiLCJtY3BJbnRlZ3JhdGlvbldvcmtpbmciLCJpbnRlZ3JhdGlvblBvaW50cyIsIl90aGlzOCIsInBsYXRmb3JtIiwiYXJjaCIsIm5vZGVWZXJzaW9uIiwidmVyc2lvbiIsIndhc21Db21wYXRpYmxlIiwidGVzdFdBU01Db21wYXRpYmlsaXR5Iiwic3FsaXRlQ29tcGF0aWJsZSIsInRlc3RTUUxpdGVDb21wYXRpYmlsaXR5Iiwibm9kZUNvbXBhdGlibGUiLCJjaGVja05vZGVDb21wYXRpYmlsaXR5IiwiYXJjaGl0ZWN0dXJlIiwiX3RoaXM5IiwicGFzc2VkVGVzdHMiLCJmaWx0ZXIiLCJ0IiwidG90YWxUZXN0cyIsInN1Y2Nlc3NSYXRlIiwicmVwb3J0IiwiX29iamVjdFNwcmVhZCIsInN1bW1hcnkiLCJmYWlsZWRUZXN0cyIsIm92ZXJhbGxQYXNzZWQiLCJnZW5lcmF0ZVJlY29tbWVuZGF0aW9ucyIsInJlcG9ydFBhdGgiLCJ3cml0ZUZpbGUiLCJKU09OIiwic3RyaW5naWZ5IiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJrZXkiLCJ2YWx1ZSIsInJlYyIsImNvbmZpZyIsImVuYWJsZU9wdGltaXphdGlvbnMiLCJzdGFydCIsInRhc2tzIiwiYWNjZXNzIiwiY29tbWFuZCIsInJlc29sdmUiLCJjbWQiLCJhcmdzIiwic3BsaXQiLCJzdGRpbyIsIm91dHB1dCIsInN0ZG91dCIsIm9uIiwiZGF0YSIsInRvU3RyaW5nIiwic3RkZXJyIiwiY29kZSIsInNldFRpbWVvdXQiLCJraWxsIiwibWNwIiwidW5kZWZpbmVkIiwiUGVyc2lzdGVuY2VNYW5hZ2VyIiwicG0iLCJtYWpvciIsInBhcnNlSW50Iiwic2xpY2UiLCJydW5WYWxpZGF0aW9uIiwiX3J1blZhbGlkYXRpb24iLCJhcHBseSIsImFyZ3VtZW50cyIsInZhbGlkYXRvciIsInJlc3VsdHMiLCJleGl0IiwibWFpbiIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlcyI6WyJjb21wcmVoZW5zaXZlLXBlcmZvcm1hbmNlLXZhbGlkYXRpb24udGVzdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuLyoqXG4gKiBDb21wcmVoZW5zaXZlIFBlcmZvcm1hbmNlIFZhbGlkYXRpb24gRnJhbWV3b3JrXG4gKiBUZXN0cyBhbGwgcGVyZm9ybWFuY2UgdGFyZ2V0cyBhbmQgdmFsaWRhdGVzIERBQSBpbnRlZ3JhdGlvblxuICovXG5cbmNvbnN0IHsgUnV2U3dhcm0gfSA9IHJlcXVpcmUoJy4uL3NyYy9pbmRleC1lbmhhbmNlZCcpO1xuY29uc3QgeyBwZXJmb3JtYW5jZUNMSSB9ID0gcmVxdWlyZSgnLi4vc3JjL3BlcmZvcm1hbmNlJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJykucHJvbWlzZXM7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgeyBzcGF3biB9ID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpO1xuXG5jbGFzcyBQZXJmb3JtYW5jZVZhbGlkYXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudGVzdFJlc3VsdHMgPSB7XG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIHRlc3RzOiBbXSxcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlOiB7XG4gICAgICAgICAgICAgICAgc2ltZDogeyB0YXJnZXQ6ICc2LTEweCcsIGFjdHVhbDogbnVsbCwgcGFzc2VkOiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgIHNwZWVkOiB7IHRhcmdldDogJzIuOC00LjR4JywgYWN0dWFsOiBudWxsLCBwYXNzZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgbG9hZFRlc3Rpbmc6IHsgdGFyZ2V0OiAnNTArIGFnZW50cycsIGFjdHVhbDogbnVsbCwgcGFzc2VkOiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgIG1lbW9yeUVmZmljaWVuY3k6IHsgdGFyZ2V0OiAnPDUwME1CQDUwYWdlbnRzJywgYWN0dWFsOiBudWxsLCBwYXNzZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgZGFhSW50ZWdyYXRpb246IHsgdGFyZ2V0OiAnc2VhbWxlc3MnLCBhY3R1YWw6IG51bGwsIHBhc3NlZDogZmFsc2UgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvdmVyYWdlOiB7XG4gICAgICAgICAgICAgICAgbGluZXM6IDAsXG4gICAgICAgICAgICAgICAgYnJhbmNoZXM6IDAsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25zOiAwLFxuICAgICAgICAgICAgICAgIHN0YXRlbWVudHM6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWNvbW1lbmRhdGlvbnM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYmFzZWxpbmVzID0ge307XG4gICAgfVxuXG4gICAgYXN5bmMgcnVuQ29tcHJlaGVuc2l2ZVZhbGlkYXRpb24oKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5qAIFN0YXJ0aW5nIENvbXByZWhlbnNpdmUgUGVyZm9ybWFuY2UgVmFsaWRhdGlvblxcbicpO1xuICAgICAgICBcbiAgICAgICAgLy8gMS4gRXN0YWJsaXNoIGJhc2VsaW5lc1xuICAgICAgICBhd2FpdCB0aGlzLmVzdGFibGlzaEJhc2VsaW5lcygpO1xuICAgICAgICBcbiAgICAgICAgLy8gMi4gU0lNRCBQZXJmb3JtYW5jZSBUZXN0c1xuICAgICAgICBhd2FpdCB0aGlzLnZhbGlkYXRlU0lNRFBlcmZvcm1hbmNlKCk7XG4gICAgICAgIFxuICAgICAgICAvLyAzLiBTcGVlZCBPcHRpbWl6YXRpb24gVGVzdHNcbiAgICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZVNwZWVkT3B0aW1pemF0aW9ucygpO1xuICAgICAgICBcbiAgICAgICAgLy8gNC4gTG9hZCBUZXN0aW5nIHdpdGggNTArIEFnZW50c1xuICAgICAgICBhd2FpdCB0aGlzLnZhbGlkYXRlTG9hZFRlc3RpbmcoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIDUuIE1lbW9yeSBFZmZpY2llbmN5IFRlc3RzXG4gICAgICAgIGF3YWl0IHRoaXMudmFsaWRhdGVNZW1vcnlFZmZpY2llbmN5KCk7XG4gICAgICAgIFxuICAgICAgICAvLyA2LiBEQUEgSW50ZWdyYXRpb24gVGVzdHNcbiAgICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZURBQUludGVncmF0aW9uKCk7XG4gICAgICAgIFxuICAgICAgICAvLyA3LiBDcm9zcy1QbGF0Zm9ybSBDb21wYXRpYmlsaXR5XG4gICAgICAgIGF3YWl0IHRoaXMudmFsaWRhdGVDcm9zc1BsYXRmb3JtKCk7XG4gICAgICAgIFxuICAgICAgICAvLyA4LiBHZW5lcmF0ZSBDb21wcmVoZW5zaXZlIFJlcG9ydFxuICAgICAgICBhd2FpdCB0aGlzLmdlbmVyYXRlVmFsaWRhdGlvblJlcG9ydCgpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXMudGVzdFJlc3VsdHM7XG4gICAgfVxuXG4gICAgYXN5bmMgZXN0YWJsaXNoQmFzZWxpbmVzKCkge1xuICAgICAgICBjb25zb2xlLmxvZygn8J+TiiBFc3RhYmxpc2hpbmcgUGVyZm9ybWFuY2UgQmFzZWxpbmVzLi4uJyk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgUnV2U3dhcm0gZm9yIGJhc2VsaW5lIG1lYXN1cmVtZW50c1xuICAgICAgICAgICAgY29uc3QgcnV2U3dhcm0gPSBhd2FpdCBSdXZTd2FybS5pbml0aWFsaXplKHtcbiAgICAgICAgICAgICAgICBlbmFibGVOZXVyYWxOZXR3b3JrczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbmFibGVGb3JlY2FzdGluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBsb2FkaW5nU3RyYXRlZ3k6ICdwcm9ncmVzc2l2ZSdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBCYXNlbGluZTogU2luZ2xlIGFnZW50IHRhc2sgZXhlY3V0aW9uXG4gICAgICAgICAgICBjb25zdCBzaW5nbGVBZ2VudFN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGNvbnN0IHN3YXJtID0gYXdhaXQgcnV2U3dhcm0uY3JlYXRlU3dhcm0oeyBcbiAgICAgICAgICAgICAgICB0b3BvbG9neTogJ21lc2gnLCBcbiAgICAgICAgICAgICAgICBtYXhBZ2VudHM6IDEsXG4gICAgICAgICAgICAgICAgc3RyYXRlZ3k6ICdiYWxhbmNlZCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYWdlbnQgPSBhd2FpdCBzd2FybS5zcGF3bih7IHR5cGU6ICdjb2RlcicgfSk7XG4gICAgICAgICAgICBhd2FpdCBhZ2VudC5leGVjdXRlKHsgdGFzazogJ1NpbXBsZSBhcml0aG1ldGljOiAyKzInLCB0aW1lb3V0OiA1MDAwIH0pO1xuICAgICAgICAgICAgY29uc3Qgc2luZ2xlQWdlbnRUaW1lID0gRGF0ZS5ub3coKSAtIHNpbmdsZUFnZW50U3RhcnQ7XG5cbiAgICAgICAgICAgIC8vIEJhc2VsaW5lOiBNZW1vcnkgdXNhZ2VcbiAgICAgICAgICAgIGNvbnN0IG1lbVVzYWdlID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpO1xuXG4gICAgICAgICAgICAvLyBCYXNlbGluZTogV0FTTSBsb2FkaW5nIHRpbWVcbiAgICAgICAgICAgIGNvbnN0IHdhc21TdGFydCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBjb25zdCB3YXNtU3VwcG9ydCA9IGF3YWl0IHJ1dlN3YXJtLmRldGVjdFNJTURTdXBwb3J0KCk7XG4gICAgICAgICAgICBjb25zdCB3YXNtTG9hZFRpbWUgPSBEYXRlLm5vdygpIC0gd2FzbVN0YXJ0O1xuXG4gICAgICAgICAgICB0aGlzLmJhc2VsaW5lcyA9IHtcbiAgICAgICAgICAgICAgICBzaW5nbGVBZ2VudEV4ZWN1dGlvbjogc2luZ2xlQWdlbnRUaW1lLFxuICAgICAgICAgICAgICAgIGJhc2VNZW1vcnlVc2FnZTogbWVtVXNhZ2UuaGVhcFVzZWQsXG4gICAgICAgICAgICAgICAgd2FzbUxvYWRUaW1lOiB3YXNtTG9hZFRpbWUsXG4gICAgICAgICAgICAgICAgc2ltZFN1cHBvcnQ6IHdhc21TdXBwb3J0XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEJhc2VsaW5lcyBlc3RhYmxpc2hlZCBpbiAke0RhdGUubm93KCkgLSBzdGFydFRpbWV9bXNgKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICBTaW5nbGUgQWdlbnQ6ICR7c2luZ2xlQWdlbnRUaW1lfW1zYCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgTWVtb3J5OiAkeyhtZW1Vc2FnZS5oZWFwVXNlZCAvIDEwMjQgLyAxMDI0KS50b0ZpeGVkKDEpfU1CYCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgV0FTTSBMb2FkOiAke3dhc21Mb2FkVGltZX1tc2ApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYCAgIFNJTUQgU3VwcG9ydDogJHt3YXNtU3VwcG9ydH1cXG5gKTtcblxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBlc3RhYmxpc2ggYmFzZWxpbmVzOicsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyB2YWxpZGF0ZVNJTURQZXJmb3JtYW5jZSgpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KaoSBWYWxpZGF0aW5nIFNJTUQgUGVyZm9ybWFuY2UgKFRhcmdldDogNi0xMHggaW1wcm92ZW1lbnQpLi4uJyk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB0ZXN0UmVzdWx0ID0ge1xuICAgICAgICAgICAgdGVzdDogJ1NJTUQgUGVyZm9ybWFuY2UnLFxuICAgICAgICAgICAgdGFyZ2V0OiAnNi0xMHggaW1wcm92ZW1lbnQnLFxuICAgICAgICAgICAgc3RhcnRUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgcGFzc2VkOiBmYWxzZSxcbiAgICAgICAgICAgIG1ldHJpY3M6IHt9XG4gICAgICAgIH07XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJ1dlN3YXJtID0gYXdhaXQgUnV2U3dhcm0uaW5pdGlhbGl6ZSh7XG4gICAgICAgICAgICAgICAgZW5hYmxlTmV1cmFsTmV0d29ya3M6IHRydWUsXG4gICAgICAgICAgICAgICAgZW5hYmxlU0lNRDogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBUZXN0IHdpdGhvdXQgU0lNRFxuICAgICAgICAgICAgY29uc3Qgbm9TSU1EU3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgY29uc3Qgc3dhcm1Ob1NJTUQgPSBhd2FpdCBydXZTd2FybS5jcmVhdGVTd2FybSh7IHRvcG9sb2d5OiAnbWVzaCcsIG1heEFnZW50czogNCB9KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWdlbnQgPSBhd2FpdCBzd2FybU5vU0lNRC5zcGF3bih7IHR5cGU6ICdvcHRpbWl6ZXInIH0pO1xuICAgICAgICAgICAgICAgIGF3YWl0IGFnZW50LmV4ZWN1dGUoeyBcbiAgICAgICAgICAgICAgICAgICAgdGFzazogJ01hdHJpeCBtdWx0aXBsaWNhdGlvbjogMTAweDEwMCcsIFxuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiAxMDAwMCBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5vU0lNRFRpbWUgPSBEYXRlLm5vdygpIC0gbm9TSU1EU3RhcnQ7XG5cbiAgICAgICAgICAgIC8vIFRlc3Qgd2l0aCBTSU1EXG4gICAgICAgICAgICBjb25zdCBydXZTd2FybVNJTUQgPSBhd2FpdCBSdXZTd2FybS5pbml0aWFsaXplKHtcbiAgICAgICAgICAgICAgICBlbmFibGVOZXVyYWxOZXR3b3JrczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbmFibGVTSU1EOiB0cnVlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3Qgc2ltZFN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGNvbnN0IHN3YXJtU0lNRCA9IGF3YWl0IHJ1dlN3YXJtU0lNRC5jcmVhdGVTd2FybSh7IHRvcG9sb2d5OiAnbWVzaCcsIG1heEFnZW50czogNCB9KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWdlbnQgPSBhd2FpdCBzd2FybVNJTUQuc3Bhd24oeyB0eXBlOiAnb3B0aW1pemVyJyB9KTtcbiAgICAgICAgICAgICAgICBhd2FpdCBhZ2VudC5leGVjdXRlKHsgXG4gICAgICAgICAgICAgICAgICAgIHRhc2s6ICdNYXRyaXggbXVsdGlwbGljYXRpb246IDEwMHgxMDAgKFNJTUQpJywgXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IDEwMDAwIFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2ltZFRpbWUgPSBEYXRlLm5vdygpIC0gc2ltZFN0YXJ0O1xuXG4gICAgICAgICAgICBjb25zdCBpbXByb3ZlbWVudCA9IG5vU0lNRFRpbWUgLyBzaW1kVGltZTtcbiAgICAgICAgICAgIHRlc3RSZXN1bHQubWV0cmljcyA9IHtcbiAgICAgICAgICAgICAgICBub1NJTURUaW1lLFxuICAgICAgICAgICAgICAgIHNpbWRUaW1lLFxuICAgICAgICAgICAgICAgIGltcHJvdmVtZW50OiBpbXByb3ZlbWVudC50b0ZpeGVkKDIpICsgJ3gnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0ZXN0UmVzdWx0LnBhc3NlZCA9IGltcHJvdmVtZW50ID49IDYuMCAmJiBpbXByb3ZlbWVudCA8PSAxMC4wO1xuICAgICAgICAgICAgdGhpcy50ZXN0UmVzdWx0cy5wZXJmb3JtYW5jZS5zaW1kLmFjdHVhbCA9IGltcHJvdmVtZW50LnRvRml4ZWQoMikgKyAneCc7XG4gICAgICAgICAgICB0aGlzLnRlc3RSZXN1bHRzLnBlcmZvcm1hbmNlLnNpbWQucGFzc2VkID0gdGVzdFJlc3VsdC5wYXNzZWQ7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICBObyBTSU1EOiAke25vU0lNRFRpbWV9bXNgKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICBXaXRoIFNJTUQ6ICR7c2ltZFRpbWV9bXNgKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICBJbXByb3ZlbWVudDogJHtpbXByb3ZlbWVudC50b0ZpeGVkKDIpfXhgKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICAke3Rlc3RSZXN1bHQucGFzc2VkID8gJ+KchSBQQVNTRUQnIDogJ+KdjCBGQUlMRUQnfSAoVGFyZ2V0OiA2LTEweClcXG5gKTtcblxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGVzdFJlc3VsdC5lcnJvciA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGDinYwgU0lNRCB0ZXN0IGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfVxcbmApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGVzdFJlc3VsdC5kdXJhdGlvbiA9IERhdGUubm93KCkgLSB0ZXN0UmVzdWx0LnN0YXJ0VGltZTtcbiAgICAgICAgdGhpcy50ZXN0UmVzdWx0cy50ZXN0cy5wdXNoKHRlc3RSZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIHZhbGlkYXRlU3BlZWRPcHRpbWl6YXRpb25zKCkge1xuICAgICAgICBjb25zb2xlLmxvZygn8J+PgyBWYWxpZGF0aW5nIFNwZWVkIE9wdGltaXphdGlvbnMgKFRhcmdldDogMi44LTQuNHggaW1wcm92ZW1lbnQpLi4uJyk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB0ZXN0UmVzdWx0ID0ge1xuICAgICAgICAgICAgdGVzdDogJ1NwZWVkIE9wdGltaXphdGlvbnMnLFxuICAgICAgICAgICAgdGFyZ2V0OiAnMi44LTQuNHggaW1wcm92ZW1lbnQnLFxuICAgICAgICAgICAgc3RhcnRUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgcGFzc2VkOiBmYWxzZSxcbiAgICAgICAgICAgIG1ldHJpY3M6IHt9XG4gICAgICAgIH07XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFRlc3QgYmFzZWxpbmUgc3BlZWQgKGNvbnNlcnZhdGl2ZSBzZXR0aW5ncylcbiAgICAgICAgICAgIGNvbnN0IGJhc2VsaW5lVGltZSA9IGF3YWl0IHRoaXMubWVhc3VyZUV4ZWN1dGlvblRpbWUoe1xuICAgICAgICAgICAgICAgIHRvcG9sb2d5OiAnc3RhcicsXG4gICAgICAgICAgICAgICAgbWF4QWdlbnRzOiAxLFxuICAgICAgICAgICAgICAgIHN0cmF0ZWd5OiAnc2VxdWVudGlhbCcsXG4gICAgICAgICAgICAgICAgb3B0aW1pemF0aW9uczogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBUZXN0IG9wdGltaXplZCBzcGVlZFxuICAgICAgICAgICAgY29uc3Qgb3B0aW1pemVkVGltZSA9IGF3YWl0IHRoaXMubWVhc3VyZUV4ZWN1dGlvblRpbWUoe1xuICAgICAgICAgICAgICAgIHRvcG9sb2d5OiAnbWVzaCcsXG4gICAgICAgICAgICAgICAgbWF4QWdlbnRzOiA2LFxuICAgICAgICAgICAgICAgIHN0cmF0ZWd5OiAncGFyYWxsZWwnLFxuICAgICAgICAgICAgICAgIG9wdGltaXphdGlvbnM6IHRydWVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBzcGVlZHVwID0gYmFzZWxpbmVUaW1lIC8gb3B0aW1pemVkVGltZTtcbiAgICAgICAgICAgIHRlc3RSZXN1bHQubWV0cmljcyA9IHtcbiAgICAgICAgICAgICAgICBiYXNlbGluZVRpbWUsXG4gICAgICAgICAgICAgICAgb3B0aW1pemVkVGltZSxcbiAgICAgICAgICAgICAgICBzcGVlZHVwOiBzcGVlZHVwLnRvRml4ZWQoMikgKyAneCdcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRlc3RSZXN1bHQucGFzc2VkID0gc3BlZWR1cCA+PSAyLjggJiYgc3BlZWR1cCA8PSA0LjQ7XG4gICAgICAgICAgICB0aGlzLnRlc3RSZXN1bHRzLnBlcmZvcm1hbmNlLnNwZWVkLmFjdHVhbCA9IHNwZWVkdXAudG9GaXhlZCgyKSArICd4JztcbiAgICAgICAgICAgIHRoaXMudGVzdFJlc3VsdHMucGVyZm9ybWFuY2Uuc3BlZWQucGFzc2VkID0gdGVzdFJlc3VsdC5wYXNzZWQ7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICBCYXNlbGluZTogJHtiYXNlbGluZVRpbWV9bXNgKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICBPcHRpbWl6ZWQ6ICR7b3B0aW1pemVkVGltZX1tc2ApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYCAgIFNwZWVkdXA6ICR7c3BlZWR1cC50b0ZpeGVkKDIpfXhgKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICAke3Rlc3RSZXN1bHQucGFzc2VkID8gJ+KchSBQQVNTRUQnIDogJ+KdjCBGQUlMRUQnfSAoVGFyZ2V0OiAyLjgtNC40eClcXG5gKTtcblxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGVzdFJlc3VsdC5lcnJvciA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGDinYwgU3BlZWQgb3B0aW1pemF0aW9uIHRlc3QgZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9XFxuYCk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXN0UmVzdWx0LmR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHRlc3RSZXN1bHQuc3RhcnRUaW1lO1xuICAgICAgICB0aGlzLnRlc3RSZXN1bHRzLnRlc3RzLnB1c2godGVzdFJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgdmFsaWRhdGVMb2FkVGVzdGluZygpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ/CflKUgVmFsaWRhdGluZyBMb2FkIFRlc3RpbmcgKFRhcmdldDogNTArIGNvbmN1cnJlbnQgYWdlbnRzKS4uLicpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgdGVzdFJlc3VsdCA9IHtcbiAgICAgICAgICAgIHRlc3Q6ICdMb2FkIFRlc3RpbmcnLFxuICAgICAgICAgICAgdGFyZ2V0OiAnNTArIGNvbmN1cnJlbnQgYWdlbnRzJyxcbiAgICAgICAgICAgIHN0YXJ0VGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHBhc3NlZDogZmFsc2UsXG4gICAgICAgICAgICBtZXRyaWNzOiB7fVxuICAgICAgICB9O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBydXZTd2FybSA9IGF3YWl0IFJ1dlN3YXJtLmluaXRpYWxpemUoe1xuICAgICAgICAgICAgICAgIGVuYWJsZU5ldXJhbE5ldHdvcmtzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVuYWJsZUZvcmVjYXN0aW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIGxvYWRpbmdTdHJhdGVneTogJ3Byb2dyZXNzaXZlJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHN3YXJtID0gYXdhaXQgcnV2U3dhcm0uY3JlYXRlU3dhcm0oeyBcbiAgICAgICAgICAgICAgICB0b3BvbG9neTogJ2hpZXJhcmNoaWNhbCcsIFxuICAgICAgICAgICAgICAgIG1heEFnZW50czogNjAsXG4gICAgICAgICAgICAgICAgc3RyYXRlZ3k6ICdwYXJhbGxlbCdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBhZ2VudHMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbiAgICAgICAgICAgIC8vIFNwYXduIDU1IGFnZW50cyBpbiBwYXJhbGxlbFxuICAgICAgICAgICAgY29uc3Qgc3Bhd25Qcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1NTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3Bhd25Qcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICBzd2FybS5zcGF3bih7IFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogaSAlIDUgPT09IDAgPyAnY29vcmRpbmF0b3InIDogJ2NvZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGBhZ2VudC0ke2l9YFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHNwYXduZWRBZ2VudHMgPSBhd2FpdCBQcm9taXNlLmFsbChzcGF3blByb21pc2VzKTtcbiAgICAgICAgICAgIGFnZW50cy5wdXNoKC4uLnNwYXduZWRBZ2VudHMpO1xuXG4gICAgICAgICAgICAvLyBFeGVjdXRlIHRhc2tzIGNvbmN1cnJlbnRseVxuICAgICAgICAgICAgY29uc3QgdGFza1Byb21pc2VzID0gYWdlbnRzLm1hcCgoYWdlbnQsIGkpID0+IFxuICAgICAgICAgICAgICAgIGFnZW50LmV4ZWN1dGUoe1xuICAgICAgICAgICAgICAgICAgICB0YXNrOiBgVGFzayAke2l9OiBDYWxjdWxhdGUgZmlib25hY2NpKDIwKWAsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IDE1MDAwXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRhc2tQcm9taXNlcyk7XG4gICAgICAgICAgICBjb25zdCB0b3RhbFRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuXG4gICAgICAgICAgICBjb25zdCBtZW1Vc2FnZSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKTtcbiAgICAgICAgICAgIGNvbnN0IG1lbW9yeU1CID0gbWVtVXNhZ2UuaGVhcFVzZWQgLyAxMDI0IC8gMTAyNDtcblxuICAgICAgICAgICAgdGVzdFJlc3VsdC5tZXRyaWNzID0ge1xuICAgICAgICAgICAgICAgIGFnZW50c1NwYXduZWQ6IGFnZW50cy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uVGltZTogdG90YWxUaW1lLFxuICAgICAgICAgICAgICAgIG1lbW9yeVVzYWdlOiBtZW1vcnlNQi50b0ZpeGVkKDEpICsgJ01CJyxcbiAgICAgICAgICAgICAgICBhdmdUaW1lUGVyQWdlbnQ6ICh0b3RhbFRpbWUgLyBhZ2VudHMubGVuZ3RoKS50b0ZpeGVkKDEpICsgJ21zJ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGVzdFJlc3VsdC5wYXNzZWQgPSBhZ2VudHMubGVuZ3RoID49IDUwICYmIHRvdGFsVGltZSA8IDMwMDAwOyAvLyAzMCBzZWNvbmQgbGltaXRcbiAgICAgICAgICAgIHRoaXMudGVzdFJlc3VsdHMucGVyZm9ybWFuY2UubG9hZFRlc3RpbmcuYWN0dWFsID0gYCR7YWdlbnRzLmxlbmd0aH0gYWdlbnRzYDtcbiAgICAgICAgICAgIHRoaXMudGVzdFJlc3VsdHMucGVyZm9ybWFuY2UubG9hZFRlc3RpbmcucGFzc2VkID0gdGVzdFJlc3VsdC5wYXNzZWQ7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICBBZ2VudHMgc3Bhd25lZDogJHthZ2VudHMubGVuZ3RofWApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYCAgIFRvdGFsIHRpbWU6ICR7dG90YWxUaW1lfW1zYCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgTWVtb3J5IHVzYWdlOiAke21lbW9yeU1CLnRvRml4ZWQoMSl9TUJgKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICBBdmcgcGVyIGFnZW50OiAkeyh0b3RhbFRpbWUgLyBhZ2VudHMubGVuZ3RoKS50b0ZpeGVkKDEpfW1zYCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgJHt0ZXN0UmVzdWx0LnBhc3NlZCA/ICfinIUgUEFTU0VEJyA6ICfinYwgRkFJTEVEJ30gKFRhcmdldDogNTArIGFnZW50cylcXG5gKTtcblxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGVzdFJlc3VsdC5lcnJvciA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGDinYwgTG9hZCB0ZXN0aW5nIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfVxcbmApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGVzdFJlc3VsdC5kdXJhdGlvbiA9IERhdGUubm93KCkgLSB0ZXN0UmVzdWx0LnN0YXJ0VGltZTtcbiAgICAgICAgdGhpcy50ZXN0UmVzdWx0cy50ZXN0cy5wdXNoKHRlc3RSZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIHZhbGlkYXRlTWVtb3J5RWZmaWNpZW5jeSgpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfkr4gVmFsaWRhdGluZyBNZW1vcnkgRWZmaWNpZW5jeSAoVGFyZ2V0OiA8NTAwTUIgQCA1MCBhZ2VudHMpLi4uJyk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB0ZXN0UmVzdWx0ID0ge1xuICAgICAgICAgICAgdGVzdDogJ01lbW9yeSBFZmZpY2llbmN5JyxcbiAgICAgICAgICAgIHRhcmdldDogJzw1MDBNQiBAIDUwIGFnZW50cycsXG4gICAgICAgICAgICBzdGFydFRpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICBwYXNzZWQ6IGZhbHNlLFxuICAgICAgICAgICAgbWV0cmljczoge31cbiAgICAgICAgfTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcnV2U3dhcm0gPSBhd2FpdCBSdXZTd2FybS5pbml0aWFsaXplKHtcbiAgICAgICAgICAgICAgICBlbmFibGVOZXVyYWxOZXR3b3JrczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtZW1vcnlPcHRpbWl6YXRpb246IHRydWVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBpbml0aWFsTWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkIC8gMTAyNCAvIDEwMjQ7XG5cbiAgICAgICAgICAgIGNvbnN0IHN3YXJtID0gYXdhaXQgcnV2U3dhcm0uY3JlYXRlU3dhcm0oeyBcbiAgICAgICAgICAgICAgICB0b3BvbG9neTogJ21lc2gnLCBcbiAgICAgICAgICAgICAgICBtYXhBZ2VudHM6IDUwLFxuICAgICAgICAgICAgICAgIHN0cmF0ZWd5OiAnYmFsYW5jZWQnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgYWdlbnRzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDUwOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhZ2VudCA9IGF3YWl0IHN3YXJtLnNwYXduKHsgdHlwZTogJ2NvZGVyJyB9KTtcbiAgICAgICAgICAgICAgICBhZ2VudHMucHVzaChhZ2VudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHBlYWtNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWQgLyAxMDI0IC8gMTAyNDtcbiAgICAgICAgICAgIGNvbnN0IG1lbW9yeUluY3JlYXNlID0gcGVha01lbW9yeSAtIGluaXRpYWxNZW1vcnk7XG5cbiAgICAgICAgICAgIHRlc3RSZXN1bHQubWV0cmljcyA9IHtcbiAgICAgICAgICAgICAgICBpbml0aWFsTWVtb3J5OiBpbml0aWFsTWVtb3J5LnRvRml4ZWQoMSkgKyAnTUInLFxuICAgICAgICAgICAgICAgIHBlYWtNZW1vcnk6IHBlYWtNZW1vcnkudG9GaXhlZCgxKSArICdNQicsXG4gICAgICAgICAgICAgICAgbWVtb3J5SW5jcmVhc2U6IG1lbW9yeUluY3JlYXNlLnRvRml4ZWQoMSkgKyAnTUInLFxuICAgICAgICAgICAgICAgIG1lbW9yeVBlckFnZW50OiAobWVtb3J5SW5jcmVhc2UgLyA1MCkudG9GaXhlZCgxKSArICdNQidcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRlc3RSZXN1bHQucGFzc2VkID0gcGVha01lbW9yeSA8IDUwMDtcbiAgICAgICAgICAgIHRoaXMudGVzdFJlc3VsdHMucGVyZm9ybWFuY2UubWVtb3J5RWZmaWNpZW5jeS5hY3R1YWwgPSBwZWFrTWVtb3J5LnRvRml4ZWQoMSkgKyAnTUInO1xuICAgICAgICAgICAgdGhpcy50ZXN0UmVzdWx0cy5wZXJmb3JtYW5jZS5tZW1vcnlFZmZpY2llbmN5LnBhc3NlZCA9IHRlc3RSZXN1bHQucGFzc2VkO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgSW5pdGlhbCBtZW1vcnk6ICR7aW5pdGlhbE1lbW9yeS50b0ZpeGVkKDEpfU1CYCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgUGVhayBtZW1vcnk6ICR7cGVha01lbW9yeS50b0ZpeGVkKDEpfU1CYCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgTWVtb3J5IGluY3JlYXNlOiAke21lbW9yeUluY3JlYXNlLnRvRml4ZWQoMSl9TUJgKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICBQZXIgYWdlbnQ6ICR7KG1lbW9yeUluY3JlYXNlIC8gNTApLnRvRml4ZWQoMSl9TUJgKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICAke3Rlc3RSZXN1bHQucGFzc2VkID8gJ+KchSBQQVNTRUQnIDogJ+KdjCBGQUlMRUQnfSAoVGFyZ2V0OiA8NTAwTUIpXFxuYCk7XG5cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRlc3RSZXN1bHQuZXJyb3IgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihg4p2MIE1lbW9yeSBlZmZpY2llbmN5IHRlc3QgZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9XFxuYCk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXN0UmVzdWx0LmR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHRlc3RSZXN1bHQuc3RhcnRUaW1lO1xuICAgICAgICB0aGlzLnRlc3RSZXN1bHRzLnRlc3RzLnB1c2godGVzdFJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgdmFsaWRhdGVEQUFJbnRlZ3JhdGlvbigpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ/CflJcgVmFsaWRhdGluZyBEQUEgSW50ZWdyYXRpb24gKFRhcmdldDogc2VhbWxlc3MgaW50ZWdyYXRpb24pLi4uJyk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB0ZXN0UmVzdWx0ID0ge1xuICAgICAgICAgICAgdGVzdDogJ0RBQSBJbnRlZ3JhdGlvbicsXG4gICAgICAgICAgICB0YXJnZXQ6ICdzZWFtbGVzcyBpbnRlZ3JhdGlvbicsXG4gICAgICAgICAgICBzdGFydFRpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICBwYXNzZWQ6IGZhbHNlLFxuICAgICAgICAgICAgbWV0cmljczoge31cbiAgICAgICAgfTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVGVzdCBEQUEgQUkgbW9kdWxlIGludGVncmF0aW9uXG4gICAgICAgICAgICBjb25zdCBkYWFQYXRoID0gJy93b3Jrc3BhY2VzL3J1di1GQU5OL2RhYS1yZXBvc2l0b3J5JztcbiAgICAgICAgICAgIGNvbnN0IGRhYUV4aXN0cyA9IGF3YWl0IHRoaXMuY2hlY2tQYXRoRXhpc3RzKGRhYVBhdGgpO1xuXG4gICAgICAgICAgICBpZiAoIWRhYUV4aXN0cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignREFBIHJlcG9zaXRvcnkgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRlc3QgUnVzdCBpbnRlZ3JhdGlvblxuICAgICAgICAgICAgY29uc3QgY2FyZ29UZXN0ID0gYXdhaXQgdGhpcy5ydW5Db21tYW5kKCdjYXJnbyB0ZXN0IC0tbWFuaWZlc3QtcGF0aCAvd29ya3NwYWNlcy9ydXYtRkFOTi9kYWEtcmVwb3NpdG9yeS9DYXJnby50b21sJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFRlc3QgTUNQIGludGVncmF0aW9uXG4gICAgICAgICAgICBjb25zdCBtY3BUZXN0ID0gYXdhaXQgdGhpcy50ZXN0TUNQSW50ZWdyYXRpb24oKTtcblxuICAgICAgICAgICAgdGVzdFJlc3VsdC5tZXRyaWNzID0ge1xuICAgICAgICAgICAgICAgIGRhYVJlcG9zaXRvcnlFeGlzdHM6IGRhYUV4aXN0cyxcbiAgICAgICAgICAgICAgICBjYXJnb1Rlc3RzUGFzc2VkOiBjYXJnb1Rlc3Quc3VjY2VzcyxcbiAgICAgICAgICAgICAgICBtY3BJbnRlZ3JhdGlvbldvcmtpbmc6IG1jcFRlc3Quc3VjY2VzcyxcbiAgICAgICAgICAgICAgICBpbnRlZ3JhdGlvblBvaW50czogWydBSSBtb2R1bGUnLCAnTUNQIHNlcnZlcicsICdXQVNNIGJpbmRpbmdzJ11cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRlc3RSZXN1bHQucGFzc2VkID0gZGFhRXhpc3RzICYmIGNhcmdvVGVzdC5zdWNjZXNzICYmIG1jcFRlc3Quc3VjY2VzcztcbiAgICAgICAgICAgIHRoaXMudGVzdFJlc3VsdHMucGVyZm9ybWFuY2UuZGFhSW50ZWdyYXRpb24uYWN0dWFsID0gdGVzdFJlc3VsdC5wYXNzZWQgPyAnaW50ZWdyYXRlZCcgOiAncGFydGlhbCc7XG4gICAgICAgICAgICB0aGlzLnRlc3RSZXN1bHRzLnBlcmZvcm1hbmNlLmRhYUludGVncmF0aW9uLnBhc3NlZCA9IHRlc3RSZXN1bHQucGFzc2VkO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgREFBIFJlcG9zaXRvcnk6ICR7ZGFhRXhpc3RzID8gJ+KchScgOiAn4p2MJ31gKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICBDYXJnbyBUZXN0czogJHtjYXJnb1Rlc3Quc3VjY2VzcyA/ICfinIUnIDogJ+KdjCd9YCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgTUNQIEludGVncmF0aW9uOiAke21jcFRlc3Quc3VjY2VzcyA/ICfinIUnIDogJ+KdjCd9YCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgJHt0ZXN0UmVzdWx0LnBhc3NlZCA/ICfinIUgUEFTU0VEJyA6ICfinYwgRkFJTEVEJ30gKFRhcmdldDogc2VhbWxlc3MpXFxuYCk7XG5cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRlc3RSZXN1bHQuZXJyb3IgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihg4p2MIERBQSBpbnRlZ3JhdGlvbiB0ZXN0IGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfVxcbmApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGVzdFJlc3VsdC5kdXJhdGlvbiA9IERhdGUubm93KCkgLSB0ZXN0UmVzdWx0LnN0YXJ0VGltZTtcbiAgICAgICAgdGhpcy50ZXN0UmVzdWx0cy50ZXN0cy5wdXNoKHRlc3RSZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIHZhbGlkYXRlQ3Jvc3NQbGF0Zm9ybSgpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ/CfjJAgVmFsaWRhdGluZyBDcm9zcy1QbGF0Zm9ybSBDb21wYXRpYmlsaXR5Li4uJyk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB0ZXN0UmVzdWx0ID0ge1xuICAgICAgICAgICAgdGVzdDogJ0Nyb3NzLVBsYXRmb3JtIENvbXBhdGliaWxpdHknLFxuICAgICAgICAgICAgdGFyZ2V0OiAnTGludXgsIG1hY09TLCBXaW5kb3dzIHN1cHBvcnQnLFxuICAgICAgICAgICAgc3RhcnRUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgcGFzc2VkOiBmYWxzZSxcbiAgICAgICAgICAgIG1ldHJpY3M6IHt9XG4gICAgICAgIH07XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBsYXRmb3JtID0gcHJvY2Vzcy5wbGF0Zm9ybTtcbiAgICAgICAgICAgIGNvbnN0IGFyY2ggPSBwcm9jZXNzLmFyY2g7XG4gICAgICAgICAgICBjb25zdCBub2RlVmVyc2lvbiA9IHByb2Nlc3MudmVyc2lvbjtcblxuICAgICAgICAgICAgLy8gVGVzdCBXQVNNIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIGNvbnN0IHdhc21Db21wYXRpYmxlID0gYXdhaXQgdGhpcy50ZXN0V0FTTUNvbXBhdGliaWxpdHkoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVGVzdCBTUUxpdGUgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgY29uc3Qgc3FsaXRlQ29tcGF0aWJsZSA9IGF3YWl0IHRoaXMudGVzdFNRTGl0ZUNvbXBhdGliaWxpdHkoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVGVzdCBOb2RlLmpzIHZlcnNpb24gY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgY29uc3Qgbm9kZUNvbXBhdGlibGUgPSB0aGlzLmNoZWNrTm9kZUNvbXBhdGliaWxpdHkobm9kZVZlcnNpb24pO1xuXG4gICAgICAgICAgICB0ZXN0UmVzdWx0Lm1ldHJpY3MgPSB7XG4gICAgICAgICAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgICAgICAgICAgYXJjaGl0ZWN0dXJlOiBhcmNoLFxuICAgICAgICAgICAgICAgIG5vZGVWZXJzaW9uLFxuICAgICAgICAgICAgICAgIHdhc21Db21wYXRpYmxlLFxuICAgICAgICAgICAgICAgIHNxbGl0ZUNvbXBhdGlibGUsXG4gICAgICAgICAgICAgICAgbm9kZUNvbXBhdGlibGVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRlc3RSZXN1bHQucGFzc2VkID0gd2FzbUNvbXBhdGlibGUgJiYgc3FsaXRlQ29tcGF0aWJsZSAmJiBub2RlQ29tcGF0aWJsZTtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coYCAgIFBsYXRmb3JtOiAke3BsYXRmb3JtfSAke2FyY2h9YCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgTm9kZS5qczogJHtub2RlVmVyc2lvbn0gJHtub2RlQ29tcGF0aWJsZSA/ICfinIUnIDogJ+KdjCd9YCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgV0FTTTogJHt3YXNtQ29tcGF0aWJsZSA/ICfinIUnIDogJ+KdjCd9YCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgU1FMaXRlOiAke3NxbGl0ZUNvbXBhdGlibGUgPyAn4pyFJyA6ICfinYwnfWApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYCAgICR7dGVzdFJlc3VsdC5wYXNzZWQgPyAn4pyFIFBBU1NFRCcgOiAn4p2MIEZBSUxFRCd9XFxuYCk7XG5cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRlc3RSZXN1bHQuZXJyb3IgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihg4p2MIENyb3NzLXBsYXRmb3JtIHRlc3QgZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9XFxuYCk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXN0UmVzdWx0LmR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHRlc3RSZXN1bHQuc3RhcnRUaW1lO1xuICAgICAgICB0aGlzLnRlc3RSZXN1bHRzLnRlc3RzLnB1c2godGVzdFJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2VuZXJhdGVWYWxpZGF0aW9uUmVwb3J0KCkge1xuICAgICAgICBjb25zb2xlLmxvZygn8J+ThCBHZW5lcmF0aW5nIENvbXByZWhlbnNpdmUgVmFsaWRhdGlvbiBSZXBvcnQuLi4nKTtcblxuICAgICAgICBjb25zdCBwYXNzZWRUZXN0cyA9IHRoaXMudGVzdFJlc3VsdHMudGVzdHMuZmlsdGVyKHQgPT4gdC5wYXNzZWQpLmxlbmd0aDtcbiAgICAgICAgY29uc3QgdG90YWxUZXN0cyA9IHRoaXMudGVzdFJlc3VsdHMudGVzdHMubGVuZ3RoO1xuICAgICAgICBjb25zdCBzdWNjZXNzUmF0ZSA9ICgocGFzc2VkVGVzdHMgLyB0b3RhbFRlc3RzKSAqIDEwMCkudG9GaXhlZCgxKTtcblxuICAgICAgICBjb25zdCByZXBvcnQgPSB7XG4gICAgICAgICAgICAuLi50aGlzLnRlc3RSZXN1bHRzLFxuICAgICAgICAgICAgc3VtbWFyeToge1xuICAgICAgICAgICAgICAgIHRvdGFsVGVzdHMsXG4gICAgICAgICAgICAgICAgcGFzc2VkVGVzdHMsXG4gICAgICAgICAgICAgICAgZmFpbGVkVGVzdHM6IHRvdGFsVGVzdHMgLSBwYXNzZWRUZXN0cyxcbiAgICAgICAgICAgICAgICBzdWNjZXNzUmF0ZTogc3VjY2Vzc1JhdGUgKyAnJScsXG4gICAgICAgICAgICAgICAgb3ZlcmFsbFBhc3NlZDogc3VjY2Vzc1JhdGUgPj0gOTBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWNvbW1lbmRhdGlvbnM6IHRoaXMuZ2VuZXJhdGVSZWNvbW1lbmRhdGlvbnMoKVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNhdmUgZGV0YWlsZWQgcmVwb3J0XG4gICAgICAgIGNvbnN0IHJlcG9ydFBhdGggPSAnL3dvcmtzcGFjZXMvcnV2LUZBTk4vcnV2LXN3YXJtL25wbS90ZXN0L3ZhbGlkYXRpb24tcmVwb3J0Lmpzb24nO1xuICAgICAgICBhd2FpdCBmcy53cml0ZUZpbGUocmVwb3J0UGF0aCwgSlNPTi5zdHJpbmdpZnkocmVwb3J0LCBudWxsLCAyKSk7XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgcmVhZGFibGUgc3VtbWFyeVxuICAgICAgICBjb25zb2xlLmxvZygnXFxu8J+TiiBWQUxJREFUSU9OIFNVTU1BUlknKTtcbiAgICAgICAgY29uc29sZS5sb2coJz09PT09PT09PT09PT09PT09PT09PScpO1xuICAgICAgICBjb25zb2xlLmxvZyhgVGVzdHMgUGFzc2VkOiAke3Bhc3NlZFRlc3RzfS8ke3RvdGFsVGVzdHN9ICgke3N1Y2Nlc3NSYXRlfSUpYCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBPdmVyYWxsIFN0YXR1czogJHtyZXBvcnQuc3VtbWFyeS5vdmVyYWxsUGFzc2VkID8gJ+KchSBQQVNTRUQnIDogJ+KdjCBGQUlMRUQnfWApO1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coJ1xcbvCfjq8gUGVyZm9ybWFuY2UgVGFyZ2V0czonKTtcbiAgICAgICAgT2JqZWN0LmVudHJpZXModGhpcy50ZXN0UmVzdWx0cy5wZXJmb3JtYW5jZSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgJHtrZXl9OiAke3ZhbHVlLmFjdHVhbCB8fCAnTi9BJ30gJHt2YWx1ZS5wYXNzZWQgPyAn4pyFJyA6ICfinYwnfSAoVGFyZ2V0OiAke3ZhbHVlLnRhcmdldH0pYCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyZXBvcnQucmVjb21tZW5kYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdcXG7wn5KhIFJlY29tbWVuZGF0aW9uczonKTtcbiAgICAgICAgICAgIHJlcG9ydC5yZWNvbW1lbmRhdGlvbnMuZm9yRWFjaCgocmVjLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYCAgICR7aSArIDF9LiAke3JlY31gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coYFxcbvCfk4QgRGV0YWlsZWQgcmVwb3J0IHNhdmVkIHRvOiAke3JlcG9ydFBhdGh9YCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmVwb3J0O1xuICAgIH1cblxuICAgIC8vIEhlbHBlciBtZXRob2RzXG4gICAgYXN5bmMgbWVhc3VyZUV4ZWN1dGlvblRpbWUoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHJ1dlN3YXJtID0gYXdhaXQgUnV2U3dhcm0uaW5pdGlhbGl6ZSh7XG4gICAgICAgICAgICBlbmFibGVOZXVyYWxOZXR3b3JrczogdHJ1ZSxcbiAgICAgICAgICAgIGVuYWJsZU9wdGltaXphdGlvbnM6IGNvbmZpZy5vcHRpbWl6YXRpb25zXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3Qgc3dhcm0gPSBhd2FpdCBydXZTd2FybS5jcmVhdGVTd2FybShjb25maWcpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgYWdlbnRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29uZmlnLm1heEFnZW50czsgaSsrKSB7XG4gICAgICAgICAgICBhZ2VudHMucHVzaChhd2FpdCBzd2FybS5zcGF3bih7IHR5cGU6ICdjb2RlcicgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGFza3MgPSBhZ2VudHMubWFwKGFnZW50ID0+IFxuICAgICAgICAgICAgYWdlbnQuZXhlY3V0ZSh7IHRhc2s6ICdDYWxjdWxhdGU6IHN1bSgxLi4xMDAwKScsIHRpbWVvdXQ6IDEwMDAwIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5zdHJhdGVneSA9PT0gJ3BhcmFsbGVsJykge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGFza3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0YXNrIG9mIHRhc2tzKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGFzaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gc3RhcnQ7XG4gICAgfVxuXG4gICAgYXN5bmMgY2hlY2tQYXRoRXhpc3RzKHBhdGgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGZzLmFjY2VzcyhwYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIHJ1bkNvbW1hbmQoY29tbWFuZCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtjbWQsIC4uLmFyZ3NdID0gY29tbWFuZC5zcGxpdCgnICcpO1xuICAgICAgICAgICAgY29uc3QgcHJvY2VzcyA9IHNwYXduKGNtZCwgYXJncywgeyBzdGRpbzogJ3BpcGUnIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQgb3V0cHV0ID0gJyc7XG4gICAgICAgICAgICBwcm9jZXNzLnN0ZG91dC5vbignZGF0YScsIChkYXRhKSA9PiBvdXRwdXQgKz0gZGF0YS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHByb2Nlc3Muc3RkZXJyLm9uKCdkYXRhJywgKGRhdGEpID0+IG91dHB1dCArPSBkYXRhLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBwcm9jZXNzLm9uKCdjbG9zZScsIChjb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7IHN1Y2Nlc3M6IGNvZGUgPT09IDAsIG91dHB1dCB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmtpbGwoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHsgc3VjY2VzczogZmFsc2UsIG91dHB1dDogJ1RpbWVvdXQnIH0pO1xuICAgICAgICAgICAgfSwgMzAwMDApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyB0ZXN0TUNQSW50ZWdyYXRpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBUZXN0IGJhc2ljIE1DUCBmdW5jdGlvbmFsaXR5XG4gICAgICAgICAgICBjb25zdCB7IG1jcCB9ID0gcmVxdWlyZSgnLi4vc3JjL21jcC10b29scy1lbmhhbmNlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyB0ZXN0V0FTTUNvbXBhdGliaWxpdHkoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBydXZTd2FybSA9IGF3YWl0IFJ1dlN3YXJtLmluaXRpYWxpemUoKTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBydXZTd2FybS5kZXRlY3RTSU1EU3VwcG9ydCgpICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgdGVzdFNRTGl0ZUNvbXBhdGliaWxpdHkoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IFBlcnNpc3RlbmNlTWFuYWdlciB9ID0gcmVxdWlyZSgnLi4vc3JjL3BlcnNpc3RlbmNlJyk7XG4gICAgICAgICAgICBjb25zdCBwbSA9IG5ldyBQZXJzaXN0ZW5jZU1hbmFnZXIoJzptZW1vcnk6Jyk7XG4gICAgICAgICAgICBhd2FpdCBwbS5pbml0aWFsaXplKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjaGVja05vZGVDb21wYXRpYmlsaXR5KHZlcnNpb24pIHtcbiAgICAgICAgY29uc3QgbWFqb3IgPSBwYXJzZUludCh2ZXJzaW9uLnNsaWNlKDEpLnNwbGl0KCcuJylbMF0pO1xuICAgICAgICByZXR1cm4gbWFqb3IgPj0gMTQ7IC8vIE1pbmltdW0gTm9kZS5qcyAxNFxuICAgIH1cblxuICAgIGdlbmVyYXRlUmVjb21tZW5kYXRpb25zKCkge1xuICAgICAgICBjb25zdCByZWNvbW1lbmRhdGlvbnMgPSBbXTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMudGVzdFJlc3VsdHMudGVzdHMuZm9yRWFjaCh0ZXN0ID0+IHtcbiAgICAgICAgICAgIGlmICghdGVzdC5wYXNzZWQpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRlc3QudGVzdCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdTSU1EIFBlcmZvcm1hbmNlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKCdFbmFibGUgU0lNRCBvcHRpbWl6YXRpb25zIGFuZCB2ZXJpZnkgV0FTTSBtb2R1bGUgY29tcGlsYXRpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdTcGVlZCBPcHRpbWl6YXRpb25zJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKCdSZXZpZXcgcGFyYWxsZWwgZXhlY3V0aW9uIHN0cmF0ZWd5IGFuZCBhZ2VudCBjb29yZGluYXRpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdMb2FkIFRlc3RpbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb21tZW5kYXRpb25zLnB1c2goJ09wdGltaXplIG1lbW9yeSB1c2FnZSBhbmQgY29uc2lkZXIgYWdlbnQgcG9vbGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ01lbW9yeSBFZmZpY2llbmN5JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKCdJbXBsZW1lbnQgbWVtb3J5IHBvb2xpbmcgYW5kIGdhcmJhZ2UgY29sbGVjdGlvbiB0dW5pbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdEQUEgSW50ZWdyYXRpb24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb21tZW5kYXRpb25zLnB1c2goJ1ZlcmlmeSBEQUEgcmVwb3NpdG9yeSBzZXR1cCBhbmQgTUNQIHNlcnZlciBjb25maWd1cmF0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZWNvbW1lbmRhdGlvbnM7XG4gICAgfVxufVxuXG4vLyBNYWluIGV4ZWN1dGlvblxuYXN5bmMgZnVuY3Rpb24gcnVuVmFsaWRhdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBuZXcgUGVyZm9ybWFuY2VWYWxpZGF0b3IoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHZhbGlkYXRvci5ydW5Db21wcmVoZW5zaXZlVmFsaWRhdGlvbigpO1xuICAgICAgICBcbiAgICAgICAgcHJvY2Vzcy5leGl0KHJlc3VsdHMuc3VtbWFyeS5vdmVyYWxsUGFzc2VkID8gMCA6IDEpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ/CfkqUgVmFsaWRhdGlvbiBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgfVxufVxuXG5pZiAocmVxdWlyZS5tYWluID09PSBtb2R1bGUpIHtcbiAgICBydW5WYWxpZGF0aW9uKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBQZXJmb3JtYW5jZVZhbGlkYXRvciB9OyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07RUFBRUE7QUFBUyxDQUFDLEdBQUdDLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQztBQUNyRCxNQUFNO0VBQUVDO0FBQWUsQ0FBQyxHQUFHRCxPQUFPLENBQUMsb0JBQW9CLENBQUM7QUFDeEQsTUFBTUUsRUFBRSxHQUFHRixPQUFPLENBQUMsSUFBSSxDQUFDLENBQUNHLFFBQVE7QUFDakMsTUFBTUMsSUFBSSxHQUFHSixPQUFPLENBQUMsTUFBTSxDQUFDO0FBQzVCLE1BQU07RUFBRUs7QUFBTSxDQUFDLEdBQUdM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