28e80ca3a4e114a685c830de79d13210
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
/**
 * Error Handling and Recovery Edge Cases
 * Tests error propagation, recovery mechanisms, and failure scenarios
 */

import { describe, it, expect, jest, beforeEach, afterEach } from '@jest/globals';
import { RuvSwarm } from '../../src/index-enhanced.js';
import { EnhancedMCPTools } from '../../src/mcp-tools-enhanced.js';
import { SwarmPersistence } from '../../src/persistence.js';
describe('Error Handling and Recovery Edge Cases', () => {
  let mcpTools;
  let mockRuvSwarm;
  beforeEach(() => {
    mockRuvSwarm = {
      createSwarm: jest.fn(),
      benchmark: jest.fn()
    };
    mcpTools = new EnhancedMCPTools();
    jest.clearAllMocks();
  });
  afterEach(() => {
    jest.restoreAllMocks();
  });
  describe('Error Propagation Edge Cases', () => {
    it('should handle nested error chains', /*#__PURE__*/_asyncToGenerator(function* () {
      const createNestedError = () => {
        try {
          throw new Error('Level 1 error');
        } catch (level1) {
          try {
            throw new Error(`Level 2: ${level1.message}`);
          } catch (level2) {
            try {
              throw new Error(`Level 3: ${level2.message}`);
            } catch (level3) {
              throw new Error(`Level 4: ${level3.message}`);
            }
          }
        }
      };
      mockRuvSwarm.createSwarm.mockImplementation(() => {
        createNestedError();
      });
      yield mcpTools.initialize(mockRuvSwarm);
      yield expect(mcpTools.swarm_init({
        topology: 'mesh'
      })).rejects.toThrow(/Level 4.*Level 3.*Level 2.*Level 1/);
    }));
    it('should handle error aggregation from multiple sources', /*#__PURE__*/_asyncToGenerator(function* () {
      const errors = [];
      const failingOperations = [() => Promise.reject(new Error('Database error')), () => Promise.reject(new Error('Network error')), () => Promise.reject(new Error('Validation error')), () => Promise.reject(new Error('Permission error'))];
      const results = yield Promise.allSettled(failingOperations.map(op => op()));
      results.forEach(result => {
        if (result.status === 'rejected') {
          errors.push(result.reason.message);
        }
      });
      expect(errors).toHaveLength(4);
      expect(errors).toContain('Database error');
      expect(errors).toContain('Network error');
      expect(errors).toContain('Validation error');
      expect(errors).toContain('Permission error');
    }));
    it('should handle circular error references', /*#__PURE__*/_asyncToGenerator(function* () {
      const createCircularError = () => {
        const error1 = new Error('Error 1');
        const error2 = new Error('Error 2');

        // Create circular reference
        error1.cause = error2;
        error2.cause = error1;
        return error1;
      };
      const circularError = createCircularError();

      // Should handle circular references without infinite loops
      expect(() => {
        JSON.stringify(circularError, null, 2);
      }).toThrow(/circular|Converting/);

      // Custom error handler should handle this gracefully
      const safeErrorString = String(circularError);
      expect(safeErrorString).toContain('Error 1');
    }));
  });
  describe('Recovery Mechanism Edge Cases', () => {
    it('should implement exponential backoff with jitter', /*#__PURE__*/_asyncToGenerator(function* () {
      let attemptCount = 0;
      const maxAttempts = 5;
      const backoffTimes = [];
      const unreliableOperation = /*#__PURE__*/function () {
        var _ref5 = _asyncToGenerator(function* () {
          attemptCount++;
          const backoffTime = Math.pow(2, attemptCount - 1) * 100; // Exponential backoff
          const jitter = Math.random() * 100; // Add jitter
          const totalWait = backoffTime + jitter;
          backoffTimes.push(totalWait);
          if (attemptCount < maxAttempts) {
            throw new Error(`Attempt ${attemptCount} failed`);
          }
          return `Success after ${attemptCount} attempts`;
        });
        return function unreliableOperation() {
          return _ref5.apply(this, arguments);
        };
      }();
      const retryWithBackoff = /*#__PURE__*/function () {
        var _ref6 = _asyncToGenerator(function* (operation, maxRetries = 5) {
          for (let i = 0; i < maxRetries; i++) {
            try {
              return yield operation();
            } catch (error) {
              if (i === maxRetries - 1) throw error;
              const backoffTime = backoffTimes[i];
              yield new Promise(resolve => setTimeout(resolve, backoffTime));
            }
          }
        });
        return function retryWithBackoff(_x) {
          return _ref6.apply(this, arguments);
        };
      }();
      const result = yield retryWithBackoff(unreliableOperation);
      expect(result).toContain('Success');
      expect(attemptCount).toBe(maxAttempts);
      expect(backoffTimes).toHaveLength(maxAttempts);

      // Verify exponential growth with jitter
      expect(backoffTimes[1]).toBeGreaterThan(backoffTimes[0]);
      expect(backoffTimes[2]).toBeGreaterThan(backoffTimes[1]);
    }));
    it('should handle recovery from corrupted state', /*#__PURE__*/_asyncToGenerator(function* () {
      class StatefulService {
        constructor() {
          this.state = {
            healthy: true,
            data: []
          };
        }
        operation() {
          var _this = this;
          return _asyncToGenerator(function* () {
            if (!_this.state.healthy) {
              throw new Error('Service in corrupted state');
            }
            return 'Operation successful';
          })();
        }
        corruptState() {
          this.state.healthy = false;
          this.state.data = null;
        }
        recover() {
          var _this2 = this;
          return _asyncToGenerator(function* () {
            // Simulate recovery process
            _this2.state = {
              healthy: true,
              data: []
            };
            yield new Promise(resolve => setTimeout(resolve, 100));
          })();
        }
        safeOperation() {
          var _this3 = this;
          return _asyncToGenerator(function* () {
            try {
              return yield _this3.operation();
            } catch (error) {
              if (error.message.includes('corrupted')) {
                yield _this3.recover();
                return yield _this3.operation();
              }
              throw error;
            }
          })();
        }
      }
      const service = new StatefulService();

      // First operation should succeed
      const result1 = yield service.safeOperation();
      expect(result1).toBe('Operation successful');

      // Corrupt the state
      service.corruptState();

      // Operation should fail but recover
      const result2 = yield service.safeOperation();
      expect(result2).toBe('Operation successful');
      expect(service.state.healthy).toBe(true);
    }));
    it('should handle cascading failures with circuit breaker', /*#__PURE__*/_asyncToGenerator(function* () {
      class CircuitBreaker {
        constructor(threshold = 5, timeout = 60000) {
          this.failureThreshold = threshold;
          this.timeout = timeout;
          this.failureCount = 0;
          this.lastFailureTime = null;
          this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
        }
        execute(operation) {
          var _this4 = this;
          return _asyncToGenerator(function* () {
            if (_this4.state === 'OPEN') {
              if (Date.now() - _this4.lastFailureTime > _this4.timeout) {
                _this4.state = 'HALF_OPEN';
              } else {
                throw new Error('Circuit breaker is OPEN');
              }
            }
            try {
              const result = yield operation();
              _this4.onSuccess();
              return result;
            } catch (error) {
              _this4.onFailure();
              throw error;
            }
          })();
        }
        onSuccess() {
          this.failureCount = 0;
          this.state = 'CLOSED';
        }
        onFailure() {
          this.failureCount++;
          this.lastFailureTime = Date.now();
          if (this.failureCount >= this.failureThreshold) {
            this.state = 'OPEN';
          }
        }
      }
      const circuitBreaker = new CircuitBreaker(3, 1000);
      let operationCount = 0;
      const flakyOperation = /*#__PURE__*/function () {
        var _ref9 = _asyncToGenerator(function* () {
          operationCount++;
          if (operationCount <= 5) {
            throw new Error(`Operation failed (${operationCount})`);
          }
          return 'Success';
        });
        return function flakyOperation() {
          return _ref9.apply(this, arguments);
        };
      }();

      // First 3 failures should succeed in failing
      for (let i = 0; i < 3; i++) {
        yield expect(circuitBreaker.execute(flakyOperation)).rejects.toThrow(/Operation failed/);
      }
      expect(circuitBreaker.state).toBe('OPEN');

      // Next attempts should fail immediately due to circuit breaker
      yield expect(circuitBreaker.execute(flakyOperation)).rejects.toThrow(/Circuit breaker is OPEN/);

      // Wait for timeout and try again
      yield new Promise(resolve => setTimeout(resolve, 1100));

      // Should succeed now (operationCount > 5)
      const result = yield circuitBreaker.execute(flakyOperation);
      expect(result).toBe('Success');
      expect(circuitBreaker.state).toBe('CLOSED');
    }));
  });
  describe('Resource Cleanup on Failure', () => {
    it('should cleanup resources even when cleanup fails', /*#__PURE__*/_asyncToGenerator(function* () {
      const resources = [];
      let cleanupSuccesses = 0;
      let cleanupFailures = 0;
      class FailingResource {
        constructor(id, shouldFailCleanup = false) {
          this.id = id;
          this.shouldFailCleanup = shouldFailCleanup;
          this.acquired = true;
          resources.push(this);
        }
        cleanup() {
          var _this5 = this;
          return _asyncToGenerator(function* () {
            if (_this5.shouldFailCleanup) {
              cleanupFailures++;
              throw new Error(`Cleanup failed for resource ${_this5.id}`);
            }
            _this5.acquired = false;
            cleanupSuccesses++;
          })();
        }
      }
      const acquireResources = /*#__PURE__*/function () {
        var _ref1 = _asyncToGenerator(function* () {
          const acquired = [];
          try {
            // Acquire resources, some will fail cleanup
            for (let i = 0; i < 10; i++) {
              const shouldFail = i % 3 === 0; // Every 3rd resource fails cleanup
              acquired.push(new FailingResource(i, shouldFail));
            }

            // Simulate operation failure
            throw new Error('Operation failed');
          } catch (error) {
            // Cleanup all resources, even if some cleanups fail
            const cleanupPromises = acquired.map(resource => resource.cleanup().catch(err => ({
              error: err.message
            })));
            const cleanupResults = yield Promise.allSettled(cleanupPromises);

            // Count successful cleanups
            const successfulCleanups = cleanupResults.filter(result => {
              var _result$value;
              return result.status === 'fulfilled' && !((_result$value = result.value) !== null && _result$value !== void 0 && _result$value.error);
            }).length;
            throw new Error(`Operation failed. Cleaned up ${successfulCleanups}/${acquired.length} resources`);
          }
        });
        return function acquireResources() {
          return _ref1.apply(this, arguments);
        };
      }();
      yield expect(acquireResources()).rejects.toThrow(/Operation failed/);
      expect(cleanupSuccesses).toBe(7); // 7 resources should cleanup successfully
      expect(cleanupFailures).toBe(3); // 3 resources should fail cleanup
    }));
    it('should handle nested resource cleanup failures', /*#__PURE__*/_asyncToGenerator(function* () {
      const cleanupLog = [];
      class NestedResource {
        constructor(id, children = []) {
          this.id = id;
          this.children = children;
          this.acquired = true;
        }
        cleanup() {
          var _this6 = this;
          return _asyncToGenerator(function* () {
            cleanupLog.push(`Cleaning up ${_this6.id}`);

            // Cleanup children first
            const childCleanupPromises = _this6.children.map(child => child.cleanup().catch(error => {
              cleanupLog.push(`Child cleanup failed: ${error.message}`);
              return {
                error
              };
            }));
            yield Promise.all(childCleanupPromises);

            // Then cleanup self
            if (_this6.id.includes('fail')) {
              throw new Error(`Failed to cleanup ${_this6.id}`);
            }
            _this6.acquired = false;
            cleanupLog.push(`Cleaned up ${_this6.id}`);
          })();
        }
      }

      // Create nested resource structure
      const leaf1 = new NestedResource('leaf-1');
      const leaf2 = new NestedResource('leaf-2-fail');
      const leaf3 = new NestedResource('leaf-3');
      const branch1 = new NestedResource('branch-1', [leaf1, leaf2]);
      const branch2 = new NestedResource('branch-2-fail', [leaf3]);
      const root = new NestedResource('root', [branch1, branch2]);
      yield expect(root.cleanup()).rejects.toThrow(/Failed to cleanup/);

      // Check cleanup log
      expect(cleanupLog).toContain('Cleaning up root');
      expect(cleanupLog).toContain('Cleaning up branch-1');
      expect(cleanupLog).toContain('Cleaning up leaf-1');
      expect(cleanupLog).toContain('Child cleanup failed: Failed to cleanup leaf-2-fail');
    }));
  });
  describe('Error Context Preservation', () => {
    it('should preserve error context through async boundaries', /*#__PURE__*/_asyncToGenerator(function* () {
      const createContextualError = context => {
        const error = new Error('Base error');
        error.context = context;
        error.timestamp = Date.now();
        return error;
      };
      const asyncOperation1 = /*#__PURE__*/function () {
        var _ref12 = _asyncToGenerator(function* () {
          yield new Promise(resolve => setImmediate(resolve));
          throw createContextualError({
            operation: 'async-1',
            step: 'validation'
          });
        });
        return function asyncOperation1() {
          return _ref12.apply(this, arguments);
        };
      }();
      const asyncOperation2 = /*#__PURE__*/function () {
        var _ref13 = _asyncToGenerator(function* () {
          try {
            yield asyncOperation1();
          } catch (error) {
            const wrappedError = new Error(`Wrapped: ${error.message}`);
            wrappedError.originalError = error;
            wrappedError.context = {
              operation: 'async-2',
              step: 'processing'
            };
            throw wrappedError;
          }
        });
        return function asyncOperation2() {
          return _ref13.apply(this, arguments);
        };
      }();
      const asyncOperation3 = /*#__PURE__*/function () {
        var _ref14 = _asyncToGenerator(function* () {
          try {
            yield asyncOperation2();
          } catch (error) {
            const finalError = new Error(`Final: ${error.message}`);
            finalError.errorChain = [error];
            finalError.context = {
              operation: 'async-3',
              step: 'finalization'
            };
            throw finalError;
          }
        });
        return function asyncOperation3() {
          return _ref14.apply(this, arguments);
        };
      }();
      try {
        yield asyncOperation3();
      } catch (error) {
        expect(error.message).toContain('Final: Wrapped: Base error');
        expect(error.context.operation).toBe('async-3');
        expect(error.errorChain[0].originalError.context.operation).toBe('async-1');
      }
    }));
    it('should handle error context serialization', /*#__PURE__*/_asyncToGenerator(function* () {
      const createComplexError = () => {
        const error = new Error('Complex error');
        error.context = {
          user: {
            id: 123,
            name: 'test'
          },
          operation: 'data-processing',
          metadata: {
            timestamp: new Date(),
            circular: {} // Will create circular reference
          }
        };

        // Create circular reference
        error.context.metadata.circular.self = error.context.metadata;
        return error;
      };
      const complexError = createComplexError();

      // Test safe serialization
      const safeSerialize = obj => {
        const seen = new WeakSet();
        return JSON.stringify(obj, (key, value) => {
          if (typeof value === 'object' && value !== null) {
            if (seen.has(value)) {
              return '[Circular]';
            }
            seen.add(value);
          }
          return value;
        });
      };
      const serialized = safeSerialize({
        message: complexError.message,
        context: complexError.context
      });
      expect(serialized).toContain('Complex error');
      expect(serialized).toContain('[Circular]');
      expect(serialized).toContain('data-processing');
    }));
  });
  describe('Timeout and Cancellation Edge Cases', () => {
    it('should handle operation cancellation during execution', /*#__PURE__*/_asyncToGenerator(function* () {
      const {
        AbortController
      } = globalThis;
      if (!AbortController) {
        // Skip if AbortController not available
        return;
      }
      const controller = new AbortController();
      const {
        signal
      } = controller;
      const longRunningOperation = /*#__PURE__*/function () {
        var _ref17 = _asyncToGenerator(function* (signal) {
          for (let i = 0; i < 1000; i++) {
            if (signal.aborted) {
              throw new Error('Operation was cancelled');
            }
            yield new Promise(resolve => setTimeout(resolve, 10));
          }
          return 'Completed';
        });
        return function longRunningOperation(_x2) {
          return _ref17.apply(this, arguments);
        };
      }();

      // Cancel after 100ms
      setTimeout(() => controller.abort(), 100);
      yield expect(longRunningOperation(signal)).rejects.toThrow('Operation was cancelled');
    }));
    it('should handle timeout with resource cleanup', /*#__PURE__*/_asyncToGenerator(function* () {
      const resources = [];
      const operationWithResources = /*#__PURE__*/function () {
        var _ref19 = _asyncToGenerator(function* (timeoutMs) {
          const acquiredResources = [];
          const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error('Operation timeout')), timeoutMs);
          });
          try {
            const workPromise = _asyncToGenerator(function* () {
              // Acquire resources
              for (let i = 0; i < 5; i++) {
                const resource = {
                  id: i,
                  acquired: true
                };
                acquiredResources.push(resource);
                resources.push(resource);
                yield new Promise(resolve => setTimeout(resolve, 50));
              }

              // Do work (this will timeout)
              yield new Promise(resolve => setTimeout(resolve, 1000));
              return 'Work completed';
            })();
            return yield Promise.race([workPromise, timeoutPromise]);
          } catch (error) {
            // Cleanup resources on timeout
            acquiredResources.forEach(resource => {
              resource.acquired = false;
            });
            throw error;
          }
        });
        return function operationWithResources(_x3) {
          return _ref19.apply(this, arguments);
        };
      }();
      yield expect(operationWithResources(200)).rejects.toThrow('Operation timeout');

      // Check that resources were cleaned up
      const acquiredResources = resources.filter(r => r.acquired);
      expect(acquiredResources).toHaveLength(0);
    }));
  });
  describe('Error Recovery Strategies', () => {
    it('should implement retry with different strategies', /*#__PURE__*/_asyncToGenerator(function* () {
      const strategies = {
        immediate: attempt => 0,
        linear: attempt => attempt * 100,
        exponential: attempt => Math.pow(2, attempt) * 100,
        fibonacci: (() => {
          const fib = [100, 100];
          return attempt => {
            if (attempt < 2) return fib[attempt];
            const next = fib[0] + fib[1];
            fib[0] = fib[1];
            fib[1] = next;
            return next;
          };
        })()
      };
      for (const [strategyName, backoffFn] of Object.entries(strategies)) {
        let attempts = 0;
        const maxAttempts = 4;
        const retryWithStrategy = /*#__PURE__*/function () {
          var _ref22 = _asyncToGenerator(function* (operation, strategy) {
            for (let attempt = 0; attempt < maxAttempts; attempt++) {
              try {
                return yield operation();
              } catch (error) {
                if (attempt === maxAttempts - 1) throw error;
                const delay = strategy(attempt);
                yield new Promise(resolve => setTimeout(resolve, Math.min(delay, 1000)));
              }
            }
          });
          return function retryWithStrategy(_x4, _x5) {
            return _ref22.apply(this, arguments);
          };
        }();
        const flakyOperation = /*#__PURE__*/function () {
          var _ref23 = _asyncToGenerator(function* () {
            attempts++;
            if (attempts < 3) {
              throw new Error(`${strategyName} attempt ${attempts} failed`);
            }
            return `${strategyName} succeeded`;
          });
          return function flakyOperation() {
            return _ref23.apply(this, arguments);
          };
        }();
        const result = yield retryWithStrategy(flakyOperation, backoffFn);
        expect(result).toContain('succeeded');

        // Reset for next strategy
        attempts = 0;
      }
    }));
  });
});

// Run tests when executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  console.log('Running error handling and recovery edge case tests...');

  // Run all tests
  const {
    run
  } = await import('../test-runner.js');
  await run(__filename);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkZXNjcmliZSIsIml0IiwiZXhwZWN0IiwiamVzdCIsImJlZm9yZUVhY2giLCJhZnRlckVhY2giLCJSdXZTd2FybSIsIkVuaGFuY2VkTUNQVG9vbHMiLCJTd2FybVBlcnNpc3RlbmNlIiwibWNwVG9vbHMiLCJtb2NrUnV2U3dhcm0iLCJjcmVhdGVTd2FybSIsImZuIiwiYmVuY2htYXJrIiwiY2xlYXJBbGxNb2NrcyIsInJlc3RvcmVBbGxNb2NrcyIsIl9hc3luY1RvR2VuZXJhdG9yIiwiY3JlYXRlTmVzdGVkRXJyb3IiLCJFcnJvciIsImxldmVsMSIsIm1lc3NhZ2UiLCJsZXZlbDIiLCJsZXZlbDMiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJpbml0aWFsaXplIiwic3dhcm1faW5pdCIsInRvcG9sb2d5IiwicmVqZWN0cyIsInRvVGhyb3ciLCJlcnJvcnMiLCJmYWlsaW5nT3BlcmF0aW9ucyIsIlByb21pc2UiLCJyZWplY3QiLCJyZXN1bHRzIiwiYWxsU2V0dGxlZCIsIm1hcCIsIm9wIiwiZm9yRWFjaCIsInJlc3VsdCIsInN0YXR1cyIsInB1c2giLCJyZWFzb24iLCJ0b0hhdmVMZW5ndGgiLCJ0b0NvbnRhaW4iLCJjcmVhdGVDaXJjdWxhckVycm9yIiwiZXJyb3IxIiwiZXJyb3IyIiwiY2F1c2UiLCJjaXJjdWxhckVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsInNhZmVFcnJvclN0cmluZyIsIlN0cmluZyIsImF0dGVtcHRDb3VudCIsIm1heEF0dGVtcHRzIiwiYmFja29mZlRpbWVzIiwidW5yZWxpYWJsZU9wZXJhdGlvbiIsIl9yZWY1IiwiYmFja29mZlRpbWUiLCJNYXRoIiwicG93Iiwiaml0dGVyIiwicmFuZG9tIiwidG90YWxXYWl0IiwiYXBwbHkiLCJhcmd1bWVudHMiLCJyZXRyeVdpdGhCYWNrb2ZmIiwiX3JlZjYiLCJvcGVyYXRpb24iLCJtYXhSZXRyaWVzIiwiaSIsImVycm9yIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJfeCIsInRvQmUiLCJ0b0JlR3JlYXRlclRoYW4iLCJTdGF0ZWZ1bFNlcnZpY2UiLCJjb25zdHJ1Y3RvciIsInN0YXRlIiwiaGVhbHRoeSIsImRhdGEiLCJfdGhpcyIsImNvcnJ1cHRTdGF0ZSIsInJlY292ZXIiLCJfdGhpczIiLCJzYWZlT3BlcmF0aW9uIiwiX3RoaXMzIiwiaW5jbHVkZXMiLCJzZXJ2aWNlIiwicmVzdWx0MSIsInJlc3VsdDIiLCJDaXJjdWl0QnJlYWtlciIsInRocmVzaG9sZCIsInRpbWVvdXQiLCJmYWlsdXJlVGhyZXNob2xkIiwiZmFpbHVyZUNvdW50IiwibGFzdEZhaWx1cmVUaW1lIiwiZXhlY3V0ZSIsIl90aGlzNCIsIkRhdGUiLCJub3ciLCJvblN1Y2Nlc3MiLCJvbkZhaWx1cmUiLCJjaXJjdWl0QnJlYWtlciIsIm9wZXJhdGlvbkNvdW50IiwiZmxha3lPcGVyYXRpb24iLCJfcmVmOSIsInJlc291cmNlcyIsImNsZWFudXBTdWNjZXNzZXMiLCJjbGVhbnVwRmFpbHVyZXMiLCJGYWlsaW5nUmVzb3VyY2UiLCJpZCIsInNob3VsZEZhaWxDbGVhbnVwIiwiYWNxdWlyZWQiLCJjbGVhbnVwIiwiX3RoaXM1IiwiYWNxdWlyZVJlc291cmNlcyIsIl9yZWYxIiwic2hvdWxkRmFpbCIsImNsZWFudXBQcm9taXNlcyIsInJlc291cmNlIiwiY2F0Y2giLCJlcnIiLCJjbGVhbnVwUmVzdWx0cyIsInN1Y2Nlc3NmdWxDbGVhbnVwcyIsImZpbHRlciIsIl9yZXN1bHQkdmFsdWUiLCJ2YWx1ZSIsImxlbmd0aCIsImNsZWFudXBMb2ciLCJOZXN0ZWRSZXNvdXJjZSIsImNoaWxkcmVuIiwiX3RoaXM2IiwiY2hpbGRDbGVhbnVwUHJvbWlzZXMiLCJjaGlsZCIsImFsbCIsImxlYWYxIiwibGVhZjIiLCJsZWFmMyIsImJyYW5jaDEiLCJicmFuY2gyIiwicm9vdCIsImNyZWF0ZUNvbnRleHR1YWxFcnJvciIsImNvbnRleHQiLCJ0aW1lc3RhbXAiLCJhc3luY09wZXJhdGlvbjEiLCJfcmVmMTIiLCJzZXRJbW1lZGlhdGUiLCJzdGVwIiwiYXN5bmNPcGVyYXRpb24yIiwiX3JlZjEzIiwid3JhcHBlZEVycm9yIiwib3JpZ2luYWxFcnJvciIsImFzeW5jT3BlcmF0aW9uMyIsIl9yZWYxNCIsImZpbmFsRXJyb3IiLCJlcnJvckNoYWluIiwiY3JlYXRlQ29tcGxleEVycm9yIiwidXNlciIsIm5hbWUiLCJtZXRhZGF0YSIsImNpcmN1bGFyIiwic2VsZiIsImNvbXBsZXhFcnJvciIsInNhZmVTZXJpYWxpemUiLCJvYmoiLCJzZWVuIiwiV2Vha1NldCIsImtleSIsImhhcyIsImFkZCIsInNlcmlhbGl6ZWQiLCJBYm9ydENvbnRyb2xsZXIiLCJnbG9iYWxUaGlzIiwiY29udHJvbGxlciIsInNpZ25hbCIsImxvbmdSdW5uaW5nT3BlcmF0aW9uIiwiX3JlZjE3IiwiYWJvcnRlZCIsIl94MiIsImFib3J0Iiwib3BlcmF0aW9uV2l0aFJlc291cmNlcyIsIl9yZWYxOSIsInRpbWVvdXRNcyIsImFjcXVpcmVkUmVzb3VyY2VzIiwidGltZW91dFByb21pc2UiLCJfIiwid29ya1Byb21pc2UiLCJyYWNlIiwiX3gzIiwiciIsInN0cmF0ZWdpZXMiLCJpbW1lZGlhdGUiLCJhdHRlbXB0IiwibGluZWFyIiwiZXhwb25lbnRpYWwiLCJmaWJvbmFjY2kiLCJmaWIiLCJuZXh0Iiwic3RyYXRlZ3lOYW1lIiwiYmFja29mZkZuIiwiT2JqZWN0IiwiZW50cmllcyIsImF0dGVtcHRzIiwicmV0cnlXaXRoU3RyYXRlZ3kiLCJfcmVmMjIiLCJzdHJhdGVneSIsImRlbGF5IiwibWluIiwiX3g0IiwiX3g1IiwiX3JlZjIzIiwiaW1wb3J0IiwibWV0YSIsInVybCIsInByb2Nlc3MiLCJhcmd2IiwiY29uc29sZSIsImxvZyIsInJ1biIsIl9fZmlsZW5hbWUiXSwic291cmNlcyI6WyJlcnJvci1yZWNvdmVyeS1lZGdlLWNhc2VzLnRlc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFcnJvciBIYW5kbGluZyBhbmQgUmVjb3ZlcnkgRWRnZSBDYXNlc1xuICogVGVzdHMgZXJyb3IgcHJvcGFnYXRpb24sIHJlY292ZXJ5IG1lY2hhbmlzbXMsIGFuZCBmYWlsdXJlIHNjZW5hcmlvc1xuICovXG5cbmltcG9ydCB7IGRlc2NyaWJlLCBpdCwgZXhwZWN0LCBqZXN0LCBiZWZvcmVFYWNoLCBhZnRlckVhY2ggfSBmcm9tICdAamVzdC9nbG9iYWxzJztcbmltcG9ydCB7IFJ1dlN3YXJtIH0gZnJvbSAnLi4vLi4vc3JjL2luZGV4LWVuaGFuY2VkLmpzJztcbmltcG9ydCB7IEVuaGFuY2VkTUNQVG9vbHMgfSBmcm9tICcuLi8uLi9zcmMvbWNwLXRvb2xzLWVuaGFuY2VkLmpzJztcbmltcG9ydCB7IFN3YXJtUGVyc2lzdGVuY2UgfSBmcm9tICcuLi8uLi9zcmMvcGVyc2lzdGVuY2UuanMnO1xuXG5kZXNjcmliZSgnRXJyb3IgSGFuZGxpbmcgYW5kIFJlY292ZXJ5IEVkZ2UgQ2FzZXMnLCAoKSA9PiB7XG4gIGxldCBtY3BUb29scztcbiAgbGV0IG1vY2tSdXZTd2FybTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBtb2NrUnV2U3dhcm0gPSB7XG4gICAgICBjcmVhdGVTd2FybTogamVzdC5mbigpLFxuICAgICAgYmVuY2htYXJrOiBqZXN0LmZuKCksXG4gICAgfTtcbiAgICBtY3BUb29scyA9IG5ldyBFbmhhbmNlZE1DUFRvb2xzKCk7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgamVzdC5yZXN0b3JlQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Vycm9yIFByb3BhZ2F0aW9uIEVkZ2UgQ2FzZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbmVzdGVkIGVycm9yIGNoYWlucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNyZWF0ZU5lc3RlZEVycm9yID0gKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTGV2ZWwgMSBlcnJvcicpO1xuICAgICAgICB9IGNhdGNoIChsZXZlbDEpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMZXZlbCAyOiAke2xldmVsMS5tZXNzYWdlfWApO1xuICAgICAgICAgIH0gY2F0Y2ggKGxldmVsMikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMZXZlbCAzOiAke2xldmVsMi5tZXNzYWdlfWApO1xuICAgICAgICAgICAgfSBjYXRjaCAobGV2ZWwzKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGV2ZWwgNDogJHtsZXZlbDMubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIG1vY2tSdXZTd2FybS5jcmVhdGVTd2FybS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICBjcmVhdGVOZXN0ZWRFcnJvcigpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IG1jcFRvb2xzLmluaXRpYWxpemUobW9ja1J1dlN3YXJtKTtcbiAgICAgIFxuICAgICAgYXdhaXQgZXhwZWN0KG1jcFRvb2xzLnN3YXJtX2luaXQoeyB0b3BvbG9neTogJ21lc2gnIH0pKVxuICAgICAgICAucmVqZWN0cy50b1Rocm93KC9MZXZlbCA0LipMZXZlbCAzLipMZXZlbCAyLipMZXZlbCAxLyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBlcnJvciBhZ2dyZWdhdGlvbiBmcm9tIG11bHRpcGxlIHNvdXJjZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgIFxuICAgICAgY29uc3QgZmFpbGluZ09wZXJhdGlvbnMgPSBbXG4gICAgICAgICgpID0+IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignRGF0YWJhc2UgZXJyb3InKSksXG4gICAgICAgICgpID0+IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignTmV0d29yayBlcnJvcicpKSxcbiAgICAgICAgKCkgPT4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdWYWxpZGF0aW9uIGVycm9yJykpLFxuICAgICAgICAoKSA9PiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1Blcm1pc3Npb24gZXJyb3InKSksXG4gICAgICBdO1xuXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKFxuICAgICAgICBmYWlsaW5nT3BlcmF0aW9ucy5tYXAob3AgPT4gb3AoKSlcbiAgICAgICk7XG5cbiAgICAgIHJlc3VsdHMuZm9yRWFjaChyZXN1bHQgPT4ge1xuICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ3JlamVjdGVkJykge1xuICAgICAgICAgIGVycm9ycy5wdXNoKHJlc3VsdC5yZWFzb24ubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoZXJyb3JzKS50b0hhdmVMZW5ndGgoNCk7XG4gICAgICBleHBlY3QoZXJyb3JzKS50b0NvbnRhaW4oJ0RhdGFiYXNlIGVycm9yJyk7XG4gICAgICBleHBlY3QoZXJyb3JzKS50b0NvbnRhaW4oJ05ldHdvcmsgZXJyb3InKTtcbiAgICAgIGV4cGVjdChlcnJvcnMpLnRvQ29udGFpbignVmFsaWRhdGlvbiBlcnJvcicpO1xuICAgICAgZXhwZWN0KGVycm9ycykudG9Db250YWluKCdQZXJtaXNzaW9uIGVycm9yJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjaXJjdWxhciBlcnJvciByZWZlcmVuY2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY3JlYXRlQ2lyY3VsYXJFcnJvciA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3IxID0gbmV3IEVycm9yKCdFcnJvciAxJyk7XG4gICAgICAgIGNvbnN0IGVycm9yMiA9IG5ldyBFcnJvcignRXJyb3IgMicpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGNpcmN1bGFyIHJlZmVyZW5jZVxuICAgICAgICBlcnJvcjEuY2F1c2UgPSBlcnJvcjI7XG4gICAgICAgIGVycm9yMi5jYXVzZSA9IGVycm9yMTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBlcnJvcjE7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBjaXJjdWxhckVycm9yID0gY3JlYXRlQ2lyY3VsYXJFcnJvcigpO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgaGFuZGxlIGNpcmN1bGFyIHJlZmVyZW5jZXMgd2l0aG91dCBpbmZpbml0ZSBsb29wc1xuICAgICAgZXhwZWN0KCgpID0+IHtcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoY2lyY3VsYXJFcnJvciwgbnVsbCwgMik7XG4gICAgICB9KS50b1Rocm93KC9jaXJjdWxhcnxDb252ZXJ0aW5nLyk7XG5cbiAgICAgIC8vIEN1c3RvbSBlcnJvciBoYW5kbGVyIHNob3VsZCBoYW5kbGUgdGhpcyBncmFjZWZ1bGx5XG4gICAgICBjb25zdCBzYWZlRXJyb3JTdHJpbmcgPSBTdHJpbmcoY2lyY3VsYXJFcnJvcik7XG4gICAgICBleHBlY3Qoc2FmZUVycm9yU3RyaW5nKS50b0NvbnRhaW4oJ0Vycm9yIDEnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1JlY292ZXJ5IE1lY2hhbmlzbSBFZGdlIENhc2VzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaW1wbGVtZW50IGV4cG9uZW50aWFsIGJhY2tvZmYgd2l0aCBqaXR0ZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgYXR0ZW1wdENvdW50ID0gMDtcbiAgICAgIGNvbnN0IG1heEF0dGVtcHRzID0gNTtcbiAgICAgIGNvbnN0IGJhY2tvZmZUaW1lcyA9IFtdO1xuXG4gICAgICBjb25zdCB1bnJlbGlhYmxlT3BlcmF0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBhdHRlbXB0Q291bnQrKztcbiAgICAgICAgY29uc3QgYmFja29mZlRpbWUgPSBNYXRoLnBvdygyLCBhdHRlbXB0Q291bnQgLSAxKSAqIDEwMDsgLy8gRXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgICBjb25zdCBqaXR0ZXIgPSBNYXRoLnJhbmRvbSgpICogMTAwOyAvLyBBZGQgaml0dGVyXG4gICAgICAgIGNvbnN0IHRvdGFsV2FpdCA9IGJhY2tvZmZUaW1lICsgaml0dGVyO1xuICAgICAgICBcbiAgICAgICAgYmFja29mZlRpbWVzLnB1c2godG90YWxXYWl0KTtcblxuICAgICAgICBpZiAoYXR0ZW1wdENvdW50IDwgbWF4QXR0ZW1wdHMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0dGVtcHQgJHthdHRlbXB0Q291bnR9IGZhaWxlZGApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYFN1Y2Nlc3MgYWZ0ZXIgJHthdHRlbXB0Q291bnR9IGF0dGVtcHRzYDtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJldHJ5V2l0aEJhY2tvZmYgPSBhc3luYyAob3BlcmF0aW9uLCBtYXhSZXRyaWVzID0gNSkgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heFJldHJpZXM7IGkrKykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgb3BlcmF0aW9uKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpID09PSBtYXhSZXRyaWVzIC0gMSkgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGJhY2tvZmZUaW1lID0gYmFja29mZlRpbWVzW2ldO1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGJhY2tvZmZUaW1lKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXRyeVdpdGhCYWNrb2ZmKHVucmVsaWFibGVPcGVyYXRpb24pO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0KS50b0NvbnRhaW4oJ1N1Y2Nlc3MnKTtcbiAgICAgIGV4cGVjdChhdHRlbXB0Q291bnQpLnRvQmUobWF4QXR0ZW1wdHMpO1xuICAgICAgZXhwZWN0KGJhY2tvZmZUaW1lcykudG9IYXZlTGVuZ3RoKG1heEF0dGVtcHRzKTtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IGV4cG9uZW50aWFsIGdyb3d0aCB3aXRoIGppdHRlclxuICAgICAgZXhwZWN0KGJhY2tvZmZUaW1lc1sxXSkudG9CZUdyZWF0ZXJUaGFuKGJhY2tvZmZUaW1lc1swXSk7XG4gICAgICBleHBlY3QoYmFja29mZlRpbWVzWzJdKS50b0JlR3JlYXRlclRoYW4oYmFja29mZlRpbWVzWzFdKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHJlY292ZXJ5IGZyb20gY29ycnVwdGVkIHN0YXRlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY2xhc3MgU3RhdGVmdWxTZXJ2aWNlIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IHsgaGVhbHRoeTogdHJ1ZSwgZGF0YTogW10gfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jIG9wZXJhdGlvbigpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuc3RhdGUuaGVhbHRoeSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2aWNlIGluIGNvcnJ1cHRlZCBzdGF0ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gJ09wZXJhdGlvbiBzdWNjZXNzZnVsJztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvcnJ1cHRTdGF0ZSgpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlLmhlYWx0aHkgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnN0YXRlLmRhdGEgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgYXN5bmMgcmVjb3ZlcigpIHtcbiAgICAgICAgICAvLyBTaW11bGF0ZSByZWNvdmVyeSBwcm9jZXNzXG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IHsgaGVhbHRoeTogdHJ1ZSwgZGF0YTogW10gfTtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSk7XG4gICAgICAgIH1cblxuICAgICAgICBhc3luYyBzYWZlT3BlcmF0aW9uKCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5vcGVyYXRpb24oKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2NvcnJ1cHRlZCcpKSB7XG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVjb3ZlcigpO1xuICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5vcGVyYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBzZXJ2aWNlID0gbmV3IFN0YXRlZnVsU2VydmljZSgpO1xuICAgICAgXG4gICAgICAvLyBGaXJzdCBvcGVyYXRpb24gc2hvdWxkIHN1Y2NlZWRcbiAgICAgIGNvbnN0IHJlc3VsdDEgPSBhd2FpdCBzZXJ2aWNlLnNhZmVPcGVyYXRpb24oKTtcbiAgICAgIGV4cGVjdChyZXN1bHQxKS50b0JlKCdPcGVyYXRpb24gc3VjY2Vzc2Z1bCcpO1xuICAgICAgXG4gICAgICAvLyBDb3JydXB0IHRoZSBzdGF0ZVxuICAgICAgc2VydmljZS5jb3JydXB0U3RhdGUoKTtcbiAgICAgIFxuICAgICAgLy8gT3BlcmF0aW9uIHNob3VsZCBmYWlsIGJ1dCByZWNvdmVyXG4gICAgICBjb25zdCByZXN1bHQyID0gYXdhaXQgc2VydmljZS5zYWZlT3BlcmF0aW9uKCk7XG4gICAgICBleHBlY3QocmVzdWx0MikudG9CZSgnT3BlcmF0aW9uIHN1Y2Nlc3NmdWwnKTtcbiAgICAgIGV4cGVjdChzZXJ2aWNlLnN0YXRlLmhlYWx0aHkpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjYXNjYWRpbmcgZmFpbHVyZXMgd2l0aCBjaXJjdWl0IGJyZWFrZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICBjbGFzcyBDaXJjdWl0QnJlYWtlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHRocmVzaG9sZCA9IDUsIHRpbWVvdXQgPSA2MDAwMCkge1xuICAgICAgICAgIHRoaXMuZmFpbHVyZVRocmVzaG9sZCA9IHRocmVzaG9sZDtcbiAgICAgICAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICAgIHRoaXMuZmFpbHVyZUNvdW50ID0gMDtcbiAgICAgICAgICB0aGlzLmxhc3RGYWlsdXJlVGltZSA9IG51bGw7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9ICdDTE9TRUQnOyAvLyBDTE9TRUQsIE9QRU4sIEhBTEZfT1BFTlxuICAgICAgICB9XG5cbiAgICAgICAgYXN5bmMgZXhlY3V0ZShvcGVyYXRpb24pIHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ09QRU4nKSB7XG4gICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIHRoaXMubGFzdEZhaWx1cmVUaW1lID4gdGhpcy50aW1lb3V0KSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnSEFMRl9PUEVOJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2lyY3VpdCBicmVha2VyIGlzIE9QRU4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb3BlcmF0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLm9uU3VjY2VzcygpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5vbkZhaWx1cmUoKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9uU3VjY2VzcygpIHtcbiAgICAgICAgICB0aGlzLmZhaWx1cmVDb3VudCA9IDA7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9ICdDTE9TRUQnO1xuICAgICAgICB9XG5cbiAgICAgICAgb25GYWlsdXJlKCkge1xuICAgICAgICAgIHRoaXMuZmFpbHVyZUNvdW50Kys7XG4gICAgICAgICAgdGhpcy5sYXN0RmFpbHVyZVRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICh0aGlzLmZhaWx1cmVDb3VudCA+PSB0aGlzLmZhaWx1cmVUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnT1BFTic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNpcmN1aXRCcmVha2VyID0gbmV3IENpcmN1aXRCcmVha2VyKDMsIDEwMDApO1xuICAgICAgbGV0IG9wZXJhdGlvbkNvdW50ID0gMDtcblxuICAgICAgY29uc3QgZmxha3lPcGVyYXRpb24gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIG9wZXJhdGlvbkNvdW50Kys7XG4gICAgICAgIGlmIChvcGVyYXRpb25Db3VudCA8PSA1KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPcGVyYXRpb24gZmFpbGVkICgke29wZXJhdGlvbkNvdW50fSlgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ1N1Y2Nlc3MnO1xuICAgICAgfTtcblxuICAgICAgLy8gRmlyc3QgMyBmYWlsdXJlcyBzaG91bGQgc3VjY2VlZCBpbiBmYWlsaW5nXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICBhd2FpdCBleHBlY3QoY2lyY3VpdEJyZWFrZXIuZXhlY3V0ZShmbGFreU9wZXJhdGlvbikpXG4gICAgICAgICAgLnJlamVjdHMudG9UaHJvdygvT3BlcmF0aW9uIGZhaWxlZC8pO1xuICAgICAgfVxuXG4gICAgICBleHBlY3QoY2lyY3VpdEJyZWFrZXIuc3RhdGUpLnRvQmUoJ09QRU4nKTtcblxuICAgICAgLy8gTmV4dCBhdHRlbXB0cyBzaG91bGQgZmFpbCBpbW1lZGlhdGVseSBkdWUgdG8gY2lyY3VpdCBicmVha2VyXG4gICAgICBhd2FpdCBleHBlY3QoY2lyY3VpdEJyZWFrZXIuZXhlY3V0ZShmbGFreU9wZXJhdGlvbikpXG4gICAgICAgIC5yZWplY3RzLnRvVGhyb3coL0NpcmN1aXQgYnJlYWtlciBpcyBPUEVOLyk7XG5cbiAgICAgIC8vIFdhaXQgZm9yIHRpbWVvdXQgYW5kIHRyeSBhZ2FpblxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDExMDApKTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIHN1Y2NlZWQgbm93IChvcGVyYXRpb25Db3VudCA+IDUpXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjaXJjdWl0QnJlYWtlci5leGVjdXRlKGZsYWt5T3BlcmF0aW9uKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoJ1N1Y2Nlc3MnKTtcbiAgICAgIGV4cGVjdChjaXJjdWl0QnJlYWtlci5zdGF0ZSkudG9CZSgnQ0xPU0VEJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdSZXNvdXJjZSBDbGVhbnVwIG9uIEZhaWx1cmUnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjbGVhbnVwIHJlc291cmNlcyBldmVuIHdoZW4gY2xlYW51cCBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc291cmNlcyA9IFtdO1xuICAgICAgbGV0IGNsZWFudXBTdWNjZXNzZXMgPSAwO1xuICAgICAgbGV0IGNsZWFudXBGYWlsdXJlcyA9IDA7XG5cbiAgICAgIGNsYXNzIEZhaWxpbmdSZXNvdXJjZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGlkLCBzaG91bGRGYWlsQ2xlYW51cCA9IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICAgIHRoaXMuc2hvdWxkRmFpbENsZWFudXAgPSBzaG91bGRGYWlsQ2xlYW51cDtcbiAgICAgICAgICB0aGlzLmFjcXVpcmVkID0gdHJ1ZTtcbiAgICAgICAgICByZXNvdXJjZXMucHVzaCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jIGNsZWFudXAoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2hvdWxkRmFpbENsZWFudXApIHtcbiAgICAgICAgICAgIGNsZWFudXBGYWlsdXJlcysrO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDbGVhbnVwIGZhaWxlZCBmb3IgcmVzb3VyY2UgJHt0aGlzLmlkfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFjcXVpcmVkID0gZmFsc2U7XG4gICAgICAgICAgY2xlYW51cFN1Y2Nlc3NlcysrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFjcXVpcmVSZXNvdXJjZXMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGFjcXVpcmVkID0gW107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gQWNxdWlyZSByZXNvdXJjZXMsIHNvbWUgd2lsbCBmYWlsIGNsZWFudXBcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZEZhaWwgPSBpICUgMyA9PT0gMDsgLy8gRXZlcnkgM3JkIHJlc291cmNlIGZhaWxzIGNsZWFudXBcbiAgICAgICAgICAgIGFjcXVpcmVkLnB1c2gobmV3IEZhaWxpbmdSZXNvdXJjZShpLCBzaG91bGRGYWlsKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNpbXVsYXRlIG9wZXJhdGlvbiBmYWlsdXJlXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcGVyYXRpb24gZmFpbGVkJyk7XG4gICAgICAgICAgXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgLy8gQ2xlYW51cCBhbGwgcmVzb3VyY2VzLCBldmVuIGlmIHNvbWUgY2xlYW51cHMgZmFpbFxuICAgICAgICAgIGNvbnN0IGNsZWFudXBQcm9taXNlcyA9IGFjcXVpcmVkLm1hcChyZXNvdXJjZSA9PiBcbiAgICAgICAgICAgIHJlc291cmNlLmNsZWFudXAoKS5jYXRjaChlcnIgPT4gKHsgZXJyb3I6IGVyci5tZXNzYWdlIH0pKVxuICAgICAgICAgICk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgY2xlYW51cFJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoY2xlYW51cFByb21pc2VzKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDb3VudCBzdWNjZXNzZnVsIGNsZWFudXBzXG4gICAgICAgICAgY29uc3Qgc3VjY2Vzc2Z1bENsZWFudXBzID0gY2xlYW51cFJlc3VsdHMuZmlsdGVyKFxuICAgICAgICAgICAgcmVzdWx0ID0+IHJlc3VsdC5zdGF0dXMgPT09ICdmdWxmaWxsZWQnICYmICFyZXN1bHQudmFsdWU/LmVycm9yXG4gICAgICAgICAgKS5sZW5ndGg7XG4gICAgICAgICAgXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPcGVyYXRpb24gZmFpbGVkLiBDbGVhbmVkIHVwICR7c3VjY2Vzc2Z1bENsZWFudXBzfS8ke2FjcXVpcmVkLmxlbmd0aH0gcmVzb3VyY2VzYCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGF3YWl0IGV4cGVjdChhY3F1aXJlUmVzb3VyY2VzKCkpLnJlamVjdHMudG9UaHJvdygvT3BlcmF0aW9uIGZhaWxlZC8pO1xuICAgICAgXG4gICAgICBleHBlY3QoY2xlYW51cFN1Y2Nlc3NlcykudG9CZSg3KTsgLy8gNyByZXNvdXJjZXMgc2hvdWxkIGNsZWFudXAgc3VjY2Vzc2Z1bGx5XG4gICAgICBleHBlY3QoY2xlYW51cEZhaWx1cmVzKS50b0JlKDMpOyAvLyAzIHJlc291cmNlcyBzaG91bGQgZmFpbCBjbGVhbnVwXG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBuZXN0ZWQgcmVzb3VyY2UgY2xlYW51cCBmYWlsdXJlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNsZWFudXBMb2cgPSBbXTtcblxuICAgICAgY2xhc3MgTmVzdGVkUmVzb3VyY2Uge1xuICAgICAgICBjb25zdHJ1Y3RvcihpZCwgY2hpbGRyZW4gPSBbXSkge1xuICAgICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgICAgdGhpcy5hY3F1aXJlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBhc3luYyBjbGVhbnVwKCkge1xuICAgICAgICAgIGNsZWFudXBMb2cucHVzaChgQ2xlYW5pbmcgdXAgJHt0aGlzLmlkfWApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENsZWFudXAgY2hpbGRyZW4gZmlyc3RcbiAgICAgICAgICBjb25zdCBjaGlsZENsZWFudXBQcm9taXNlcyA9IHRoaXMuY2hpbGRyZW4ubWFwKGNoaWxkID0+IFxuICAgICAgICAgICAgY2hpbGQuY2xlYW51cCgpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgY2xlYW51cExvZy5wdXNoKGBDaGlsZCBjbGVhbnVwIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICByZXR1cm4geyBlcnJvciB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIFxuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGNoaWxkQ2xlYW51cFByb21pc2VzKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUaGVuIGNsZWFudXAgc2VsZlxuICAgICAgICAgIGlmICh0aGlzLmlkLmluY2x1ZGVzKCdmYWlsJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNsZWFudXAgJHt0aGlzLmlkfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICB0aGlzLmFjcXVpcmVkID0gZmFsc2U7XG4gICAgICAgICAgY2xlYW51cExvZy5wdXNoKGBDbGVhbmVkIHVwICR7dGhpcy5pZH1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgbmVzdGVkIHJlc291cmNlIHN0cnVjdHVyZVxuICAgICAgY29uc3QgbGVhZjEgPSBuZXcgTmVzdGVkUmVzb3VyY2UoJ2xlYWYtMScpO1xuICAgICAgY29uc3QgbGVhZjIgPSBuZXcgTmVzdGVkUmVzb3VyY2UoJ2xlYWYtMi1mYWlsJyk7XG4gICAgICBjb25zdCBsZWFmMyA9IG5ldyBOZXN0ZWRSZXNvdXJjZSgnbGVhZi0zJyk7XG4gICAgICBcbiAgICAgIGNvbnN0IGJyYW5jaDEgPSBuZXcgTmVzdGVkUmVzb3VyY2UoJ2JyYW5jaC0xJywgW2xlYWYxLCBsZWFmMl0pO1xuICAgICAgY29uc3QgYnJhbmNoMiA9IG5ldyBOZXN0ZWRSZXNvdXJjZSgnYnJhbmNoLTItZmFpbCcsIFtsZWFmM10pO1xuICAgICAgXG4gICAgICBjb25zdCByb290ID0gbmV3IE5lc3RlZFJlc291cmNlKCdyb290JywgW2JyYW5jaDEsIGJyYW5jaDJdKTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHJvb3QuY2xlYW51cCgpKS5yZWplY3RzLnRvVGhyb3coL0ZhaWxlZCB0byBjbGVhbnVwLyk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGNsZWFudXAgbG9nXG4gICAgICBleHBlY3QoY2xlYW51cExvZykudG9Db250YWluKCdDbGVhbmluZyB1cCByb290Jyk7XG4gICAgICBleHBlY3QoY2xlYW51cExvZykudG9Db250YWluKCdDbGVhbmluZyB1cCBicmFuY2gtMScpO1xuICAgICAgZXhwZWN0KGNsZWFudXBMb2cpLnRvQ29udGFpbignQ2xlYW5pbmcgdXAgbGVhZi0xJyk7XG4gICAgICBleHBlY3QoY2xlYW51cExvZykudG9Db250YWluKCdDaGlsZCBjbGVhbnVwIGZhaWxlZDogRmFpbGVkIHRvIGNsZWFudXAgbGVhZi0yLWZhaWwnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Vycm9yIENvbnRleHQgUHJlc2VydmF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcHJlc2VydmUgZXJyb3IgY29udGV4dCB0aHJvdWdoIGFzeW5jIGJvdW5kYXJpZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjcmVhdGVDb250ZXh0dWFsRXJyb3IgPSAoY29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignQmFzZSBlcnJvcicpO1xuICAgICAgICBlcnJvci5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgZXJyb3IudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgYXN5bmNPcGVyYXRpb24xID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldEltbWVkaWF0ZShyZXNvbHZlKSk7XG4gICAgICAgIHRocm93IGNyZWF0ZUNvbnRleHR1YWxFcnJvcih7IG9wZXJhdGlvbjogJ2FzeW5jLTEnLCBzdGVwOiAndmFsaWRhdGlvbicgfSk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBhc3luY09wZXJhdGlvbjIgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgYXN5bmNPcGVyYXRpb24xKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc3Qgd3JhcHBlZEVycm9yID0gbmV3IEVycm9yKGBXcmFwcGVkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgd3JhcHBlZEVycm9yLm9yaWdpbmFsRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICB3cmFwcGVkRXJyb3IuY29udGV4dCA9IHsgb3BlcmF0aW9uOiAnYXN5bmMtMicsIHN0ZXA6ICdwcm9jZXNzaW5nJyB9O1xuICAgICAgICAgIHRocm93IHdyYXBwZWRFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgYXN5bmNPcGVyYXRpb24zID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IGFzeW5jT3BlcmF0aW9uMigpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnN0IGZpbmFsRXJyb3IgPSBuZXcgRXJyb3IoYEZpbmFsOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgZmluYWxFcnJvci5lcnJvckNoYWluID0gW2Vycm9yXTtcbiAgICAgICAgICBmaW5hbEVycm9yLmNvbnRleHQgPSB7IG9wZXJhdGlvbjogJ2FzeW5jLTMnLCBzdGVwOiAnZmluYWxpemF0aW9uJyB9O1xuICAgICAgICAgIHRocm93IGZpbmFsRXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGFzeW5jT3BlcmF0aW9uMygpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZXhwZWN0KGVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignRmluYWw6IFdyYXBwZWQ6IEJhc2UgZXJyb3InKTtcbiAgICAgICAgZXhwZWN0KGVycm9yLmNvbnRleHQub3BlcmF0aW9uKS50b0JlKCdhc3luYy0zJyk7XG4gICAgICAgIGV4cGVjdChlcnJvci5lcnJvckNoYWluWzBdLm9yaWdpbmFsRXJyb3IuY29udGV4dC5vcGVyYXRpb24pLnRvQmUoJ2FzeW5jLTEnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGVycm9yIGNvbnRleHQgc2VyaWFsaXphdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNyZWF0ZUNvbXBsZXhFcnJvciA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvbXBsZXggZXJyb3InKTtcbiAgICAgICAgZXJyb3IuY29udGV4dCA9IHtcbiAgICAgICAgICB1c2VyOiB7IGlkOiAxMjMsIG5hbWU6ICd0ZXN0JyB9LFxuICAgICAgICAgIG9wZXJhdGlvbjogJ2RhdGEtcHJvY2Vzc2luZycsXG4gICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgIGNpcmN1bGFyOiB7fSwgLy8gV2lsbCBjcmVhdGUgY2lyY3VsYXIgcmVmZXJlbmNlXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBjaXJjdWxhciByZWZlcmVuY2VcbiAgICAgICAgZXJyb3IuY29udGV4dC5tZXRhZGF0YS5jaXJjdWxhci5zZWxmID0gZXJyb3IuY29udGV4dC5tZXRhZGF0YTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGNvbXBsZXhFcnJvciA9IGNyZWF0ZUNvbXBsZXhFcnJvcigpO1xuICAgICAgXG4gICAgICAvLyBUZXN0IHNhZmUgc2VyaWFsaXphdGlvblxuICAgICAgY29uc3Qgc2FmZVNlcmlhbGl6ZSA9IChvYmopID0+IHtcbiAgICAgICAgY29uc3Qgc2VlbiA9IG5ldyBXZWFrU2V0KCk7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChzZWVuLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW4uYWRkKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBzYWZlU2VyaWFsaXplKHtcbiAgICAgICAgbWVzc2FnZTogY29tcGxleEVycm9yLm1lc3NhZ2UsXG4gICAgICAgIGNvbnRleHQ6IGNvbXBsZXhFcnJvci5jb250ZXh0LFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChzZXJpYWxpemVkKS50b0NvbnRhaW4oJ0NvbXBsZXggZXJyb3InKTtcbiAgICAgIGV4cGVjdChzZXJpYWxpemVkKS50b0NvbnRhaW4oJ1tDaXJjdWxhcl0nKTtcbiAgICAgIGV4cGVjdChzZXJpYWxpemVkKS50b0NvbnRhaW4oJ2RhdGEtcHJvY2Vzc2luZycpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnVGltZW91dCBhbmQgQ2FuY2VsbGF0aW9uIEVkZ2UgQ2FzZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgb3BlcmF0aW9uIGNhbmNlbGxhdGlvbiBkdXJpbmcgZXhlY3V0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBBYm9ydENvbnRyb2xsZXIgfSA9IGdsb2JhbFRoaXM7XG4gICAgICBcbiAgICAgIGlmICghQWJvcnRDb250cm9sbGVyKSB7XG4gICAgICAgIC8vIFNraXAgaWYgQWJvcnRDb250cm9sbGVyIG5vdCBhdmFpbGFibGVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3QgeyBzaWduYWwgfSA9IGNvbnRyb2xsZXI7XG5cbiAgICAgIGNvbnN0IGxvbmdSdW5uaW5nT3BlcmF0aW9uID0gYXN5bmMgKHNpZ25hbCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDA7IGkrKykge1xuICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcGVyYXRpb24gd2FzIGNhbmNlbGxlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ0NvbXBsZXRlZCc7XG4gICAgICB9O1xuXG4gICAgICAvLyBDYW5jZWwgYWZ0ZXIgMTAwbXNcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCAxMDApO1xuXG4gICAgICBhd2FpdCBleHBlY3QobG9uZ1J1bm5pbmdPcGVyYXRpb24oc2lnbmFsKSlcbiAgICAgICAgLnJlamVjdHMudG9UaHJvdygnT3BlcmF0aW9uIHdhcyBjYW5jZWxsZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHRpbWVvdXQgd2l0aCByZXNvdXJjZSBjbGVhbnVwJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzb3VyY2VzID0gW107XG4gICAgICBcbiAgICAgIGNvbnN0IG9wZXJhdGlvbldpdGhSZXNvdXJjZXMgPSBhc3luYyAodGltZW91dE1zKSA9PiB7XG4gICAgICAgIGNvbnN0IGFjcXVpcmVkUmVzb3VyY2VzID0gW107XG4gICAgICAgIGNvbnN0IHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignT3BlcmF0aW9uIHRpbWVvdXQnKSksIHRpbWVvdXRNcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgd29ya1Byb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gQWNxdWlyZSByZXNvdXJjZXNcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc291cmNlID0geyBpZDogaSwgYWNxdWlyZWQ6IHRydWUgfTtcbiAgICAgICAgICAgICAgYWNxdWlyZWRSZXNvdXJjZXMucHVzaChyZXNvdXJjZSk7XG4gICAgICAgICAgICAgIHJlc291cmNlcy5wdXNoKHJlc291cmNlKTtcbiAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERvIHdvcmsgKHRoaXMgd2lsbCB0aW1lb3V0KVxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTtcbiAgICAgICAgICAgIHJldHVybiAnV29yayBjb21wbGV0ZWQnO1xuICAgICAgICAgIH0pKCk7XG5cbiAgICAgICAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5yYWNlKFt3b3JrUHJvbWlzZSwgdGltZW91dFByb21pc2VdKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAvLyBDbGVhbnVwIHJlc291cmNlcyBvbiB0aW1lb3V0XG4gICAgICAgICAgYWNxdWlyZWRSZXNvdXJjZXMuZm9yRWFjaChyZXNvdXJjZSA9PiB7XG4gICAgICAgICAgICByZXNvdXJjZS5hY3F1aXJlZCA9IGZhbHNlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBhd2FpdCBleHBlY3Qob3BlcmF0aW9uV2l0aFJlc291cmNlcygyMDApKS5yZWplY3RzLnRvVGhyb3coJ09wZXJhdGlvbiB0aW1lb3V0Jyk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIHRoYXQgcmVzb3VyY2VzIHdlcmUgY2xlYW5lZCB1cFxuICAgICAgY29uc3QgYWNxdWlyZWRSZXNvdXJjZXMgPSByZXNvdXJjZXMuZmlsdGVyKHIgPT4gci5hY3F1aXJlZCk7XG4gICAgICBleHBlY3QoYWNxdWlyZWRSZXNvdXJjZXMpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Vycm9yIFJlY292ZXJ5IFN0cmF0ZWdpZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBpbXBsZW1lbnQgcmV0cnkgd2l0aCBkaWZmZXJlbnQgc3RyYXRlZ2llcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHN0cmF0ZWdpZXMgPSB7XG4gICAgICAgIGltbWVkaWF0ZTogKGF0dGVtcHQpID0+IDAsXG4gICAgICAgIGxpbmVhcjogKGF0dGVtcHQpID0+IGF0dGVtcHQgKiAxMDAsXG4gICAgICAgIGV4cG9uZW50aWFsOiAoYXR0ZW1wdCkgPT4gTWF0aC5wb3coMiwgYXR0ZW1wdCkgKiAxMDAsXG4gICAgICAgIGZpYm9uYWNjaTogKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBmaWIgPSBbMTAwLCAxMDBdO1xuICAgICAgICAgIHJldHVybiAoYXR0ZW1wdCkgPT4ge1xuICAgICAgICAgICAgaWYgKGF0dGVtcHQgPCAyKSByZXR1cm4gZmliW2F0dGVtcHRdO1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGZpYlswXSArIGZpYlsxXTtcbiAgICAgICAgICAgIGZpYlswXSA9IGZpYlsxXTtcbiAgICAgICAgICAgIGZpYlsxXSA9IG5leHQ7XG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICB9O1xuICAgICAgICB9KSgpLFxuICAgICAgfTtcblxuICAgICAgZm9yIChjb25zdCBbc3RyYXRlZ3lOYW1lLCBiYWNrb2ZmRm5dIG9mIE9iamVjdC5lbnRyaWVzKHN0cmF0ZWdpZXMpKSB7XG4gICAgICAgIGxldCBhdHRlbXB0cyA9IDA7XG4gICAgICAgIGNvbnN0IG1heEF0dGVtcHRzID0gNDtcblxuICAgICAgICBjb25zdCByZXRyeVdpdGhTdHJhdGVneSA9IGFzeW5jIChvcGVyYXRpb24sIHN0cmF0ZWd5KSA9PiB7XG4gICAgICAgICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCBtYXhBdHRlbXB0czsgYXR0ZW1wdCsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgb3BlcmF0aW9uKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBpZiAoYXR0ZW1wdCA9PT0gbWF4QXR0ZW1wdHMgLSAxKSB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gc3RyYXRlZ3koYXR0ZW1wdCk7XG4gICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBNYXRoLm1pbihkZWxheSwgMTAwMCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgZmxha3lPcGVyYXRpb24gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgYXR0ZW1wdHMrKztcbiAgICAgICAgICBpZiAoYXR0ZW1wdHMgPCAzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c3RyYXRlZ3lOYW1lfSBhdHRlbXB0ICR7YXR0ZW1wdHN9IGZhaWxlZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYCR7c3RyYXRlZ3lOYW1lfSBzdWNjZWVkZWRgO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJldHJ5V2l0aFN0cmF0ZWd5KGZsYWt5T3BlcmF0aW9uLCBiYWNrb2ZmRm4pO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0NvbnRhaW4oJ3N1Y2NlZWRlZCcpO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVzZXQgZm9yIG5leHQgc3RyYXRlZ3lcbiAgICAgICAgYXR0ZW1wdHMgPSAwO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn0pO1xuXG4vLyBSdW4gdGVzdHMgd2hlbiBleGVjdXRlZCBkaXJlY3RseVxuaWYgKGltcG9ydC5tZXRhLnVybCA9PT0gYGZpbGU6Ly8ke3Byb2Nlc3MuYXJndlsxXX1gKSB7XG4gIGNvbnNvbGUubG9nKCdSdW5uaW5nIGVycm9yIGhhbmRsaW5nIGFuZCByZWNvdmVyeSBlZGdlIGNhc2UgdGVzdHMuLi4nKTtcbiAgXG4gIC8vIFJ1biBhbGwgdGVzdHNcbiAgY29uc3QgeyBydW4gfSA9IGF3YWl0IGltcG9ydCgnLi4vdGVzdC1ydW5uZXIuanMnKTtcbiAgYXdhaXQgcnVuKF9fZmlsZW5hbWUpO1xufSJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTQSxRQUFRLEVBQUVDLEVBQUUsRUFBRUMsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLFVBQVUsRUFBRUMsU0FBUyxRQUFRLGVBQWU7QUFDakYsU0FBU0MsUUFBUSxRQUFRLDZCQUE2QjtBQUN0RCxTQUFTQyxnQkFBZ0IsUUFBUSxpQ0FBaUM7QUFDbEUsU0FBU0MsZ0JBQWdCLFFBQVEsMEJBQTBCO0FBRTNEUixRQUFRLENBQUMsd0NBQXdDLEVBQUUsTUFBTTtFQUN2RCxJQUFJUyxRQUFRO0VBQ1osSUFBSUMsWUFBWTtFQUVoQk4sVUFBVSxDQUFDLE1BQU07SUFDZk0sWUFBWSxHQUFHO01BQ2JDLFdBQVcsRUFBRVIsSUFBSSxDQUFDUyxFQUFFLENBQUMsQ0FBQztNQUN0QkMsU0FBUyxFQUFFVixJQUFJLENBQUNTLEVBQUUsQ0FBQztJQUNyQixDQUFDO0lBQ0RILFFBQVEsR0FBRyxJQUFJRixnQkFBZ0IsQ0FBQyxDQUFDO0lBQ2pDSixJQUFJLENBQUNXLGFBQWEsQ0FBQyxDQUFDO0VBQ3RCLENBQUMsQ0FBQztFQUVGVCxTQUFTLENBQUMsTUFBTTtJQUNkRixJQUFJLENBQUNZLGVBQWUsQ0FBQyxDQUFDO0VBQ3hCLENBQUMsQ0FBQztFQUVGZixRQUFRLENBQUMsOEJBQThCLEVBQUUsTUFBTTtJQUM3Q0MsRUFBRSxDQUFDLG1DQUFtQyxlQUFBZSxpQkFBQSxDQUFFLGFB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