178dd6a7598b7cff3f0bfc42b7c45239
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
/**
 * Load Testing Suite for ruv-swarm
 * Tests concurrent operation of 50+ agents with stress testing scenarios
 */

const {
  RuvSwarm
} = require('../src/index-enhanced');
const {
  EventEmitter
} = require('events');
const fs = require('fs').promises;
const os = require('os');
class LoadTestingSuite extends EventEmitter {
  constructor() {
    super();
    this.testResults = {
      timestamp: new Date().toISOString(),
      systemInfo: {
        platform: process.platform,
        arch: process.arch,
        nodeVersion: process.version,
        cpus: os.cpus().length,
        totalMemory: os.totalmem(),
        freeMemory: os.freemem()
      },
      scenarios: [],
      performance: {
        maxConcurrentAgents: 0,
        avgResponseTime: 0,
        throughput: 0,
        errorRate: 0,
        memoryPeak: 0,
        cpuPeak: 0
      },
      passed: false
    };
    this.metrics = {
      responseTimes: [],
      memorySnapshots: [],
      errors: [],
      throughputData: []
    };
    this.monitoringInterval = null;
  }
  runLoadTests() {
    var _this = this;
    return _asyncToGenerator(function* () {
      console.log('🔥 Starting Load Testing Suite');
      console.log('==============================\n');
      _this.logSystemInfo();
      _this.startSystemMonitoring();
      try {
        // Scenario 1: Gradual load increase (10 → 60 agents)
        yield _this.runGradualLoadTest();

        // Scenario 2: Burst load test (0 → 50 agents instantly)
        yield _this.runBurstLoadTest();

        // Scenario 3: Sustained load test (50 agents for 5 minutes)
        yield _this.runSustainedLoadTest();

        // Scenario 4: Mixed workload test (different agent types)
        yield _this.runMixedWorkloadTest();

        // Scenario 5: Stress test (pushing to failure point)
        yield _this.runStressTest();

        // Generate comprehensive report
        yield _this.generateLoadTestReport();
      } catch (error) {
        console.error('❌ Load testing failed:', error);
        throw error;
      } finally {
        _this.stopSystemMonitoring();
      }
      return _this.testResults;
    })();
  }
  logSystemInfo() {
    console.log('📊 System Information:');
    console.log(`   Platform: ${this.testResults.systemInfo.platform} ${this.testResults.systemInfo.arch}`);
    console.log(`   Node.js: ${this.testResults.systemInfo.nodeVersion}`);
    console.log(`   CPUs: ${this.testResults.systemInfo.cpus}`);
    console.log(`   Memory: ${(this.testResults.systemInfo.totalMemory / 1024 / 1024 / 1024).toFixed(1)}GB total`);
    console.log(`   Free: ${(this.testResults.systemInfo.freeMemory / 1024 / 1024 / 1024).toFixed(1)}GB\n`);
  }
  startSystemMonitoring() {
    this.monitoringInterval = setInterval(() => {
      const memUsage = process.memoryUsage();
      const cpuUsage = process.cpuUsage();
      this.metrics.memorySnapshots.push({
        timestamp: Date.now(),
        heapUsed: memUsage.heapUsed,
        heapTotal: memUsage.heapTotal,
        external: memUsage.external
      });

      // Update peak values
      this.testResults.performance.memoryPeak = Math.max(this.testResults.performance.memoryPeak, memUsage.heapUsed);
    }, 1000);
  }
  stopSystemMonitoring() {
    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
    }
  }
  runGradualLoadTest() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      console.log('📈 Scenario 1: Gradual Load Increase (10 → 60 agents)');
      const scenario = {
        name: 'Gradual Load Increase',
        startTime: Date.now(),
        agents: [],
        metrics: {
          spawnTimes: [],
          executionTimes: [],
          errors: []
        },
        passed: false
      };
      try {
        const ruvSwarm = yield RuvSwarm.initialize({
          enableNeuralNetworks: true,
          enableForecasting: true,
          loadingStrategy: 'progressive'
        });
        const swarm = yield ruvSwarm.createSwarm({
          topology: 'hierarchical',
          maxAgents: 70,
          strategy: 'parallel'
        });

        // Gradually increase load from 10 to 60 agents
        for (let batch = 10; batch <= 60; batch += 10) {
          console.log(`   Spawning batch: ${batch} agents...`);
          const batchStartTime = Date.now();
          const batchPromises = [];
          for (let i = scenario.agents.length; i < batch; i++) {
            const spawnPromise = swarm.spawn({
              type: ['coder', 'researcher', 'analyst', 'optimizer'][i % 4],
              name: `gradual-agent-${i}`
            }).then(agent => {
              scenario.agents.push(agent);
              return agent;
            }).catch(error => {
              scenario.metrics.errors.push({
                phase: 'spawn',
                agent: i,
                error: error.message
              });
              return null;
            });
            batchPromises.push(spawnPromise);
          }
          yield Promise.all(batchPromises);
          const batchSpawnTime = Date.now() - batchStartTime;
          scenario.metrics.spawnTimes.push({
            batch,
            time: batchSpawnTime,
            agentsSpawned: scenario.agents.length
          });
          console.log(`     Spawned ${scenario.agents.length} agents in ${batchSpawnTime}ms`);

          // Execute tasks for current batch
          const taskPromises = scenario.agents.map((agent, i) => {
            if (!agent) return Promise.resolve();
            const taskStart = Date.now();
            return agent.execute({
              task: `Gradual load task ${i}: Calculate fibonacci(${20 + i % 10})`,
              timeout: 15000
            }).then(() => {
              scenario.metrics.executionTimes.push(Date.now() - taskStart);
            }).catch(error => {
              scenario.metrics.errors.push({
                phase: 'execution',
                agent: i,
                error: error.message
              });
            });
          });
          yield Promise.all(taskPromises);

          // Brief pause between batches
          yield new Promise(resolve => setTimeout(resolve, 2000));
        }
        scenario.passed = scenario.agents.length >= 50 && scenario.metrics.errors.length < 5;
        _this2.testResults.performance.maxConcurrentAgents = Math.max(_this2.testResults.performance.maxConcurrentAgents, scenario.agents.length);
        console.log(`   ✅ Completed: ${scenario.agents.length} agents, ${scenario.metrics.errors.length} errors`);
      } catch (error) {
        scenario.error = error.message;
        console.log(`   ❌ Failed: ${error.message}`);
      }
      scenario.duration = Date.now() - scenario.startTime;
      _this2.testResults.scenarios.push(scenario);
      console.log('');
    })();
  }
  runBurstLoadTest() {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      console.log('💥 Scenario 2: Burst Load Test (0 → 50 agents instantly)');
      const scenario = {
        name: 'Burst Load Test',
        startTime: Date.now(),
        agents: [],
        metrics: {
          spawnTime: 0,
          firstResponseTime: 0,
          allResponsesTime: 0,
          errors: []
        },
        passed: false
      };
      try {
        const ruvSwarm = yield RuvSwarm.initialize({
          enableNeuralNetworks: true,
          enableForecasting: false,
          // Reduce overhead for burst test
          loadingStrategy: 'immediate'
        });
        const swarm = yield ruvSwarm.createSwarm({
          topology: 'mesh',
          maxAgents: 60,
          strategy: 'parallel'
        });

        // Spawn all 50 agents simultaneously
        console.log('   Spawning 50 agents simultaneously...');
        const spawnStartTime = Date.now();
        const spawnPromises = Array.from({
          length: 50
        }, (_, i) => swarm.spawn({
          type: 'coder',
          name: `burst-agent-${i}`
        }).catch(error => {
          scenario.metrics.errors.push({
            phase: 'spawn',
            agent: i,
            error: error.message
          });
          return null;
        }));
        const spawnedAgents = yield Promise.all(spawnPromises);
        scenario.agents = spawnedAgents.filter(agent => agent !== null);
        scenario.metrics.spawnTime = Date.now() - spawnStartTime;
        console.log(`     Spawned ${scenario.agents.length}/50 agents in ${scenario.metrics.spawnTime}ms`);

        // Execute tasks simultaneously
        console.log('   Executing tasks simultaneously...');
        const execStartTime = Date.now();
        let firstResponseReceived = false;
        const taskPromises = scenario.agents.map((agent, i) => {
          const taskStart = Date.now();
          return agent.execute({
            task: `Burst task ${i}: Sort array of 1000 random numbers`,
            timeout: 20000
          }).then(() => {
            const responseTime = Date.now() - taskStart;
            if (!firstResponseReceived) {
              scenario.metrics.firstResponseTime = Date.now() - execStartTime;
              firstResponseReceived = true;
            }
            return responseTime;
          }).catch(error => {
            scenario.metrics.errors.push({
              phase: 'execution',
              agent: i,
              error: error.message
            });
            return null;
          });
        });
        const responseTimes = yield Promise.all(taskPromises);
        scenario.metrics.allResponsesTime = Date.now() - execStartTime;
        const validResponses = responseTimes.filter(t => t !== null);
        _this3.metrics.responseTimes.push(...validResponses);
        scenario.passed = scenario.agents.length >= 45 && scenario.metrics.errors.length < 10;
        console.log(`   First response: ${scenario.metrics.firstResponseTime}ms`);
        console.log(`   All responses: ${scenario.metrics.allResponsesTime}ms`);
        console.log(`   Average response: ${validResponses.length > 0 ? Math.round(validResponses.reduce((a, b) => a + b, 0) / validResponses.length) : 'N/A'}ms`);
        console.log(`   Errors: ${scenario.metrics.errors.length}`);
      } catch (error) {
        scenario.error = error.message;
        console.log(`   ❌ Failed: ${error.message}`);
      }
      scenario.duration = Date.now() - scenario.startTime;
      _this3.testResults.scenarios.push(scenario);
      console.log('');
    })();
  }
  runSustainedLoadTest() {
    var _this4 = this;
    return _asyncToGenerator(function* () {
      console.log('⏰ Scenario 3: Sustained Load Test (50 agents for 5 minutes)');
      const scenario = {
        name: 'Sustained Load Test',
        startTime: Date.now(),
        agents: [],
        metrics: {
          tasksCompleted: 0,
          avgTaskTime: 0,
          memoryGrowth: 0,
          errors: []
        },
        passed: false
      };
      try {
        const ruvSwarm = yield RuvSwarm.initialize({
          enableNeuralNetworks: true,
          enableForecasting: true,
          memoryOptimization: true
        });
        const swarm = yield ruvSwarm.createSwarm({
          topology: 'mesh',
          maxAgents: 60,
          strategy: 'balanced'
        });

        // Spawn 50 agents
        const spawnPromises = Array.from({
          length: 50
        }, (_, i) => swarm.spawn({
          type: ['coder', 'researcher', 'analyst'][i % 3],
          name: `sustained-agent-${i}`
        }));
        scenario.agents = yield Promise.all(spawnPromises);
        console.log(`   Spawned ${scenario.agents.length} agents`);
        const initialMemory = process.memoryUsage().heapUsed;
        const testDuration = 5 * 60 * 1000; // 5 minutes
        const endTime = Date.now() + testDuration;
        const taskTimes = [];
        let taskCounter = 0;
        console.log('   Running sustained load for 5 minutes...');
        while (Date.now() < endTime) {
          const batchPromises = scenario.agents.map(/*#__PURE__*/function () {
            var _ref = _asyncToGenerator(function* (agent, i) {
              const taskStart = Date.now();
              try {
                yield agent.execute({
                  task: `Sustained task ${taskCounter}: Process data batch ${taskCounter % 100}`,
                  timeout: 10000
                });
                const taskTime = Date.now() - taskStart;
                taskTimes.push(taskTime);
                scenario.metrics.tasksCompleted++;
                return true;
              } catch (error) {
                scenario.metrics.errors.push({
                  phase: 'sustained_execution',
                  agent: i,
                  task: taskCounter,
                  error: error.message
                });
                return false;
              }
            });
            return function (_x, _x2) {
              return _ref.apply(this, arguments);
            };
          }());
          yield Promise.all(batchPromises);
          taskCounter++;

          // Brief pause to prevent overwhelming
          yield new Promise(resolve => setTimeout(resolve, 1000));

          // Log progress every minute
          if (taskCounter % 50 === 0) {
            const elapsed = Date.now() - scenario.startTime;
            const remaining = endTime - Date.now();
            console.log(`     Progress: ${Math.round(elapsed / 1000)}s elapsed, ${Math.round(remaining / 1000)}s remaining`);
            console.log(`     Tasks completed: ${scenario.metrics.tasksCompleted}, Errors: ${scenario.metrics.errors.length}`);
          }
        }
        const finalMemory = process.memoryUsage().heapUsed;
        scenario.metrics.memoryGrowth = finalMemory - initialMemory;
        scenario.metrics.avgTaskTime = taskTimes.length > 0 ? Math.round(taskTimes.reduce((a, b) => a + b, 0) / taskTimes.length) : 0;
        scenario.passed = scenario.metrics.tasksCompleted >= 1000 && scenario.metrics.errors.length < 50 && scenario.metrics.memoryGrowth < 200 * 1024 * 1024; // Less than 200MB growth

        console.log(`   Tasks completed: ${scenario.metrics.tasksCompleted}`);
        console.log(`   Average task time: ${scenario.metrics.avgTaskTime}ms`);
        console.log(`   Memory growth: ${Math.round(scenario.metrics.memoryGrowth / 1024 / 1024)}MB`);
        console.log(`   Error rate: ${(scenario.metrics.errors.length / scenario.metrics.tasksCompleted * 100).toFixed(2)}%`);
      } catch (error) {
        scenario.error = error.message;
        console.log(`   ❌ Failed: ${error.message}`);
      }
      scenario.duration = Date.now() - scenario.startTime;
      _this4.testResults.scenarios.push(scenario);
      console.log('');
    })();
  }
  runMixedWorkloadTest() {
    var _this5 = this;
    return _asyncToGenerator(function* () {
      console.log('🎭 Scenario 4: Mixed Workload Test (different agent types)');
      const scenario = {
        name: 'Mixed Workload Test',
        startTime: Date.now(),
        agents: {
          coders: [],
          researchers: [],
          analysts: [],
          optimizers: [],
          coordinators: []
        },
        metrics: {
          tasksByType: {},
          avgTimesByType: {},
          errors: []
        },
        passed: false
      };
      try {
        const ruvSwarm = yield RuvSwarm.initialize({
          enableNeuralNetworks: true,
          enableForecasting: true,
          loadingStrategy: 'progressive'
        });
        const swarm = yield ruvSwarm.createSwarm({
          topology: 'hierarchical',
          maxAgents: 60,
          strategy: 'specialized'
        });

        // Spawn different types of agents
        const agentTypes = [{
          type: 'coder',
          count: 15
        }, {
          type: 'researcher',
          count: 12
        }, {
          type: 'analyst',
          count: 10
        }, {
          type: 'optimizer',
          count: 8
        }, {
          type: 'coordinator',
          count: 5
        }];
        console.log('   Spawning mixed agent types...');
        for (const {
          type,
          count
        } of agentTypes) {
          const typePromises = Array.from({
            length: count
          }, (_, i) => swarm.spawn({
            type,
            name: `${type}-${i}`
          }));
          const typeAgents = yield Promise.all(typePromises);
          scenario.agents[type + 's'] = typeAgents;
          scenario.metrics.tasksByType[type] = 0;
          scenario.metrics.avgTimesByType[type] = [];
          console.log(`     ${type}: ${typeAgents.length} agents`);
        }

        // Execute type-specific tasks
        console.log('   Executing type-specific workloads...');
        const workloadPromises = Object.entries(scenario.agents).map(/*#__PURE__*/function () {
          var _ref2 = _asyncToGenerator(function* ([agentType, agents]) {
            const type = agentType.slice(0, -1); // Remove 's' suffix

            return Promise.all(agents.map(/*#__PURE__*/function () {
              var _ref3 = _asyncToGenerator(function* (agent, i) {
                const tasks = _this5.getTasksForType(type, i);
                for (const task of tasks) {
                  const taskStart = Date.now();
                  try {
                    yield agent.execute({
                      task: task.description,
                      timeout: task.timeout
                    });
                    const taskTime = Date.now() - taskStart;
                    scenario.metrics.avgTimesByType[type].push(taskTime);
                    scenario.metrics.tasksByType[type]++;
                  } catch (error) {
                    scenario.metrics.errors.push({
                      phase: 'mixed_workload',
                      agentType: type,
                      agent: i,
                      task: task.description,
                      error: error.message
                    });
                  }
                }
              });
              return function (_x4, _x5) {
                return _ref3.apply(this, arguments);
              };
            }()));
          });
          return function (_x3) {
            return _ref2.apply(this, arguments);
          };
        }());
        yield Promise.all(workloadPromises);

        // Calculate averages
        Object.entries(scenario.metrics.avgTimesByType).forEach(([type, times]) => {
          scenario.metrics.avgTimesByType[type] = times.length > 0 ? Math.round(times.reduce((a, b) => a + b, 0) / times.length) : 0;
        });
        const totalAgents = Object.values(scenario.agents).flat().length;
        const totalTasks = Object.values(scenario.metrics.tasksByType).reduce((a, b) => a + b, 0);
        scenario.passed = totalAgents >= 50 && totalTasks >= 150 && scenario.metrics.errors.length < 15;
        console.log(`   Total agents: ${totalAgents}`);
        console.log(`   Total tasks: ${totalTasks}`);
        console.log(`   Tasks by type:`, scenario.metrics.tasksByType);
        console.log(`   Avg times by type:`, scenario.metrics.avgTimesByType);
        console.log(`   Errors: ${scenario.metrics.errors.length}`);
      } catch (error) {
        scenario.error = error.message;
        console.log(`   ❌ Failed: ${error.message}`);
      }
      scenario.duration = Date.now() - scenario.startTime;
      _this5.testResults.scenarios.push(scenario);
      console.log('');
    })();
  }
  runStressTest() {
    var _this6 = this;
    return _asyncToGenerator(function* () {
      console.log('🔥 Scenario 5: Stress Test (pushing to failure point)');
      const scenario = {
        name: 'Stress Test',
        startTime: Date.now(),
        maxAgentsReached: 0,
        failurePoint: null,
        metrics: {
          memoryAtFailure: 0,
          agentSpawnFailures: 0,
          taskExecutionFailures: 0,
          systemErrors: []
        },
        passed: false
      };
      try {
        const ruvSwarm = yield RuvSwarm.initialize({
          enableNeuralNetworks: true,
          enableForecasting: false,
          loadingStrategy: 'immediate'
        });
        const swarm = yield ruvSwarm.createSwarm({
          topology: 'mesh',
          maxAgents: 200,
          // High limit for stress testing
          strategy: 'parallel'
        });
        console.log('   Progressively increasing load until failure...');
        let currentAgents = [];
        let batchSize = 10;
        let maxBatchSize = 50;
        for (let targetCount = 10; targetCount <= 150; targetCount += batchSize) {
          console.log(`   Attempting to reach ${targetCount} agents...`);
          try {
            // Spawn additional agents
            const newAgents = [];
            const spawnPromises = [];
            for (let i = currentAgents.length; i < targetCount; i++) {
              spawnPromises.push(swarm.spawn({
                type: 'coder',
                name: `stress-agent-${i}`
              }).then(agent => {
                newAgents.push(agent);
                return agent;
              }).catch(error => {
                scenario.metrics.agentSpawnFailures++;
                scenario.metrics.systemErrors.push({
                  phase: 'spawn',
                  agent: i,
                  error: error.message
                });
                return null;
              }));
            }
            const spawnedBatch = yield Promise.all(spawnPromises);
            currentAgents.push(...spawnedBatch.filter(agent => agent !== null));
            scenario.maxAgentsReached = currentAgents.length;
            console.log(`     Successfully spawned ${currentAgents.length} agents`);

            // Test execution with current agent count
            const taskPromises = currentAgents.map((agent, i) => {
              if (!agent) return Promise.resolve();
              return agent.execute({
                task: `Stress test task ${i}: Heavy computation`,
                timeout: 10000
              }).catch(error => {
                scenario.metrics.taskExecutionFailures++;
                scenario.metrics.systemErrors.push({
                  phase: 'execution',
                  agent: i,
                  error: error.message
                });
              });
            });
            yield Promise.allSettled(taskPromises);

            // Check memory usage
            const memUsage = process.memoryUsage();
            const memoryMB = memUsage.heapUsed / 1024 / 1024;
            console.log(`     Memory usage: ${memoryMB.toFixed(1)}MB`);
            console.log(`     Spawn failures: ${scenario.metrics.agentSpawnFailures}`);
            console.log(`     Execution failures: ${scenario.metrics.taskExecutionFailures}`);

            // Check if we're approaching limits
            if (memoryMB > 1000 || scenario.metrics.agentSpawnFailures > 10) {
              scenario.failurePoint = {
                agentCount: currentAgents.length,
                memory: memoryMB,
                reason: memoryMB > 1000 ? 'memory_limit' : 'spawn_failures'
              };
              console.log(`   Failure point reached: ${scenario.failurePoint.reason}`);
              break;
            }

            // Increase batch size for efficiency, but cap it
            batchSize = Math.min(batchSize + 5, maxBatchSize);
          } catch (error) {
            scenario.failurePoint = {
              agentCount: currentAgents.length,
              memory: process.memoryUsage().heapUsed / 1024 / 1024,
              reason: 'system_error',
              error: error.message
            };
            console.log(`   System error at ${currentAgents.length} agents: ${error.message}`);
            break;
          }

          // Brief pause between stress increments
          yield new Promise(resolve => setTimeout(resolve, 2000));
        }
        scenario.metrics.memoryAtFailure = process.memoryUsage().heapUsed / 1024 / 1024;
        scenario.passed = scenario.maxAgentsReached >= 80; // Minimum threshold for stress test

        console.log(`   Maximum agents reached: ${scenario.maxAgentsReached}`);
        console.log(`   Failure point:`, scenario.failurePoint || 'No failure reached');
        console.log(`   Memory at end: ${scenario.metrics.memoryAtFailure.toFixed(1)}MB`);
      } catch (error) {
        scenario.error = error.message;
        console.log(`   ❌ Failed: ${error.message}`);
      }
      scenario.duration = Date.now() - scenario.startTime;
      _this6.testResults.scenarios.push(scenario);
      console.log('');
    })();
  }
  getTasksForType(type, agentIndex) {
    const taskSets = {
      coder: [{
        description: `Code review task ${agentIndex}: Analyze function complexity`,
        timeout: 8000
      }, {
        description: `Implementation task ${agentIndex}: Write sorting algorithm`,
        timeout: 12000
      }, {
        description: `Debug task ${agentIndex}: Find memory leak`,
        timeout: 10000
      }],
      researcher: [{
        description: `Research task ${agentIndex}: Literature review on AI`,
        timeout: 15000
      }, {
        description: `Analysis task ${agentIndex}: Trend analysis`,
        timeout: 12000
      }],
      analyst: [{
        description: `Data analysis ${agentIndex}: Process dataset`,
        timeout: 10000
      }, {
        description: `Statistical analysis ${agentIndex}: Correlation study`,
        timeout: 8000
      }],
      optimizer: [{
        description: `Optimization task ${agentIndex}: Algorithm tuning`,
        timeout: 15000
      }, {
        description: `Performance task ${agentIndex}: Bottleneck analysis`,
        timeout: 12000
      }],
      coordinator: [{
        description: `Coordination task ${agentIndex}: Task scheduling`,
        timeout: 6000
      }, {
        description: `Management task ${agentIndex}: Resource allocation`,
        timeout: 8000
      }]
    };
    return taskSets[type] || [{
      description: `Generic task ${agentIndex}`,
      timeout: 8000
    }];
  }
  generateLoadTestReport() {
    var _this7 = this;
    return _asyncToGenerator(function* () {
      console.log('📄 Generating Load Test Report...');

      // Calculate overall metrics
      const passedScenarios = _this7.testResults.scenarios.filter(s => s.passed).length;
      const totalScenarios = _this7.testResults.scenarios.length;
      _this7.testResults.performance.avgResponseTime = _this7.metrics.responseTimes.length > 0 ? Math.round(_this7.metrics.responseTimes.reduce((a, b) => a + b, 0) / _this7.metrics.responseTimes.length) : 0;
      _this7.testResults.performance.errorRate = _this7.metrics.errors.length > 0 ? (_this7.metrics.errors.length / (_this7.metrics.responseTimes.length + _this7.metrics.errors.length) * 100).toFixed(2) : 0;
      _this7.testResults.performance.memoryPeak = _this7.testResults.performance.memoryPeak / 1024 / 1024; // Convert to MB

      _this7.testResults.passed = passedScenarios >= 4; // At least 4/5 scenarios must pass

      const report = _objectSpread(_objectSpread({}, _this7.testResults), {}, {
        summary: {
          totalScenarios,
          passedScenarios,
          failedScenarios: totalScenarios - passedScenarios,
          successRate: (passedScenarios / totalScenarios * 100).toFixed(1) + '%',
          overallPassed: _this7.testResults.passed
        }
      });

      // Save detailed report
      const reportPath = '/workspaces/ruv-FANN/ruv-swarm/npm/test/load-test-report.json';
      yield fs.writeFile(reportPath, JSON.stringify(report, null, 2));

      // Console summary
      console.log('\n🎯 LOAD TEST SUMMARY');
      console.log('====================');
      console.log(`Scenarios Passed: ${passedScenarios}/${totalScenarios} (${report.summary.successRate})`);
      console.log(`Max Concurrent Agents: ${_this7.testResults.performance.maxConcurrentAgents}`);
      console.log(`Average Response Time: ${_this7.testResults.performance.avgResponseTime}ms`);
      console.log(`Error Rate: ${_this7.testResults.performance.errorRate}%`);
      console.log(`Peak Memory Usage: ${_this7.testResults.performance.memoryPeak.toFixed(1)}MB`);
      console.log(`Overall Status: ${_this7.testResults.passed ? '✅ PASSED' : '❌ FAILED'}`);
      console.log('\n📋 Scenario Results:');
      _this7.testResults.scenarios.forEach(scenario => {
        console.log(`   ${scenario.passed ? '✅' : '❌'} ${scenario.name} (${scenario.duration}ms)`);
      });
      console.log(`\n📄 Detailed report saved to: ${reportPath}`);
      return report;
    })();
  }
}

// Main execution
function runLoadTests() {
  return _runLoadTests.apply(this, arguments);
}
function _runLoadTests() {
  _runLoadTests = _asyncToGenerator(function* () {
    try {
      const loadTester = new LoadTestingSuite();
      const results = yield loadTester.runLoadTests();
      process.exit(results.passed ? 0 : 1);
    } catch (error) {
      console.error('💥 Load testing failed:', error);
      process.exit(1);
    }
  });
  return _runLoadTests.apply(this, arguments);
}
if (require.main === module) {
  runLoadTests();
}
module.exports = {
  LoadTestingSuite
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJSdXZTd2FybSIsInJlcXVpcmUiLCJFdmVudEVtaXR0ZXIiLCJmcyIsInByb21pc2VzIiwib3MiLCJMb2FkVGVzdGluZ1N1aXRlIiwiY29uc3RydWN0b3IiLCJ0ZXN0UmVzdWx0cyIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInN5c3RlbUluZm8iLCJwbGF0Zm9ybSIsInByb2Nlc3MiLCJhcmNoIiwibm9kZVZlcnNpb24iLCJ2ZXJzaW9uIiwiY3B1cyIsImxlbmd0aCIsInRvdGFsTWVtb3J5IiwidG90YWxtZW0iLCJmcmVlTWVtb3J5IiwiZnJlZW1lbSIsInNjZW5hcmlvcyIsInBlcmZvcm1hbmNlIiwibWF4Q29uY3VycmVudEFnZW50cyIsImF2Z1Jlc3BvbnNlVGltZSIsInRocm91Z2hwdXQiLCJlcnJvclJhdGUiLCJtZW1vcnlQZWFrIiwiY3B1UGVhayIsInBhc3NlZCIsIm1ldHJpY3MiLCJyZXNwb25zZVRpbWVzIiwibWVtb3J5U25hcHNob3RzIiwiZXJyb3JzIiwidGhyb3VnaHB1dERhdGEiLCJtb25pdG9yaW5nSW50ZXJ2YWwiLCJydW5Mb2FkVGVzdHMiLCJfdGhpcyIsIl9hc3luY1RvR2VuZXJhdG9yIiwiY29uc29sZSIsImxvZyIsImxvZ1N5c3RlbUluZm8iLCJzdGFydFN5c3RlbU1vbml0b3JpbmciLCJydW5HcmFkdWFsTG9hZFRlc3QiLCJydW5CdXJzdExvYWRUZXN0IiwicnVuU3VzdGFpbmVkTG9hZFRlc3QiLCJydW5NaXhlZFdvcmtsb2FkVGVzdCIsInJ1blN0cmVzc1Rlc3QiLCJnZW5lcmF0ZUxvYWRUZXN0UmVwb3J0IiwiZXJyb3IiLCJzdG9wU3lzdGVtTW9uaXRvcmluZyIsInRvRml4ZWQiLCJzZXRJbnRlcnZhbCIsIm1lbVVzYWdlIiwibWVtb3J5VXNhZ2UiLCJjcHVVc2FnZSIsInB1c2giLCJub3ciLCJoZWFwVXNlZCIsImhlYXBUb3RhbCIsImV4dGVybmFsIiwiTWF0aCIsIm1heCIsImNsZWFySW50ZXJ2YWwiLCJfdGhpczIiLCJzY2VuYXJpbyIsIm5hbWUiLCJzdGFydFRpbWUiLCJhZ2VudHMiLCJzcGF3blRpbWVzIiwiZXhlY3V0aW9uVGltZXMiLCJydXZTd2FybSIsImluaXRpYWxpemUiLCJlbmFibGVOZXVyYWxOZXR3b3JrcyIsImVuYWJsZUZvcmVjYXN0aW5nIiwibG9hZGluZ1N0cmF0ZWd5Iiwic3dhcm0iLCJjcmVhdGVTd2FybSIsInRvcG9sb2d5IiwibWF4QWdlbnRzIiwic3RyYXRlZ3kiLCJiYXRjaCIsImJhdGNoU3RhcnRUaW1lIiwiYmF0Y2hQcm9taXNlcyIsImkiLCJzcGF3blByb21pc2UiLCJzcGF3biIsInR5cGUiLCJ0aGVuIiwiYWdlbnQiLCJjYXRjaCIsInBoYXNlIiwibWVzc2FnZSIsIlByb21pc2UiLCJhbGwiLCJiYXRjaFNwYXduVGltZSIsInRpbWUiLCJhZ2VudHNTcGF3bmVkIiwidGFza1Byb21pc2VzIiwibWFwIiwicmVzb2x2ZSIsInRhc2tTdGFydCIsImV4ZWN1dGUiLCJ0YXNrIiwidGltZW91dCIsInNldFRpbWVvdXQiLCJkdXJhdGlvbiIsIl90aGlzMyIsInNwYXduVGltZSIsImZpcnN0UmVzcG9uc2VUaW1lIiwiYWxsUmVzcG9uc2VzVGltZSIsInNwYXduU3RhcnRUaW1lIiwic3Bhd25Qcm9taXNlcyIsIkFycmF5IiwiZnJvbSIsIl8iLCJzcGF3bmVkQWdlbnRzIiwiZmlsdGVyIiwiZXhlY1N0YXJ0VGltZSIsImZpcnN0UmVzcG9uc2VSZWNlaXZlZCIsInJlc3BvbnNlVGltZSIsInZhbGlkUmVzcG9uc2VzIiwidCIsInJvdW5kIiwicmVkdWNlIiwiYSIsImIiLCJfdGhpczQiLCJ0YXNrc0NvbXBsZXRlZCIsImF2Z1Rhc2tUaW1lIiwibWVtb3J5R3Jvd3RoIiwibWVtb3J5T3B0aW1pemF0aW9uIiwiaW5pdGlhbE1lbW9yeSIsInRlc3REdXJhdGlvbiIsImVuZFRpbWUiLCJ0YXNrVGltZXMiLCJ0YXNrQ291bnRlciIsIl9yZWYiLCJ0YXNrVGltZSIsIl94IiwiX3gyIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJlbGFwc2VkIiwicmVtYWluaW5nIiwiZmluYWxNZW1vcnkiLCJfdGhpczUiLCJjb2RlcnMiLCJyZXNlYXJjaGVycyIsImFuYWx5c3RzIiwib3B0aW1pemVycyIsImNvb3JkaW5hdG9ycyIsInRhc2tzQnlUeXBlIiwiYXZnVGltZXNCeVR5cGUiLCJhZ2VudFR5cGVzIiwiY291bnQiLCJ0eXBlUHJvbWlzZXMiLCJ0eXBlQWdlbnRzIiwid29ya2xvYWRQcm9taXNlcyIsIk9iamVjdCIsImVudHJpZXMiLCJfcmVmMiIsImFnZW50VHlwZSIsInNsaWNlIiwiX3JlZjMiLCJ0YXNrcyIsImdldFRhc2tzRm9yVHlwZSIsImRlc2NyaXB0aW9uIiwiX3g0IiwiX3g1IiwiX3gzIiwiZm9yRWFjaCIsInRpbWVzIiwidG90YWxBZ2VudHMiLCJ2YWx1ZXMiLCJmbGF0IiwidG90YWxUYXNrcyIsIl90aGlzNiIsIm1heEFnZW50c1JlYWNoZWQiLCJmYWlsdXJlUG9pbnQiLCJtZW1vcnlBdEZhaWx1cmUiLCJhZ2VudFNwYXduRmFpbHVyZXMiLCJ0YXNrRXhlY3V0aW9uRmFpbHVyZXMiLCJzeXN0ZW1FcnJvcnMiLCJjdXJyZW50QWdlbnRzIiwiYmF0Y2hTaXplIiwibWF4QmF0Y2hTaXplIiwidGFyZ2V0Q291bnQiLCJuZXdBZ2VudHMiLCJzcGF3bmVkQmF0Y2giLCJhbGxTZXR0bGVkIiwibWVtb3J5TUIiLCJhZ2VudENvdW50IiwibWVtb3J5IiwicmVhc29uIiwibWluIiwiYWdlbnRJbmRleCIsInRhc2tTZXRzIiwiY29kZXIiLCJyZXNlYXJjaGVyIiwiYW5hbHlzdCIsIm9wdGltaXplciIsImNvb3JkaW5hdG9yIiwiX3RoaXM3IiwicGFzc2VkU2NlbmFyaW9zIiwicyIsInRvdGFsU2NlbmFyaW9zIiwicmVwb3J0IiwiX29iamVjdFNwcmVhZCIsInN1bW1hcnkiLCJmYWlsZWRTY2VuYXJpb3MiLCJzdWNjZXNzUmF0ZSIsIm92ZXJhbGxQYXNzZWQiLCJyZXBvcnRQYXRoIiwid3JpdGVGaWxlIiwiSlNPTiIsInN0cmluZ2lmeSIsIl9ydW5Mb2FkVGVzdHMiLCJsb2FkVGVzdGVyIiwicmVzdWx0cyIsImV4aXQiLCJtYWluIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VzIjpbImxvYWQtdGVzdGluZy1zdWl0ZS50ZXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4vKipcbiAqIExvYWQgVGVzdGluZyBTdWl0ZSBmb3IgcnV2LXN3YXJtXG4gKiBUZXN0cyBjb25jdXJyZW50IG9wZXJhdGlvbiBvZiA1MCsgYWdlbnRzIHdpdGggc3RyZXNzIHRlc3Rpbmcgc2NlbmFyaW9zXG4gKi9cblxuY29uc3QgeyBSdXZTd2FybSB9ID0gcmVxdWlyZSgnLi4vc3JjL2luZGV4LWVuaGFuY2VkJyk7XG5jb25zdCB7IEV2ZW50RW1pdHRlciB9ID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJykucHJvbWlzZXM7XG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5cbmNsYXNzIExvYWRUZXN0aW5nU3VpdGUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRlc3RSZXN1bHRzID0ge1xuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBzeXN0ZW1JbmZvOiB7XG4gICAgICAgICAgICAgICAgcGxhdGZvcm06IHByb2Nlc3MucGxhdGZvcm0sXG4gICAgICAgICAgICAgICAgYXJjaDogcHJvY2Vzcy5hcmNoLFxuICAgICAgICAgICAgICAgIG5vZGVWZXJzaW9uOiBwcm9jZXNzLnZlcnNpb24sXG4gICAgICAgICAgICAgICAgY3B1czogb3MuY3B1cygpLmxlbmd0aCxcbiAgICAgICAgICAgICAgICB0b3RhbE1lbW9yeTogb3MudG90YWxtZW0oKSxcbiAgICAgICAgICAgICAgICBmcmVlTWVtb3J5OiBvcy5mcmVlbWVtKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzY2VuYXJpb3M6IFtdLFxuICAgICAgICAgICAgcGVyZm9ybWFuY2U6IHtcbiAgICAgICAgICAgICAgICBtYXhDb25jdXJyZW50QWdlbnRzOiAwLFxuICAgICAgICAgICAgICAgIGF2Z1Jlc3BvbnNlVGltZTogMCxcbiAgICAgICAgICAgICAgICB0aHJvdWdocHV0OiAwLFxuICAgICAgICAgICAgICAgIGVycm9yUmF0ZTogMCxcbiAgICAgICAgICAgICAgICBtZW1vcnlQZWFrOiAwLFxuICAgICAgICAgICAgICAgIGNwdVBlYWs6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXNzZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubWV0cmljcyA9IHtcbiAgICAgICAgICAgIHJlc3BvbnNlVGltZXM6IFtdLFxuICAgICAgICAgICAgbWVtb3J5U25hcHNob3RzOiBbXSxcbiAgICAgICAgICAgIGVycm9yczogW10sXG4gICAgICAgICAgICB0aHJvdWdocHV0RGF0YTogW11cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tb25pdG9yaW5nSW50ZXJ2YWwgPSBudWxsO1xuICAgIH1cblxuICAgIGFzeW5jIHJ1bkxvYWRUZXN0cygpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ/CflKUgU3RhcnRpbmcgTG9hZCBUZXN0aW5nIFN1aXRlJyk7XG4gICAgICAgIGNvbnNvbGUubG9nKCc9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4nKTtcblxuICAgICAgICB0aGlzLmxvZ1N5c3RlbUluZm8oKTtcbiAgICAgICAgdGhpcy5zdGFydFN5c3RlbU1vbml0b3JpbmcoKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gU2NlbmFyaW8gMTogR3JhZHVhbCBsb2FkIGluY3JlYXNlICgxMCDihpIgNjAgYWdlbnRzKVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5ydW5HcmFkdWFsTG9hZFRlc3QoKTtcblxuICAgICAgICAgICAgLy8gU2NlbmFyaW8gMjogQnVyc3QgbG9hZCB0ZXN0ICgwIOKGkiA1MCBhZ2VudHMgaW5zdGFudGx5KVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5ydW5CdXJzdExvYWRUZXN0KCk7XG5cbiAgICAgICAgICAgIC8vIFNjZW5hcmlvIDM6IFN1c3RhaW5lZCBsb2FkIHRlc3QgKDUwIGFnZW50cyBmb3IgNSBtaW51dGVzKVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5ydW5TdXN0YWluZWRMb2FkVGVzdCgpO1xuXG4gICAgICAgICAgICAvLyBTY2VuYXJpbyA0OiBNaXhlZCB3b3JrbG9hZCB0ZXN0IChkaWZmZXJlbnQgYWdlbnQgdHlwZXMpXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJ1bk1peGVkV29ya2xvYWRUZXN0KCk7XG5cbiAgICAgICAgICAgIC8vIFNjZW5hcmlvIDU6IFN0cmVzcyB0ZXN0IChwdXNoaW5nIHRvIGZhaWx1cmUgcG9pbnQpXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJ1blN0cmVzc1Rlc3QoKTtcblxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgY29tcHJlaGVuc2l2ZSByZXBvcnRcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZ2VuZXJhdGVMb2FkVGVzdFJlcG9ydCgpO1xuXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgTG9hZCB0ZXN0aW5nIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuc3RvcFN5c3RlbU1vbml0b3JpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnRlc3RSZXN1bHRzO1xuICAgIH1cblxuICAgIGxvZ1N5c3RlbUluZm8oKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OKIFN5c3RlbSBJbmZvcm1hdGlvbjonKTtcbiAgICAgICAgY29uc29sZS5sb2coYCAgIFBsYXRmb3JtOiAke3RoaXMudGVzdFJlc3VsdHMuc3lzdGVtSW5mby5wbGF0Zm9ybX0gJHt0aGlzLnRlc3RSZXN1bHRzLnN5c3RlbUluZm8uYXJjaH1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYCAgIE5vZGUuanM6ICR7dGhpcy50ZXN0UmVzdWx0cy5zeXN0ZW1JbmZvLm5vZGVWZXJzaW9ufWApO1xuICAgICAgICBjb25zb2xlLmxvZyhgICAgQ1BVczogJHt0aGlzLnRlc3RSZXN1bHRzLnN5c3RlbUluZm8uY3B1c31gKTtcbiAgICAgICAgY29uc29sZS5sb2coYCAgIE1lbW9yeTogJHsodGhpcy50ZXN0UmVzdWx0cy5zeXN0ZW1JbmZvLnRvdGFsTWVtb3J5IC8gMTAyNCAvIDEwMjQgLyAxMDI0KS50b0ZpeGVkKDEpfUdCIHRvdGFsYCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGAgICBGcmVlOiAkeyh0aGlzLnRlc3RSZXN1bHRzLnN5c3RlbUluZm8uZnJlZU1lbW9yeSAvIDEwMjQgLyAxMDI0IC8gMTAyNCkudG9GaXhlZCgxKX1HQlxcbmApO1xuICAgIH1cblxuICAgIHN0YXJ0U3lzdGVtTW9uaXRvcmluZygpIHtcbiAgICAgICAgdGhpcy5tb25pdG9yaW5nSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZW1Vc2FnZSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKTtcbiAgICAgICAgICAgIGNvbnN0IGNwdVVzYWdlID0gcHJvY2Vzcy5jcHVVc2FnZSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLm1ldHJpY3MubWVtb3J5U25hcHNob3RzLnB1c2goe1xuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgICBoZWFwVXNlZDogbWVtVXNhZ2UuaGVhcFVzZWQsXG4gICAgICAgICAgICAgICAgaGVhcFRvdGFsOiBtZW1Vc2FnZS5oZWFwVG90YWwsXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWw6IG1lbVVzYWdlLmV4dGVybmFsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHBlYWsgdmFsdWVzXG4gICAgICAgICAgICB0aGlzLnRlc3RSZXN1bHRzLnBlcmZvcm1hbmNlLm1lbW9yeVBlYWsgPSBNYXRoLm1heChcbiAgICAgICAgICAgICAgICB0aGlzLnRlc3RSZXN1bHRzLnBlcmZvcm1hbmNlLm1lbW9yeVBlYWssXG4gICAgICAgICAgICAgICAgbWVtVXNhZ2UuaGVhcFVzZWRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sIDEwMDApO1xuICAgIH1cblxuICAgIHN0b3BTeXN0ZW1Nb25pdG9yaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5tb25pdG9yaW5nSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5tb25pdG9yaW5nSW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgcnVuR3JhZHVhbExvYWRUZXN0KCkge1xuICAgICAgICBjb25zb2xlLmxvZygn8J+TiCBTY2VuYXJpbyAxOiBHcmFkdWFsIExvYWQgSW5jcmVhc2UgKDEwIOKGkiA2MCBhZ2VudHMpJyk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBzY2VuYXJpbyA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdHcmFkdWFsIExvYWQgSW5jcmVhc2UnLFxuICAgICAgICAgICAgc3RhcnRUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgYWdlbnRzOiBbXSxcbiAgICAgICAgICAgIG1ldHJpY3M6IHtcbiAgICAgICAgICAgICAgICBzcGF3blRpbWVzOiBbXSxcbiAgICAgICAgICAgICAgICBleGVjdXRpb25UaW1lczogW10sXG4gICAgICAgICAgICAgICAgZXJyb3JzOiBbXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhc3NlZDogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcnV2U3dhcm0gPSBhd2FpdCBSdXZTd2FybS5pbml0aWFsaXplKHtcbiAgICAgICAgICAgICAgICBlbmFibGVOZXVyYWxOZXR3b3JrczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbmFibGVGb3JlY2FzdGluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBsb2FkaW5nU3RyYXRlZ3k6ICdwcm9ncmVzc2l2ZSdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBzd2FybSA9IGF3YWl0IHJ1dlN3YXJtLmNyZWF0ZVN3YXJtKHtcbiAgICAgICAgICAgICAgICB0b3BvbG9neTogJ2hpZXJhcmNoaWNhbCcsXG4gICAgICAgICAgICAgICAgbWF4QWdlbnRzOiA3MCxcbiAgICAgICAgICAgICAgICBzdHJhdGVneTogJ3BhcmFsbGVsJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEdyYWR1YWxseSBpbmNyZWFzZSBsb2FkIGZyb20gMTAgdG8gNjAgYWdlbnRzXG4gICAgICAgICAgICBmb3IgKGxldCBiYXRjaCA9IDEwOyBiYXRjaCA8PSA2MDsgYmF0Y2ggKz0gMTApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgU3Bhd25pbmcgYmF0Y2g6ICR7YmF0Y2h9IGFnZW50cy4uLmApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXRjaFByb21pc2VzID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gc2NlbmFyaW8uYWdlbnRzLmxlbmd0aDsgaSA8IGJhdGNoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3Bhd25Qcm9taXNlID0gc3dhcm0uc3Bhd24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogWydjb2RlcicsICdyZXNlYXJjaGVyJywgJ2FuYWx5c3QnLCAnb3B0aW1pemVyJ11baSAlIDRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogYGdyYWR1YWwtYWdlbnQtJHtpfWBcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbihhZ2VudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2VuYXJpby5hZ2VudHMucHVzaChhZ2VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWdlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjZW5hcmlvLm1ldHJpY3MuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBoYXNlOiAnc3Bhd24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFnZW50OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGJhdGNoUHJvbWlzZXMucHVzaChzcGF3blByb21pc2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGJhdGNoUHJvbWlzZXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoU3Bhd25UaW1lID0gRGF0ZS5ub3coKSAtIGJhdGNoU3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgIHNjZW5hcmlvLm1ldHJpY3Muc3Bhd25UaW1lcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2gsXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IGJhdGNoU3Bhd25UaW1lLFxuICAgICAgICAgICAgICAgICAgICBhZ2VudHNTcGF3bmVkOiBzY2VuYXJpby5hZ2VudHMubGVuZ3RoXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgICBTcGF3bmVkICR7c2NlbmFyaW8uYWdlbnRzLmxlbmd0aH0gYWdlbnRzIGluICR7YmF0Y2hTcGF3blRpbWV9bXNgKTtcblxuICAgICAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGFza3MgZm9yIGN1cnJlbnQgYmF0Y2hcbiAgICAgICAgICAgICAgICBjb25zdCB0YXNrUHJvbWlzZXMgPSBzY2VuYXJpby5hZ2VudHMubWFwKChhZ2VudCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFnZW50KSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXNrU3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWdlbnQuZXhlY3V0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrOiBgR3JhZHVhbCBsb2FkIHRhc2sgJHtpfTogQ2FsY3VsYXRlIGZpYm9uYWNjaSgkezIwICsgKGkgJSAxMCl9KWAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiAxNTAwMFxuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjZW5hcmlvLm1ldHJpY3MuZXhlY3V0aW9uVGltZXMucHVzaChEYXRlLm5vdygpIC0gdGFza1N0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NlbmFyaW8ubWV0cmljcy5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGhhc2U6ICdleGVjdXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFnZW50OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0YXNrUHJvbWlzZXMpO1xuXG4gICAgICAgICAgICAgICAgLy8gQnJpZWYgcGF1c2UgYmV0d2VlbiBiYXRjaGVzXG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMDApKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2NlbmFyaW8ucGFzc2VkID0gc2NlbmFyaW8uYWdlbnRzLmxlbmd0aCA+PSA1MCAmJiBzY2VuYXJpby5tZXRyaWNzLmVycm9ycy5sZW5ndGggPCA1O1xuICAgICAgICAgICAgdGhpcy50ZXN0UmVzdWx0cy5wZXJmb3JtYW5jZS5tYXhDb25jdXJyZW50QWdlbnRzID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgdGhpcy50ZXN0UmVzdWx0cy5wZXJmb3JtYW5jZS5tYXhDb25jdXJyZW50QWdlbnRzLFxuICAgICAgICAgICAgICAgIHNjZW5hcmlvLmFnZW50cy5sZW5ndGhcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICDinIUgQ29tcGxldGVkOiAke3NjZW5hcmlvLmFnZW50cy5sZW5ndGh9IGFnZW50cywgJHtzY2VuYXJpby5tZXRyaWNzLmVycm9ycy5sZW5ndGh9IGVycm9yc2ApO1xuXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBzY2VuYXJpby5lcnJvciA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICAg4p2MIEZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgc2NlbmFyaW8uZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc2NlbmFyaW8uc3RhcnRUaW1lO1xuICAgICAgICB0aGlzLnRlc3RSZXN1bHRzLnNjZW5hcmlvcy5wdXNoKHNjZW5hcmlvKTtcbiAgICAgICAgY29uc29sZS5sb2coJycpO1xuICAgIH1cblxuICAgIGFzeW5jIHJ1bkJ1cnN0TG9hZFRlc3QoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5KlIFNjZW5hcmlvIDI6IEJ1cnN0IExvYWQgVGVzdCAoMCDihpIgNTAgYWdlbnRzIGluc3RhbnRseSknKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHNjZW5hcmlvID0ge1xuICAgICAgICAgICAgbmFtZTogJ0J1cnN0IExvYWQgVGVzdCcsXG4gICAgICAgICAgICBzdGFydFRpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICBhZ2VudHM6IFtdLFxuICAgICAgICAgICAgbWV0cmljczoge1xuICAgICAgICAgICAgICAgIHNwYXduVGltZTogMCxcbiAgICAgICAgICAgICAgICBmaXJzdFJlc3BvbnNlVGltZTogMCxcbiAgICAgICAgICAgICAgICBhbGxSZXNwb25zZXNUaW1lOiAwLFxuICAgICAgICAgICAgICAgIGVycm9yczogW11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXNzZWQ6IGZhbHNlXG4gICAgICAgIH07XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJ1dlN3YXJtID0gYXdhaXQgUnV2U3dhcm0uaW5pdGlhbGl6ZSh7XG4gICAgICAgICAgICAgICAgZW5hYmxlTmV1cmFsTmV0d29ya3M6IHRydWUsXG4gICAgICAgICAgICAgICAgZW5hYmxlRm9yZWNhc3Rpbmc6IGZhbHNlLCAvLyBSZWR1Y2Ugb3ZlcmhlYWQgZm9yIGJ1cnN0IHRlc3RcbiAgICAgICAgICAgICAgICBsb2FkaW5nU3RyYXRlZ3k6ICdpbW1lZGlhdGUnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3Qgc3dhcm0gPSBhd2FpdCBydXZTd2FybS5jcmVhdGVTd2FybSh7XG4gICAgICAgICAgICAgICAgdG9wb2xvZ3k6ICdtZXNoJyxcbiAgICAgICAgICAgICAgICBtYXhBZ2VudHM6IDYwLFxuICAgICAgICAgICAgICAgIHN0cmF0ZWd5OiAncGFyYWxsZWwnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gU3Bhd24gYWxsIDUwIGFnZW50cyBzaW11bHRhbmVvdXNseVxuICAgICAgICAgICAgY29uc29sZS5sb2coJyAgIFNwYXduaW5nIDUwIGFnZW50cyBzaW11bHRhbmVvdXNseS4uLicpO1xuICAgICAgICAgICAgY29uc3Qgc3Bhd25TdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBzcGF3blByb21pc2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogNTAgfSwgKF8sIGkpID0+XG4gICAgICAgICAgICAgICAgc3dhcm0uc3Bhd24oe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29kZXInLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBgYnVyc3QtYWdlbnQtJHtpfWBcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNjZW5hcmlvLm1ldHJpY3MuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGhhc2U6ICdzcGF3bicsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2VudDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29uc3Qgc3Bhd25lZEFnZW50cyA9IGF3YWl0IFByb21pc2UuYWxsKHNwYXduUHJvbWlzZXMpO1xuICAgICAgICAgICAgc2NlbmFyaW8uYWdlbnRzID0gc3Bhd25lZEFnZW50cy5maWx0ZXIoYWdlbnQgPT4gYWdlbnQgIT09IG51bGwpO1xuICAgICAgICAgICAgc2NlbmFyaW8ubWV0cmljcy5zcGF3blRpbWUgPSBEYXRlLm5vdygpIC0gc3Bhd25TdGFydFRpbWU7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICAgIFNwYXduZWQgJHtzY2VuYXJpby5hZ2VudHMubGVuZ3RofS81MCBhZ2VudHMgaW4gJHtzY2VuYXJpby5tZXRyaWNzLnNwYXduVGltZX1tc2ApO1xuXG4gICAgICAgICAgICAvLyBFeGVjdXRlIHRhc2tzIHNpbXVsdGFuZW91c2x5XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnICAgRXhlY3V0aW5nIHRhc2tzIHNpbXVsdGFuZW91c2x5Li4uJyk7XG4gICAgICAgICAgICBjb25zdCBleGVjU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGxldCBmaXJzdFJlc3BvbnNlUmVjZWl2ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgY29uc3QgdGFza1Byb21pc2VzID0gc2NlbmFyaW8uYWdlbnRzLm1hcCgoYWdlbnQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXNrU3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhZ2VudC5leGVjdXRlKHtcbiAgICAgICAgICAgICAgICAgICAgdGFzazogYEJ1cnN0IHRhc2sgJHtpfTogU29ydCBhcnJheSBvZiAxMDAwIHJhbmRvbSBudW1iZXJzYCxcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dDogMjAwMDBcbiAgICAgICAgICAgICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VUaW1lID0gRGF0ZS5ub3coKSAtIHRhc2tTdGFydDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaXJzdFJlc3BvbnNlUmVjZWl2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjZW5hcmlvLm1ldHJpY3MuZmlyc3RSZXNwb25zZVRpbWUgPSBEYXRlLm5vdygpIC0gZXhlY1N0YXJ0VGltZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzcG9uc2VSZWNlaXZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlVGltZTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNjZW5hcmlvLm1ldHJpY3MuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGhhc2U6ICdleGVjdXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWdlbnQ6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VUaW1lcyA9IGF3YWl0IFByb21pc2UuYWxsKHRhc2tQcm9taXNlcyk7XG4gICAgICAgICAgICBzY2VuYXJpby5tZXRyaWNzLmFsbFJlc3BvbnNlc1RpbWUgPSBEYXRlLm5vdygpIC0gZXhlY1N0YXJ0VGltZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgdmFsaWRSZXNwb25zZXMgPSByZXNwb25zZVRpbWVzLmZpbHRlcih0ID0+IHQgIT09IG51bGwpO1xuICAgICAgICAgICAgdGhpcy5tZXRyaWNzLnJlc3BvbnNlVGltZXMucHVzaCguLi52YWxpZFJlc3BvbnNlcyk7XG5cbiAgICAgICAgICAgIHNjZW5hcmlvLnBhc3NlZCA9IHNjZW5hcmlvLmFnZW50cy5sZW5ndGggPj0gNDUgJiYgc2NlbmFyaW8ubWV0cmljcy5lcnJvcnMubGVuZ3RoIDwgMTA7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICBGaXJzdCByZXNwb25zZTogJHtzY2VuYXJpby5tZXRyaWNzLmZpcnN0UmVzcG9uc2VUaW1lfW1zYCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgQWxsIHJlc3BvbnNlczogJHtzY2VuYXJpby5tZXRyaWNzLmFsbFJlc3BvbnNlc1RpbWV9bXNgKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICBBdmVyYWdlIHJlc3BvbnNlOiAke3ZhbGlkUmVzcG9uc2VzLmxlbmd0aCA+IDAgPyBNYXRoLnJvdW5kKHZhbGlkUmVzcG9uc2VzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gdmFsaWRSZXNwb25zZXMubGVuZ3RoKSA6ICdOL0EnfW1zYCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgRXJyb3JzOiAke3NjZW5hcmlvLm1ldHJpY3MuZXJyb3JzLmxlbmd0aH1gKTtcblxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgc2NlbmFyaW8uZXJyb3IgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYCAgIOKdjCBGYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjZW5hcmlvLmR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHNjZW5hcmlvLnN0YXJ0VGltZTtcbiAgICAgICAgdGhpcy50ZXN0UmVzdWx0cy5zY2VuYXJpb3MucHVzaChzY2VuYXJpbyk7XG4gICAgICAgIGNvbnNvbGUubG9nKCcnKTtcbiAgICB9XG5cbiAgICBhc3luYyBydW5TdXN0YWluZWRMb2FkVGVzdCgpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KPsCBTY2VuYXJpbyAzOiBTdXN0YWluZWQgTG9hZCBUZXN0ICg1MCBhZ2VudHMgZm9yIDUgbWludXRlcyknKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHNjZW5hcmlvID0ge1xuICAgICAgICAgICAgbmFtZTogJ1N1c3RhaW5lZCBMb2FkIFRlc3QnLFxuICAgICAgICAgICAgc3RhcnRUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgYWdlbnRzOiBbXSxcbiAgICAgICAgICAgIG1ldHJpY3M6IHtcbiAgICAgICAgICAgICAgICB0YXNrc0NvbXBsZXRlZDogMCxcbiAgICAgICAgICAgICAgICBhdmdUYXNrVGltZTogMCxcbiAgICAgICAgICAgICAgICBtZW1vcnlHcm93dGg6IDAsXG4gICAgICAgICAgICAgICAgZXJyb3JzOiBbXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhc3NlZDogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcnV2U3dhcm0gPSBhd2FpdCBSdXZTd2FybS5pbml0aWFsaXplKHtcbiAgICAgICAgICAgICAgICBlbmFibGVOZXVyYWxOZXR3b3JrczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbmFibGVGb3JlY2FzdGluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtZW1vcnlPcHRpbWl6YXRpb246IHRydWVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBzd2FybSA9IGF3YWl0IHJ1dlN3YXJtLmNyZWF0ZVN3YXJtKHtcbiAgICAgICAgICAgICAgICB0b3BvbG9neTogJ21lc2gnLFxuICAgICAgICAgICAgICAgIG1heEFnZW50czogNjAsXG4gICAgICAgICAgICAgICAgc3RyYXRlZ3k6ICdiYWxhbmNlZCdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBTcGF3biA1MCBhZ2VudHNcbiAgICAgICAgICAgIGNvbnN0IHNwYXduUHJvbWlzZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiA1MCB9LCAoXywgaSkgPT5cbiAgICAgICAgICAgICAgICBzd2FybS5zcGF3bih7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFsnY29kZXInLCAncmVzZWFyY2hlcicsICdhbmFseXN0J11baSAlIDNdLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBgc3VzdGFpbmVkLWFnZW50LSR7aX1gXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHNjZW5hcmlvLmFnZW50cyA9IGF3YWl0IFByb21pc2UuYWxsKHNwYXduUHJvbWlzZXMpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYCAgIFNwYXduZWQgJHtzY2VuYXJpby5hZ2VudHMubGVuZ3RofSBhZ2VudHNgKTtcblxuICAgICAgICAgICAgY29uc3QgaW5pdGlhbE1lbW9yeSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKS5oZWFwVXNlZDtcbiAgICAgICAgICAgIGNvbnN0IHRlc3REdXJhdGlvbiA9IDUgKiA2MCAqIDEwMDA7IC8vIDUgbWludXRlc1xuICAgICAgICAgICAgY29uc3QgZW5kVGltZSA9IERhdGUubm93KCkgKyB0ZXN0RHVyYXRpb247XG4gICAgICAgICAgICBjb25zdCB0YXNrVGltZXMgPSBbXTtcblxuICAgICAgICAgICAgbGV0IHRhc2tDb3VudGVyID0gMDtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coJyAgIFJ1bm5pbmcgc3VzdGFpbmVkIGxvYWQgZm9yIDUgbWludXRlcy4uLicpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB3aGlsZSAoRGF0ZS5ub3coKSA8IGVuZFRpbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXRjaFByb21pc2VzID0gc2NlbmFyaW8uYWdlbnRzLm1hcChhc3luYyAoYWdlbnQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFza1N0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGFnZW50LmV4ZWN1dGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2s6IGBTdXN0YWluZWQgdGFzayAke3Rhc2tDb3VudGVyfTogUHJvY2VzcyBkYXRhIGJhdGNoICR7dGFza0NvdW50ZXIgJSAxMDB9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiAxMDAwMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXNrVGltZSA9IERhdGUubm93KCkgLSB0YXNrU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrVGltZXMucHVzaCh0YXNrVGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2VuYXJpby5tZXRyaWNzLnRhc2tzQ29tcGxldGVkKys7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjZW5hcmlvLm1ldHJpY3MuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBoYXNlOiAnc3VzdGFpbmVkX2V4ZWN1dGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdlbnQ6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFzazogdGFza0NvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChiYXRjaFByb21pc2VzKTtcbiAgICAgICAgICAgICAgICB0YXNrQ291bnRlcisrO1xuXG4gICAgICAgICAgICAgICAgLy8gQnJpZWYgcGF1c2UgdG8gcHJldmVudCBvdmVyd2hlbG1pbmdcbiAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpO1xuXG4gICAgICAgICAgICAgICAgLy8gTG9nIHByb2dyZXNzIGV2ZXJ5IG1pbnV0ZVxuICAgICAgICAgICAgICAgIGlmICh0YXNrQ291bnRlciAlIDUwID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsYXBzZWQgPSBEYXRlLm5vdygpIC0gc2NlbmFyaW8uc3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW1haW5pbmcgPSBlbmRUaW1lIC0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYCAgICAgUHJvZ3Jlc3M6ICR7TWF0aC5yb3VuZChlbGFwc2VkIC8gMTAwMCl9cyBlbGFwc2VkLCAke01hdGgucm91bmQocmVtYWluaW5nIC8gMTAwMCl9cyByZW1haW5pbmdgKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYCAgICAgVGFza3MgY29tcGxldGVkOiAke3NjZW5hcmlvLm1ldHJpY3MudGFza3NDb21wbGV0ZWR9LCBFcnJvcnM6ICR7c2NlbmFyaW8ubWV0cmljcy5lcnJvcnMubGVuZ3RofWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZmluYWxNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWQ7XG4gICAgICAgICAgICBzY2VuYXJpby5tZXRyaWNzLm1lbW9yeUdyb3d0aCA9IGZpbmFsTWVtb3J5IC0gaW5pdGlhbE1lbW9yeTtcbiAgICAgICAgICAgIHNjZW5hcmlvLm1ldHJpY3MuYXZnVGFza1RpbWUgPSB0YXNrVGltZXMubGVuZ3RoID4gMCBcbiAgICAgICAgICAgICAgICA/IE1hdGgucm91bmQodGFza1RpbWVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gdGFza1RpbWVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICA6IDA7XG5cbiAgICAgICAgICAgIHNjZW5hcmlvLnBhc3NlZCA9IHNjZW5hcmlvLm1ldHJpY3MudGFza3NDb21wbGV0ZWQgPj0gMTAwMCAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NlbmFyaW8ubWV0cmljcy5lcnJvcnMubGVuZ3RoIDwgNTAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NlbmFyaW8ubWV0cmljcy5tZW1vcnlHcm93dGggPCAyMDAgKiAxMDI0ICogMTAyNDsgLy8gTGVzcyB0aGFuIDIwME1CIGdyb3d0aFxuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgVGFza3MgY29tcGxldGVkOiAke3NjZW5hcmlvLm1ldHJpY3MudGFza3NDb21wbGV0ZWR9YCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgQXZlcmFnZSB0YXNrIHRpbWU6ICR7c2NlbmFyaW8ubWV0cmljcy5hdmdUYXNrVGltZX1tc2ApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYCAgIE1lbW9yeSBncm93dGg6ICR7TWF0aC5yb3VuZChzY2VuYXJpby5tZXRyaWNzLm1lbW9yeUdyb3d0aCAvIDEwMjQgLyAxMDI0KX1NQmApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYCAgIEVycm9yIHJhdGU6ICR7KChzY2VuYXJpby5tZXRyaWNzLmVycm9ycy5sZW5ndGggLyBzY2VuYXJpby5tZXRyaWNzLnRhc2tzQ29tcGxldGVkKSAqIDEwMCkudG9GaXhlZCgyKX0lYCk7XG5cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHNjZW5hcmlvLmVycm9yID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICDinYwgRmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBzY2VuYXJpby5kdXJhdGlvbiA9IERhdGUubm93KCkgLSBzY2VuYXJpby5zdGFydFRpbWU7XG4gICAgICAgIHRoaXMudGVzdFJlc3VsdHMuc2NlbmFyaW9zLnB1c2goc2NlbmFyaW8pO1xuICAgICAgICBjb25zb2xlLmxvZygnJyk7XG4gICAgfVxuXG4gICAgYXN5bmMgcnVuTWl4ZWRXb3JrbG9hZFRlc3QoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn46tIFNjZW5hcmlvIDQ6IE1peGVkIFdvcmtsb2FkIFRlc3QgKGRpZmZlcmVudCBhZ2VudCB0eXBlcyknKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHNjZW5hcmlvID0ge1xuICAgICAgICAgICAgbmFtZTogJ01peGVkIFdvcmtsb2FkIFRlc3QnLFxuICAgICAgICAgICAgc3RhcnRUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgYWdlbnRzOiB7XG4gICAgICAgICAgICAgICAgY29kZXJzOiBbXSxcbiAgICAgICAgICAgICAgICByZXNlYXJjaGVyczogW10sXG4gICAgICAgICAgICAgICAgYW5hbHlzdHM6IFtdLFxuICAgICAgICAgICAgICAgIG9wdGltaXplcnM6IFtdLFxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdG9yczogW11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZXRyaWNzOiB7XG4gICAgICAgICAgICAgICAgdGFza3NCeVR5cGU6IHt9LFxuICAgICAgICAgICAgICAgIGF2Z1RpbWVzQnlUeXBlOiB7fSxcbiAgICAgICAgICAgICAgICBlcnJvcnM6IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFzc2VkOiBmYWxzZVxuICAgICAgICB9O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBydXZTd2FybSA9IGF3YWl0IFJ1dlN3YXJtLmluaXRpYWxpemUoe1xuICAgICAgICAgICAgICAgIGVuYWJsZU5ldXJhbE5ldHdvcmtzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVuYWJsZUZvcmVjYXN0aW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIGxvYWRpbmdTdHJhdGVneTogJ3Byb2dyZXNzaXZlJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHN3YXJtID0gYXdhaXQgcnV2U3dhcm0uY3JlYXRlU3dhcm0oe1xuICAgICAgICAgICAgICAgIHRvcG9sb2d5OiAnaGllcmFyY2hpY2FsJyxcbiAgICAgICAgICAgICAgICBtYXhBZ2VudHM6IDYwLFxuICAgICAgICAgICAgICAgIHN0cmF0ZWd5OiAnc3BlY2lhbGl6ZWQnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gU3Bhd24gZGlmZmVyZW50IHR5cGVzIG9mIGFnZW50c1xuICAgICAgICAgICAgY29uc3QgYWdlbnRUeXBlcyA9IFtcbiAgICAgICAgICAgICAgICB7IHR5cGU6ICdjb2RlcicsIGNvdW50OiAxNSB9LFxuICAgICAgICAgICAgICAgIHsgdHlwZTogJ3Jlc2VhcmNoZXInLCBjb3VudDogMTIgfSxcbiAgICAgICAgICAgICAgICB7IHR5cGU6ICdhbmFseXN0JywgY291bnQ6IDEwIH0sXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAnb3B0aW1pemVyJywgY291bnQ6IDggfSxcbiAgICAgICAgICAgICAgICB7IHR5cGU6ICdjb29yZGluYXRvcicsIGNvdW50OiA1IH1cbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCcgICBTcGF3bmluZyBtaXhlZCBhZ2VudCB0eXBlcy4uLicpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IHR5cGUsIGNvdW50IH0gb2YgYWdlbnRUeXBlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVQcm9taXNlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IGNvdW50IH0sIChfLCBpKSA9PlxuICAgICAgICAgICAgICAgICAgICBzd2FybS5zcGF3bih7IHR5cGUsIG5hbWU6IGAke3R5cGV9LSR7aX1gIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlQWdlbnRzID0gYXdhaXQgUHJvbWlzZS5hbGwodHlwZVByb21pc2VzKTtcbiAgICAgICAgICAgICAgICBzY2VuYXJpby5hZ2VudHNbdHlwZSArICdzJ10gPSB0eXBlQWdlbnRzO1xuICAgICAgICAgICAgICAgIHNjZW5hcmlvLm1ldHJpY3MudGFza3NCeVR5cGVbdHlwZV0gPSAwO1xuICAgICAgICAgICAgICAgIHNjZW5hcmlvLm1ldHJpY3MuYXZnVGltZXNCeVR5cGVbdHlwZV0gPSBbXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgICAke3R5cGV9OiAke3R5cGVBZ2VudHMubGVuZ3RofSBhZ2VudHNgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRXhlY3V0ZSB0eXBlLXNwZWNpZmljIHRhc2tzXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnICAgRXhlY3V0aW5nIHR5cGUtc3BlY2lmaWMgd29ya2xvYWRzLi4uJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHdvcmtsb2FkUHJvbWlzZXMgPSBPYmplY3QuZW50cmllcyhzY2VuYXJpby5hZ2VudHMpLm1hcChhc3luYyAoW2FnZW50VHlwZSwgYWdlbnRzXSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBhZ2VudFR5cGUuc2xpY2UoMCwgLTEpOyAvLyBSZW1vdmUgJ3MnIHN1ZmZpeFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChhZ2VudHMubWFwKGFzeW5jIChhZ2VudCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXNrcyA9IHRoaXMuZ2V0VGFza3NGb3JUeXBlKHR5cGUsIGkpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB0YXNrIG9mIHRhc2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXNrU3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBhZ2VudC5leGVjdXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFzazogdGFzay5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dDogdGFzay50aW1lb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFza1RpbWUgPSBEYXRlLm5vdygpIC0gdGFza1N0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjZW5hcmlvLm1ldHJpY3MuYXZnVGltZXNCeVR5cGVbdHlwZV0ucHVzaCh0YXNrVGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NlbmFyaW8ubWV0cmljcy50YXNrc0J5VHlwZVt0eXBlXSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2VuYXJpby5tZXRyaWNzLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGhhc2U6ICdtaXhlZF93b3JrbG9hZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFnZW50VHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdlbnQ6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2s6IHRhc2suZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwod29ya2xvYWRQcm9taXNlcyk7XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBhdmVyYWdlc1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoc2NlbmFyaW8ubWV0cmljcy5hdmdUaW1lc0J5VHlwZSkuZm9yRWFjaCgoW3R5cGUsIHRpbWVzXSkgPT4ge1xuICAgICAgICAgICAgICAgIHNjZW5hcmlvLm1ldHJpY3MuYXZnVGltZXNCeVR5cGVbdHlwZV0gPSB0aW1lcy5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgICAgID8gTWF0aC5yb3VuZCh0aW1lcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIHRpbWVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHRvdGFsQWdlbnRzID0gT2JqZWN0LnZhbHVlcyhzY2VuYXJpby5hZ2VudHMpLmZsYXQoKS5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCB0b3RhbFRhc2tzID0gT2JqZWN0LnZhbHVlcyhzY2VuYXJpby5tZXRyaWNzLnRhc2tzQnlUeXBlKS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc2NlbmFyaW8ucGFzc2VkID0gdG90YWxBZ2VudHMgPj0gNTAgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsVGFza3MgPj0gMTUwICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2VuYXJpby5tZXRyaWNzLmVycm9ycy5sZW5ndGggPCAxNTtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coYCAgIFRvdGFsIGFnZW50czogJHt0b3RhbEFnZW50c31gKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICBUb3RhbCB0YXNrczogJHt0b3RhbFRhc2tzfWApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYCAgIFRhc2tzIGJ5IHR5cGU6YCwgc2NlbmFyaW8ubWV0cmljcy50YXNrc0J5VHlwZSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgQXZnIHRpbWVzIGJ5IHR5cGU6YCwgc2NlbmFyaW8ubWV0cmljcy5hdmdUaW1lc0J5VHlwZSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgRXJyb3JzOiAke3NjZW5hcmlvLm1ldHJpY3MuZXJyb3JzLmxlbmd0aH1gKTtcblxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgc2NlbmFyaW8uZXJyb3IgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYCAgIOKdjCBGYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjZW5hcmlvLmR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHNjZW5hcmlvLnN0YXJ0VGltZTtcbiAgICAgICAgdGhpcy50ZXN0UmVzdWx0cy5zY2VuYXJpb3MucHVzaChzY2VuYXJpbyk7XG4gICAgICAgIGNvbnNvbGUubG9nKCcnKTtcbiAgICB9XG5cbiAgICBhc3luYyBydW5TdHJlc3NUZXN0KCkge1xuICAgICAgICBjb25zb2xlLmxvZygn8J+UpSBTY2VuYXJpbyA1OiBTdHJlc3MgVGVzdCAocHVzaGluZyB0byBmYWlsdXJlIHBvaW50KScpO1xuICAgICAgICBcbiAgICAgICAgY29uc3Qgc2NlbmFyaW8gPSB7XG4gICAgICAgICAgICBuYW1lOiAnU3RyZXNzIFRlc3QnLFxuICAgICAgICAgICAgc3RhcnRUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgbWF4QWdlbnRzUmVhY2hlZDogMCxcbiAgICAgICAgICAgIGZhaWx1cmVQb2ludDogbnVsbCxcbiAgICAgICAgICAgIG1ldHJpY3M6IHtcbiAgICAgICAgICAgICAgICBtZW1vcnlBdEZhaWx1cmU6IDAsXG4gICAgICAgICAgICAgICAgYWdlbnRTcGF3bkZhaWx1cmVzOiAwLFxuICAgICAgICAgICAgICAgIHRhc2tFeGVjdXRpb25GYWlsdXJlczogMCxcbiAgICAgICAgICAgICAgICBzeXN0ZW1FcnJvcnM6IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFzc2VkOiBmYWxzZVxuICAgICAgICB9O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBydXZTd2FybSA9IGF3YWl0IFJ1dlN3YXJtLmluaXRpYWxpemUoe1xuICAgICAgICAgICAgICAgIGVuYWJsZU5ldXJhbE5ldHdvcmtzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVuYWJsZUZvcmVjYXN0aW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBsb2FkaW5nU3RyYXRlZ3k6ICdpbW1lZGlhdGUnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3Qgc3dhcm0gPSBhd2FpdCBydXZTd2FybS5jcmVhdGVTd2FybSh7XG4gICAgICAgICAgICAgICAgdG9wb2xvZ3k6ICdtZXNoJyxcbiAgICAgICAgICAgICAgICBtYXhBZ2VudHM6IDIwMCwgLy8gSGlnaCBsaW1pdCBmb3Igc3RyZXNzIHRlc3RpbmdcbiAgICAgICAgICAgICAgICBzdHJhdGVneTogJ3BhcmFsbGVsJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCcgICBQcm9ncmVzc2l2ZWx5IGluY3JlYXNpbmcgbG9hZCB1bnRpbCBmYWlsdXJlLi4uJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxldCBjdXJyZW50QWdlbnRzID0gW107XG4gICAgICAgICAgICBsZXQgYmF0Y2hTaXplID0gMTA7XG4gICAgICAgICAgICBsZXQgbWF4QmF0Y2hTaXplID0gNTA7XG5cbiAgICAgICAgICAgIGZvciAobGV0IHRhcmdldENvdW50ID0gMTA7IHRhcmdldENvdW50IDw9IDE1MDsgdGFyZ2V0Q291bnQgKz0gYmF0Y2hTaXplKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYCAgIEF0dGVtcHRpbmcgdG8gcmVhY2ggJHt0YXJnZXRDb3VudH0gYWdlbnRzLi4uYCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3Bhd24gYWRkaXRpb25hbCBhZ2VudHNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3QWdlbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwYXduUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBjdXJyZW50QWdlbnRzLmxlbmd0aDsgaSA8IHRhcmdldENvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYXduUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2FybS5zcGF3bih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb2RlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGBzdHJlc3MtYWdlbnQtJHtpfWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGFnZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3QWdlbnRzLnB1c2goYWdlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWdlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2VuYXJpby5tZXRyaWNzLmFnZW50U3Bhd25GYWlsdXJlcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2VuYXJpby5tZXRyaWNzLnN5c3RlbUVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBoYXNlOiAnc3Bhd24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdlbnQ6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzcGF3bmVkQmF0Y2ggPSBhd2FpdCBQcm9taXNlLmFsbChzcGF3blByb21pc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEFnZW50cy5wdXNoKC4uLnNwYXduZWRCYXRjaC5maWx0ZXIoYWdlbnQgPT4gYWdlbnQgIT09IG51bGwpKTtcbiAgICAgICAgICAgICAgICAgICAgc2NlbmFyaW8ubWF4QWdlbnRzUmVhY2hlZCA9IGN1cnJlbnRBZ2VudHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICAgIFN1Y2Nlc3NmdWxseSBzcGF3bmVkICR7Y3VycmVudEFnZW50cy5sZW5ndGh9IGFnZW50c2ApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRlc3QgZXhlY3V0aW9uIHdpdGggY3VycmVudCBhZ2VudCBjb3VudFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXNrUHJvbWlzZXMgPSBjdXJyZW50QWdlbnRzLm1hcCgoYWdlbnQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYWdlbnQpIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFnZW50LmV4ZWN1dGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2s6IGBTdHJlc3MgdGVzdCB0YXNrICR7aX06IEhlYXZ5IGNvbXB1dGF0aW9uYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiAxMDAwMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjZW5hcmlvLm1ldHJpY3MudGFza0V4ZWN1dGlvbkZhaWx1cmVzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NlbmFyaW8ubWV0cmljcy5zeXN0ZW1FcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBoYXNlOiAnZXhlY3V0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdlbnQ6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKHRhc2tQcm9taXNlcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgbWVtb3J5IHVzYWdlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lbVVzYWdlID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZW1vcnlNQiA9IG1lbVVzYWdlLmhlYXBVc2VkIC8gMTAyNCAvIDEwMjQ7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgICBNZW1vcnkgdXNhZ2U6ICR7bWVtb3J5TUIudG9GaXhlZCgxKX1NQmApO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgICBTcGF3biBmYWlsdXJlczogJHtzY2VuYXJpby5tZXRyaWNzLmFnZW50U3Bhd25GYWlsdXJlc31gKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYCAgICAgRXhlY3V0aW9uIGZhaWx1cmVzOiAke3NjZW5hcmlvLm1ldHJpY3MudGFza0V4ZWN1dGlvbkZhaWx1cmVzfWApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFwcHJvYWNoaW5nIGxpbWl0c1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVtb3J5TUIgPiAxMDAwIHx8IHNjZW5hcmlvLm1ldHJpY3MuYWdlbnRTcGF3bkZhaWx1cmVzID4gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjZW5hcmlvLmZhaWx1cmVQb2ludCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZ2VudENvdW50OiBjdXJyZW50QWdlbnRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW1vcnk6IG1lbW9yeU1CLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogbWVtb3J5TUIgPiAxMDAwID8gJ21lbW9yeV9saW1pdCcgOiAnc3Bhd25fZmFpbHVyZXMnXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYCAgIEZhaWx1cmUgcG9pbnQgcmVhY2hlZDogJHtzY2VuYXJpby5mYWlsdXJlUG9pbnQucmVhc29ufWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBJbmNyZWFzZSBiYXRjaCBzaXplIGZvciBlZmZpY2llbmN5LCBidXQgY2FwIGl0XG4gICAgICAgICAgICAgICAgICAgIGJhdGNoU2l6ZSA9IE1hdGgubWluKGJhdGNoU2l6ZSArIDUsIG1heEJhdGNoU2l6ZSk7XG5cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBzY2VuYXJpby5mYWlsdXJlUG9pbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2VudENvdW50OiBjdXJyZW50QWdlbnRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbW9yeTogcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkIC8gMTAyNCAvIDEwMjQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzb246ICdzeXN0ZW1fZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYCAgIFN5c3RlbSBlcnJvciBhdCAke2N1cnJlbnRBZ2VudHMubGVuZ3RofSBhZ2VudHM6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQnJpZWYgcGF1c2UgYmV0d2VlbiBzdHJlc3MgaW5jcmVtZW50c1xuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDAwKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNjZW5hcmlvLm1ldHJpY3MubWVtb3J5QXRGYWlsdXJlID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkIC8gMTAyNCAvIDEwMjQ7XG4gICAgICAgICAgICBzY2VuYXJpby5wYXNzZWQgPSBzY2VuYXJpby5tYXhBZ2VudHNSZWFjaGVkID49IDgwOyAvLyBNaW5pbXVtIHRocmVzaG9sZCBmb3Igc3RyZXNzIHRlc3RcblxuICAgICAgICAgICAgY29uc29sZS5sb2coYCAgIE1heGltdW0gYWdlbnRzIHJlYWNoZWQ6ICR7c2NlbmFyaW8ubWF4QWdlbnRzUmVhY2hlZH1gKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICBGYWlsdXJlIHBvaW50OmAsIHNjZW5hcmlvLmZhaWx1cmVQb2ludCB8fCAnTm8gZmFpbHVyZSByZWFjaGVkJyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgTWVtb3J5IGF0IGVuZDogJHtzY2VuYXJpby5tZXRyaWNzLm1lbW9yeUF0RmFpbHVyZS50b0ZpeGVkKDEpfU1CYCk7XG5cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHNjZW5hcmlvLmVycm9yID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICDinYwgRmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBzY2VuYXJpby5kdXJhdGlvbiA9IERhdGUubm93KCkgLSBzY2VuYXJpby5zdGFydFRpbWU7XG4gICAgICAgIHRoaXMudGVzdFJlc3VsdHMuc2NlbmFyaW9zLnB1c2goc2NlbmFyaW8pO1xuICAgICAgICBjb25zb2xlLmxvZygnJyk7XG4gICAgfVxuXG4gICAgZ2V0VGFza3NGb3JUeXBlKHR5cGUsIGFnZW50SW5kZXgpIHtcbiAgICAgICAgY29uc3QgdGFza1NldHMgPSB7XG4gICAgICAgICAgICBjb2RlcjogW1xuICAgICAgICAgICAgICAgIHsgZGVzY3JpcHRpb246IGBDb2RlIHJldmlldyB0YXNrICR7YWdlbnRJbmRleH06IEFuYWx5emUgZnVuY3Rpb24gY29tcGxleGl0eWAsIHRpbWVvdXQ6IDgwMDAgfSxcbiAgICAgICAgICAgICAgICB7IGRlc2NyaXB0aW9uOiBgSW1wbGVtZW50YXRpb24gdGFzayAke2FnZW50SW5kZXh9OiBXcml0ZSBzb3J0aW5nIGFsZ29yaXRobWAsIHRpbWVvdXQ6IDEyMDAwIH0sXG4gICAgICAgICAgICAgICAgeyBkZXNjcmlwdGlvbjogYERlYnVnIHRhc2sgJHthZ2VudEluZGV4fTogRmluZCBtZW1vcnkgbGVha2AsIHRpbWVvdXQ6IDEwMDAwIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICByZXNlYXJjaGVyOiBbXG4gICAgICAgICAgICAgICAgeyBkZXNjcmlwdGlvbjogYFJlc2VhcmNoIHRhc2sgJHthZ2VudEluZGV4fTogTGl0ZXJhdHVyZSByZXZpZXcgb24gQUlgLCB0aW1lb3V0OiAxNTAwMCB9LFxuICAgICAgICAgICAgICAgIHsgZGVzY3JpcHRpb246IGBBbmFseXNpcyB0YXNrICR7YWdlbnRJbmRleH06IFRyZW5kIGFuYWx5c2lzYCwgdGltZW91dDogMTIwMDAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGFuYWx5c3Q6IFtcbiAgICAgICAgICAgICAgICB7IGRlc2NyaXB0aW9uOiBgRGF0YSBhbmFseXNpcyAke2FnZW50SW5kZXh9OiBQcm9jZXNzIGRhdGFzZXRgLCB0aW1lb3V0OiAxMDAwMCB9LFxuICAgICAgICAgICAgICAgIHsgZGVzY3JpcHRpb246IGBTdGF0aXN0aWNhbCBhbmFseXNpcyAke2FnZW50SW5kZXh9OiBDb3JyZWxhdGlvbiBzdHVkeWAsIHRpbWVvdXQ6IDgwMDAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIG9wdGltaXplcjogW1xuICAgICAgICAgICAgICAgIHsgZGVzY3JpcHRpb246IGBPcHRpbWl6YXRpb24gdGFzayAke2FnZW50SW5kZXh9OiBBbGdvcml0aG0gdHVuaW5nYCwgdGltZW91dDogMTUwMDAgfSxcbiAgICAgICAgICAgICAgICB7IGRlc2NyaXB0aW9uOiBgUGVyZm9ybWFuY2UgdGFzayAke2FnZW50SW5kZXh9OiBCb3R0bGVuZWNrIGFuYWx5c2lzYCwgdGltZW91dDogMTIwMDAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGNvb3JkaW5hdG9yOiBbXG4gICAgICAgICAgICAgICAgeyBkZXNjcmlwdGlvbjogYENvb3JkaW5hdGlvbiB0YXNrICR7YWdlbnRJbmRleH06IFRhc2sgc2NoZWR1bGluZ2AsIHRpbWVvdXQ6IDYwMDAgfSxcbiAgICAgICAgICAgICAgICB7IGRlc2NyaXB0aW9uOiBgTWFuYWdlbWVudCB0YXNrICR7YWdlbnRJbmRleH06IFJlc291cmNlIGFsbG9jYXRpb25gLCB0aW1lb3V0OiA4MDAwIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGFza1NldHNbdHlwZV0gfHwgW3sgZGVzY3JpcHRpb246IGBHZW5lcmljIHRhc2sgJHthZ2VudEluZGV4fWAsIHRpbWVvdXQ6IDgwMDAgfV07XG4gICAgfVxuXG4gICAgYXN5bmMgZ2VuZXJhdGVMb2FkVGVzdFJlcG9ydCgpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfk4QgR2VuZXJhdGluZyBMb2FkIFRlc3QgUmVwb3J0Li4uJyk7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIG92ZXJhbGwgbWV0cmljc1xuICAgICAgICBjb25zdCBwYXNzZWRTY2VuYXJpb3MgPSB0aGlzLnRlc3RSZXN1bHRzLnNjZW5hcmlvcy5maWx0ZXIocyA9PiBzLnBhc3NlZCkubGVuZ3RoO1xuICAgICAgICBjb25zdCB0b3RhbFNjZW5hcmlvcyA9IHRoaXMudGVzdFJlc3VsdHMuc2NlbmFyaW9zLmxlbmd0aDtcbiAgICAgICAgXG4gICAgICAgIHRoaXMudGVzdFJlc3VsdHMucGVyZm9ybWFuY2UuYXZnUmVzcG9uc2VUaW1lID0gdGhpcy5tZXRyaWNzLnJlc3BvbnNlVGltZXMubGVuZ3RoID4gMFxuICAgICAgICAgICAgPyBNYXRoLnJvdW5kKHRoaXMubWV0cmljcy5yZXNwb25zZVRpbWVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gdGhpcy5tZXRyaWNzLnJlc3BvbnNlVGltZXMubGVuZ3RoKVxuICAgICAgICAgICAgOiAwO1xuXG4gICAgICAgIHRoaXMudGVzdFJlc3VsdHMucGVyZm9ybWFuY2UuZXJyb3JSYXRlID0gdGhpcy5tZXRyaWNzLmVycm9ycy5sZW5ndGggPiAwXG4gICAgICAgICAgICA/ICgodGhpcy5tZXRyaWNzLmVycm9ycy5sZW5ndGggLyAodGhpcy5tZXRyaWNzLnJlc3BvbnNlVGltZXMubGVuZ3RoICsgdGhpcy5tZXRyaWNzLmVycm9ycy5sZW5ndGgpKSAqIDEwMCkudG9GaXhlZCgyKVxuICAgICAgICAgICAgOiAwO1xuXG4gICAgICAgIHRoaXMudGVzdFJlc3VsdHMucGVyZm9ybWFuY2UubWVtb3J5UGVhayA9IHRoaXMudGVzdFJlc3VsdHMucGVyZm9ybWFuY2UubWVtb3J5UGVhayAvIDEwMjQgLyAxMDI0OyAvLyBDb252ZXJ0IHRvIE1CXG5cbiAgICAgICAgdGhpcy50ZXN0UmVzdWx0cy5wYXNzZWQgPSBwYXNzZWRTY2VuYXJpb3MgPj0gNDsgLy8gQXQgbGVhc3QgNC81IHNjZW5hcmlvcyBtdXN0IHBhc3NcblxuICAgICAgICBjb25zdCByZXBvcnQgPSB7XG4gICAgICAgICAgICAuLi50aGlzLnRlc3RSZXN1bHRzLFxuICAgICAgICAgICAgc3VtbWFyeToge1xuICAgICAgICAgICAgICAgIHRvdGFsU2NlbmFyaW9zLFxuICAgICAgICAgICAgICAgIHBhc3NlZFNjZW5hcmlvcyxcbiAgICAgICAgICAgICAgICBmYWlsZWRTY2VuYXJpb3M6IHRvdGFsU2NlbmFyaW9zIC0gcGFzc2VkU2NlbmFyaW9zLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3NSYXRlOiAoKHBhc3NlZFNjZW5hcmlvcyAvIHRvdGFsU2NlbmFyaW9zKSAqIDEwMCkudG9GaXhlZCgxKSArICclJyxcbiAgICAgICAgICAgICAgICBvdmVyYWxsUGFzc2VkOiB0aGlzLnRlc3RSZXN1bHRzLnBhc3NlZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNhdmUgZGV0YWlsZWQgcmVwb3J0XG4gICAgICAgIGNvbnN0IHJlcG9ydFBhdGggPSAnL3dvcmtzcGFjZXMvcnV2LUZBTk4vcnV2LXN3YXJtL25wbS90ZXN0L2xvYWQtdGVzdC1yZXBvcnQuanNvbic7XG4gICAgICAgIGF3YWl0IGZzLndyaXRlRmlsZShyZXBvcnRQYXRoLCBKU09OLnN0cmluZ2lmeShyZXBvcnQsIG51bGwsIDIpKTtcblxuICAgICAgICAvLyBDb25zb2xlIHN1bW1hcnlcbiAgICAgICAgY29uc29sZS5sb2coJ1xcbvCfjq8gTE9BRCBURVNUIFNVTU1BUlknKTtcbiAgICAgICAgY29uc29sZS5sb2coJz09PT09PT09PT09PT09PT09PT09Jyk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBTY2VuYXJpb3MgUGFzc2VkOiAke3Bhc3NlZFNjZW5hcmlvc30vJHt0b3RhbFNjZW5hcmlvc30gKCR7cmVwb3J0LnN1bW1hcnkuc3VjY2Vzc1JhdGV9KWApO1xuICAgICAgICBjb25zb2xlLmxvZyhgTWF4IENvbmN1cnJlbnQgQWdlbnRzOiAke3RoaXMudGVzdFJlc3VsdHMucGVyZm9ybWFuY2UubWF4Q29uY3VycmVudEFnZW50c31gKTtcbiAgICAgICAgY29uc29sZS5sb2coYEF2ZXJhZ2UgUmVzcG9uc2UgVGltZTogJHt0aGlzLnRlc3RSZXN1bHRzLnBlcmZvcm1hbmNlLmF2Z1Jlc3BvbnNlVGltZX1tc2ApO1xuICAgICAgICBjb25zb2xlLmxvZyhgRXJyb3IgUmF0ZTogJHt0aGlzLnRlc3RSZXN1bHRzLnBlcmZvcm1hbmNlLmVycm9yUmF0ZX0lYCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBQZWFrIE1lbW9yeSBVc2FnZTogJHt0aGlzLnRlc3RSZXN1bHRzLnBlcmZvcm1hbmNlLm1lbW9yeVBlYWsudG9GaXhlZCgxKX1NQmApO1xuICAgICAgICBjb25zb2xlLmxvZyhgT3ZlcmFsbCBTdGF0dXM6ICR7dGhpcy50ZXN0UmVzdWx0cy5wYXNzZWQgPyAn4pyFIFBBU1NFRCcgOiAn4p2MIEZBSUxFRCd9YCk7XG5cbiAgICAgICAgY29uc29sZS5sb2coJ1xcbvCfk4sgU2NlbmFyaW8gUmVzdWx0czonKTtcbiAgICAgICAgdGhpcy50ZXN0UmVzdWx0cy5zY2VuYXJpb3MuZm9yRWFjaChzY2VuYXJpbyA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgJHtzY2VuYXJpby5wYXNzZWQgPyAn4pyFJyA6ICfinYwnfSAke3NjZW5hcmlvLm5hbWV9ICgke3NjZW5hcmlvLmR1cmF0aW9ufW1zKWApO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zb2xlLmxvZyhgXFxu8J+ThCBEZXRhaWxlZCByZXBvcnQgc2F2ZWQgdG86ICR7cmVwb3J0UGF0aH1gKTtcblxuICAgICAgICByZXR1cm4gcmVwb3J0O1xuICAgIH1cbn1cblxuLy8gTWFpbiBleGVjdXRpb25cbmFzeW5jIGZ1bmN0aW9uIHJ1bkxvYWRUZXN0cygpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBsb2FkVGVzdGVyID0gbmV3IExvYWRUZXN0aW5nU3VpdGUoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGxvYWRUZXN0ZXIucnVuTG9hZFRlc3RzKCk7XG4gICAgICAgIFxuICAgICAgICBwcm9jZXNzLmV4aXQocmVzdWx0cy5wYXNzZWQgPyAwIDogMSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcign8J+SpSBMb2FkIHRlc3RpbmcgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgIH1cbn1cblxuaWYgKHJlcXVpcmUubWFpbiA9PT0gbW9kdWxlKSB7XG4gICAgcnVuTG9hZFRlc3RzKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBMb2FkVGVzdGluZ1N1aXRlIH07Il0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtFQUFFQTtBQUFTLENBQUMsR0FBR0MsT0FBTyxDQUFDLHVCQUF1QixDQUFDO0FBQ3JELE1BQU07RUFBRUM7QUFBYSxDQUFDLEdBQUdELE9BQU8sQ0FBQyxRQUFRLENBQUM7QUFDMUMsTUFBTUUsRUFBRSxHQUFHRixPQUFPLENBQUMsSUFBSSxDQUFDLENBQUNHLFFBQVE7QUFDakMsTUFBTUMsRUFBRSxHQUFHSixPQUFPLENBQUMsSUFBSSxDQUFDO0FBRXhCLE1BQU1LLGdCQUFnQixTQUFTSixZQUFZLENBQUM7RUFDeENLLFdBQVdBLENBQUEsRUFBRztJQUNWLEtBQUssQ0FBQyxDQUFDO0lBQ1AsSUFBSSxDQUFDQyxXQUFXLEdBQUc7TUFDZkMsU0FBUyxFQUFFLElBQUlDLElBQUksQ0FBQyxDQUFDLENBQUNDLFdBQVcsQ0FBQyxDQUFDO01BQ25DQyxVQUFVLEVBQUU7UUFDUkMsUUFBUSxFQUFFQyxPQUFPLENBQUNELFFBQVE7UUFDMUJFLElBQUksRUFBRUQsT0FBTyxDQUFDQyxJQUFJO1FBQ2xCQyxXQUFXLEVBQUVGLE9BQU8sQ0FBQ0csT0FBTztRQUM1QkMsSUFBSSxFQUFFYixFQUFFLENBQUNhLElBQUksQ0FBQyxDQUFDLENBQUNDLE1BQU07UUFDdEJDLFdBQVcsRUFBRWYsRUFBRSxDQUFDZ0IsUUFBUSxDQUFDLENBQUM7UUFDMUJDLFVBQVUsRUFBRWpCLEVBQUUsQ0FBQ2tCLE9BQU8sQ0FBQztNQUMzQixDQUFDO01BQ0RDLFNBQVMsRUFBRSxFQUFFO01BQ2JDLFdBQVcsRUFBRTtRQUNUQyxtQkFBbUIsRUFBRSxDQUFDO1FBQ3RCQyxlQUFlLEVBQUUsQ0FBQztRQUNsQkMsVUFBVSxFQUFFLENBQUM7UUFDYkMsU0FBUyxFQUFFLENBQUM7UUFDWkMsVUFBVSxFQUFFLENBQUM7UUFDYkMsT0FBTyxFQUFFO01BQ2IsQ0FBQztNQUNEQyxNQUFNLEVBQUU7SUFDWixDQUFDO0lBQ0QsSUFBSSxDQUFDQyxPQUFPLEdBQUc7TUFDWEMsYUFBYSxFQUFFLEVBQUU7TUFDakJDLGVBQWUsRUFBRSxFQUFFO01BQ25CQyxNQUFNLEVBQUUsRUFBRTtNQUNWQyxjQUFjLEVBQUU7SUFDcEIsQ0FBQztJQUNELElBQUksQ0FBQ0Msa0JBQWtCLEdBQUcsSUFBSTtFQUNsQztFQUVNQyxZQUFZQSxDQUFBLEVBQUc7SUFBQSxJQUFBQyxLQUFBO0lBQUEsT0FBQUMsaUJBQUE7TUFDakJDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLGdDQUFnQyxDQUFDO01BQzdDRCxPQUFPLENBQUNDLEdBQUcsQ0FBQyxrQ0FBa0MsQ0FBQztNQUUvQ0gsS0FBSSxDQUFDSSxhQUFhLENBQUMsQ0FBQztNQUNwQkosS0FBSSxDQUFDSyxxQkFBcUIsQ0FBQyxDQUFDO01BRTVCLElBQUk7UUFDQTtRQUNBLE1BQU1MLEtBQUksQ0FBQ00sa0JBQWtCLENBQUMsQ0FBQzs7UUFFL0I7UUFDQSxNQUFNTixLQUFJLENBQUNPLGdCQUFnQixDQUFDLENBQUM7O1FBRTdCO1FBQ0EsTUFBTVAsS0FBSSxDQUFDUSxvQkFBb0IsQ0FBQyxDQUFDOztRQUVqQztRQUNBLE1BQU1SLEtBQUksQ0FBQ1Msb0JBQW9CLENBQUMsQ0FBQzs7UUFFakM7UUFDQSxNQUFNVCxLQUFJLENBQUNVLGFBQWEsQ0FBQyxDQUFDOztRQUUxQjtRQUNBLE1BQU1WLEtBQUksQ0FBQ1csc0JBQXNCLENBQUMsQ0FBQztNQUV2QyxDQUFDLENBQUMsT0FBT0MsS0FBSyxFQUFFO1FBQ1pWLE9BQU8sQ0FBQ1UsS0FBSyxDQUFDLHdCQUF3QixFQUFFQSxLQUFLLENBQUM7UUFDOUMsTUFBTUEsS0FBSztNQUNmLENBQUMsU0FBUztRQUNOWixLQUFJLENBQUNhLG9CQUFvQixDQUFDLENBQUM7TUFDL0I7TUFFQSxPQUFPYixLQUFJLENBQUNoQyxXQUFXO0lBQUM7RUFDNUI7RUFFQW9DLGFBQWFBLENBQUEsRUFBRztJQUNaRixPQUFPLENBQUNDLEdBQUcsQ0FBQyx3QkFBd0IsQ0FBQztJQUNyQ0QsT0FBTyxDQUFDQyxHQUFHLENBQUMsZ0JBQWdCLElBQUksQ0FBQ25DLFdBQVcsQ0FBQ0ksVUFBVSxDQUFDQyxRQUFRLElBQUksSUFBSSxDQUFDTCxXQUFXLENBQUNJLFVBQVUsQ0FBQ0csSUFBSSxFQUFFLENBQUM7SUFDdkcyQixPQUFPLENBQUNDLEdBQUcsQ0FBQyxlQUFlLElBQUksQ0FBQ25DLFdBQVcsQ0FBQ0ksVUFBVSxDQUFDSSxXQUFXLEVBQUUsQ0FBQztJQUNyRTBCLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLFlBQVksSUFBSSxDQUFDbkMsV0FBVyxDQUFDSSxVQUFVLENBQUNNLElBQUksRUFBRSxDQUFDO0lBQzNEd0IsT0FBTyxDQUFDQyxHQUFHLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQ25DLFdBQVcsQ0FBQ0ksVUFBVSxDQUFDUSxXQUFXLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEVBQUVrQyxPQUFPLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQztJQUM5R1osT0FBTyxDQUFDQyxHQUFHLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQ25DLFdBQVcsQ0FBQ0ksVUFBVSxDQUFDVSxVQUFVLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEVBQUVnQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztFQUMzRztFQUVBVCxxQkFBcUJBLENBQUEsRUFBRztJQUNwQixJQUFJLENBQUNQLGtCQUFrQixHQUFHaUIsV0FBVyxDQUFDLE1BQU07TUFDeEMsTUFBTUMsUUFBUSxHQUFHMUMsT0FBTyxDQUFDMkMsV0FBVyxDQUFDLENBQUM7TUFDdEMsTUFBTUMsUUFBUSxHQUFHNUMsT0FBTyxDQUFDNEMsUUFBUSxDQUFDLENBQUM7TUFFbkMsSUFBSSxDQUFDekIsT0FBTyxDQUFDRSxlQUFlLENBQUN3QixJQUFJLENBQUM7UUFDOUJsRCxTQUFTLEVBQUVDLElBQUksQ0FBQ2tELEdBQUcsQ0FBQyxDQUFDO1FBQ3JCQyxRQUFRLEVBQUVMLFFBQVEsQ0FBQ0ssUUFBUTtRQUMzQkMsU0FBUyxFQUFFTixRQUFRLENBQUNNLFNBQVM7UUFDN0JDLFFBQVEsRUFBRVAsUUFBUSxDQUFDTztNQUN2QixDQUFDLENBQUM7O01BRUY7TUFDQSxJQUFJLENBQUN2RCxXQUFXLENBQUNpQixXQUFXLENBQUNLLFVBQVUsR0FBR2tDLElBQUksQ0FBQ0MsR0FBRyxDQUM5QyxJQUFJLENBQUN6RCxXQUFXLENBQUNpQixXQUFXLENBQUNLLFVBQVUsRUFDdkMwQixRQUFRLENBQUNLLFFBQ2IsQ0FBQztJQUNMLENBQUMsRUFBRSxJQUFJLENBQUM7RUFDWjtFQUVBUixvQkFBb0JBLENBQUEsRUFBRztJQUNuQixJQUFJLElBQUksQ0FBQ2Ysa0JBQWtCLEVBQUU7TUFDekI0QixhQUFhLENBQUMsSUFBSSxDQUFDNUIsa0JBQWtCLENBQUM7SUFDMUM7RUFDSjtFQUVNUSxrQkFBa0JBLENBQUEsRUFBRztJQUFBLElBQUFxQixNQUFBO0lBQUEsT0FBQTFCLGlCQUFBO01BQ3ZCQyxPQUFPLENBQUNDLEdBQUcsQ0FBQyx1REFBdUQsQ0FBQztNQUVwRSxNQUFNeUIsUUFBUSxHQUFHO1FBQ2JDLElBQUksRUFBRSx1QkFBdUI7UUFDN0JDLFNBQVMsRUFBRTVELElBQUksQ0FBQ2tELEdBQUcsQ0FBQyxDQUFDO1FBQ3JCVyxNQUFNLEVBQUUsRUFBRTtRQUNWdEMsT0FBTyxFQUFFO1VBQ0x1QyxVQUFVLEVBQUUsRUFBRTtVQUNkQyxjQUFjLEVBQUUsRUFBRTtVQUNsQnJDLE1BQU0sRUFBRTtRQUNaLENBQUM7UUFDREosTUFBTSxFQUFFO01BQ1osQ0FBQztNQUVELElBQUk7UUFDQSxNQUFNMEMsUUFBUSxTQUFTMUUsUUFBUSxDQUFDMkUsVUFBVSxDQUFDO1VBQ3ZDQyxvQkFBb0IsRUFBRSxJQUFJO1VBQzFCQyxpQkFBaUIsRUFBRSxJQUFJO1VBQ3ZCQyxlQUFlLEVBQUU7UUFDckIsQ0FBQyxDQUFDO1FBRUYsTUFBTUMsS0FBSyxTQUFTTCxRQUFRLENBQUNNLFdBQVcsQ0FBQztVQUNyQ0MsUUFBUSxFQUFFLGNBQWM7VUFDeEJDLFNBQVMsRUFBRSxFQUFFO1VBQ2JDLFFBQVEsRUFBRTtRQUNkLENBQUMsQ0FBQzs7UUFFRjtRQUNBLEtBQUssSUFBSUMsS0FBSyxHQUFHLEVBQUUsRUFBRUEsS0FBSyxJQUFJLEVBQUUsRUFBRUEsS0FBSyxJQUFJLEVBQUUsRUFBRTtVQUMzQzFDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLHNCQUFzQnlDLEtBQUssWUFBWSxDQUFDO1VBRXBELE1BQU1DLGNBQWMsR0FBRzNFLElBQUksQ0FBQ2tELEdBQUcsQ0FBQyxDQUFDO1VBQ2pDLE1BQU0wQixhQUFhLEdBQUcsRUFBRTtVQUV4QixLQUFLLElBQUlDLENBQUMsR0FBR25CLFFBQVEsQ0FBQ0csTUFBTSxDQUFDcEQsTUFBTSxFQUFFb0UsQ0FBQyxHQUFHSCxLQUFLLEVBQUVHLENBQUMsRUFBRSxFQUFFO1lBQ2pELE1BQU1DLFlBQVksR0FBR1QsS0FBSyxDQUFDVSxLQUFLLENBQUM7Y0FDN0JDLElBQUksRUFBRSxDQUFDLE9BQU8sRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFFLFdBQVcsQ0FBQyxDQUFDSCxDQUFDLEdBQUcsQ0FBQyxDQUFDO2NBQzVEbEIsSUFBSSxFQUFFLGlCQUFpQmtCLENBQUM7WUFDNUIsQ0FBQyxDQUFDLENBQUNJLElBQUksQ0FBQ0MsS0FBSyxJQUFJO2NBQ2J4QixRQUFRLENBQUNHLE1BQU0sQ0FBQ1osSUFBSSxDQUFDaUMsS0FBSyxDQUFDO2NBQzNCLE9BQU9BLEtBQUs7WUFDaEIsQ0FBQyxDQUFDLENBQUNDLEtBQUssQ0FBQ3pDLEtBQUssSUFBSTtjQUNkZ0IsUUFBUSxDQUFDbkMsT0FBTyxDQUFDRyxNQUFNLENBQUN1QixJQUFJLENBQUM7Z0JBQ3pCbUMsS0FBSyxFQUFFLE9BQU87Z0JBQ2RGLEtBQUssRUFBRUwsQ0FBQztnQkFDUm5DLEtBQUssRUFBRUEsS0FBSyxDQUFDMkM7Y0FDakIsQ0FBQyxDQUFDO2NBQ0YsT0FBTyxJQUFJO1lBQ2YsQ0FBQyxDQUFDO1lBRUZULGFBQWEsQ0FBQzNCLElBQUksQ0FBQzZCLFlBQVksQ0FBQztVQUNwQztVQUVBLE1BQU1RLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDWCxhQUFhLENBQUM7VUFDaEMsTUFBTVksY0FBYyxHQUFHeEYsSUFBSSxDQUFDa0QsR0FBRyxDQUFDLENBQUMsR0FBR3lCLGNBQWM7VUFDbERqQixRQUFRLENBQUNuQyxPQUFPLENBQUN1QyxVQUFVLENBQUNiLElBQUksQ0FBQztZQUM3QnlCLEtBQUs7WUFDTGUsSUFBSSxFQUFFRCxjQUFjO1lBQ3BCRSxhQUFhLEVBQUVoQyxRQUFRLENBQUNHLE1BQU0sQ0FBQ3BEO1VBQ25DLENBQUMsQ0FBQztVQUVGdUIsT0FBTyxDQUFDQyxHQUFHLENBQUMsZ0JBQWdCeUIsUUFBUSxDQUFDRyxNQUFNLENBQUNwRCxNQUFNLGNBQWMrRSxjQUFjLElBQUksQ0FBQzs7VUFFbkY7VUFDQSxNQUFNRyxZQUFZLEdBQUdqQyxRQUFRLENBQUNHLE1BQU0sQ0FBQytCLEdBQUcsQ0FBQyxDQUFDVixLQUFLLEVBQUVMLENBQUMsS0FBSztZQUNuRCxJQUFJLENBQUNLLEtBQUssRUFBRSxPQUFPSSxPQUFPLENBQUNPLE9BQU8sQ0FBQyxDQUFDO1lBRXBDLE1BQU1DLFNBQVMsR0FBRzlGLElBQUksQ0FBQ2tELEdBQUcsQ0FBQyxDQUFDO1lBQzVCLE9BQU9nQyxLQUFLLENBQUNhLE9BQU8sQ0FBQztjQUNqQkMsSUFBSSxFQUFFLHFCQUFxQm5CLENBQUMseUJBQXlCLEVBQUUsR0FBSUEsQ0FBQyxHQUFHLEVBQUcsR0FBRztjQUNyRW9CLE9BQU8sRUFBRTtZQUNiLENBQUMsQ0FBQyxDQUFDaEIsSUFBSSxDQUFDLE1BQU07Y0FDVnZCLFFBQVEsQ0FBQ25DLE9BQU8sQ0FBQ3dDLGNBQWMsQ0FBQ2QsSUFBSSxDQUFDakQsSUFBSSxDQUFDa0QsR0FBRyxDQUFDLENBQUMsR0FBRzRDLFNBQVMsQ0FBQztZQUNoRSxDQUFDLENBQUMsQ0FBQ1gsS0FBSyxDQUFDekMsS0FBSyxJQUFJO2NBQ2RnQixRQUFRLENBQUNuQyxPQUFPLENBQUNHLE1BQU0sQ0FBQ3VCLElBQUksQ0FBQztnQkFDekJtQyxLQUFLLEVBQUUsV0FBVztnQkFDbEJGLEtBQUssRUFBRUwsQ0FBQztnQkFDUm5DLEtBQUssRUFBRUEsS0FBSyxDQUFDMkM7Y0FDakIsQ0FBQyxDQUFDO1lBQ04sQ0FBQyxDQUFDO1VBQ04sQ0FBQyxDQUFDO1VBRUYsTUFBTUMsT0FBTyxDQUFDQyxHQUFHLENBQUNJLFlBQVksQ0FBQzs7VUFFL0I7VUFDQSxNQUFNLElBQUlMLE9BQU8sQ0FBQ08sT0FBTyxJQUFJSyxVQUFVLENBQUNMLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztRQUMzRDtRQUVBbkMsUUFBUSxDQUFDcEMsTUFBTSxHQUFHb0MsUUFBUSxDQUFDRyxNQUFNLENBQUNwRCxNQUFNLElBQUksRUFBRSxJQUFJaUQsUUFBUSxDQUFDbkMsT0FBTyxDQUFDRyxNQUFNLENBQUNqQixNQUFNLEdBQUcsQ0FBQztRQUNwRmdELE1BQUksQ0FBQzNELFdBQVcsQ0FBQ2lCLFdBQVcsQ0FBQ0MsbUJBQW1CLEdBQUdzQyxJQUFJLENBQUNDLEdBQUcsQ0FDdkRFLE1BQUksQ0FBQzNELFdBQVcsQ0FBQ2lCLFdBQVcsQ0FBQ0MsbUJBQW1CLEVBQ2hEMEMsUUFBUSxDQUFDRyxNQUFNLENBQUNwRCxNQUNwQixDQUFDO1FBRUR1QixPQUFPLENBQUNDLEdBQUcsQ0FBQyxtQkFBbUJ5QixRQUFRLENBQUNHLE1BQU0sQ0FBQ3BELE1BQU0sWUFBWWlELFFBQVEsQ0FBQ25DLE9BQU8sQ0FBQ0csTUFBTSxDQUFDakIsTUFBTSxTQUFTLENBQUM7TUFFN0csQ0FBQyxDQUFDLE9BQU9pQyxLQUFLLEVBQUU7UUFDWmdCLFFBQVEsQ0FBQ2hCLEtBQUssR0FBR0EsS0FBSyxDQUFDMkMsT0FBTztRQUM5QnJELE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLGdCQUFnQlMsS0FBSyxDQUFDMkMsT0FBTyxFQUFFLENBQUM7TUFDaEQ7TUFFQTNCLFFBQVEsQ0FBQ3lDLFFBQVEsR0FBR25HLElBQUksQ0FBQ2tELEdBQUcsQ0FBQyxDQUFDLEdBQUdRLFFBQVEsQ0FBQ0UsU0FBUztNQUNuREgsTUFBSSxDQUFDM0QsV0FBVyxDQUFDZ0IsU0FBUyxDQUFDbUMsSUFBSSxDQUFDUyxRQUFRLENBQUM7TUFDekMxQixPQUFPLENBQUNDLEdBQUcsQ0FBQyxFQUFFLENBQUM7SUFBQztFQUNwQjtFQUVNSSxnQkFBZ0JBLENBQUEsRUFBRztJQUFBLElBQUErRCxNQUFBO0lBQUEsT0FBQXJFLGlCQUFBO01BQ3JCQyxPQUFPLENBQUNDLEdBQUcsQ0FBQywwREFBMEQsQ0FBQztNQUV2RSxNQUFNeUIsUUFBUSxHQUFHO1FBQ2JDLElBQUksRUFBRSxpQkFBaUI7UUFDdkJDLFNBQVMsRUFBRTVELElBQUksQ0FBQ2tELEdBQUcsQ0FBQyxDQUFDO1FBQ3JCVyxNQUFNLEVBQUUsRUFBRTtRQUNWdEMsT0FBTyxFQUFFO1VBQ0w4RSxTQUFTLEVBQUUsQ0FBQztVQUNaQyxpQkFBaUIsRUFBRSxDQUFDO1VBQ3BCQyxnQkFBZ0IsRUFBRSxDQUFDO1VBQ25CN0UsTUFBTSxFQUFFO1FBQ1osQ0FBQztRQUNESixNQUFNLEVBQUU7TUFDWixDQUFDO01BRUQsSUFBSTtRQUNBLE1BQU0wQyxRQUFRLFNBQVMxRSxRQUFRLENBQUMyRSxVQUFVLENBQUM7VUFDdkNDLG9CQUFvQixFQUFFLElBQUk7VUFDMUJDLGlCQUFpQixFQUFFLEtBQUs7VUFBRTtVQUMxQkMsZUFBZSxFQUFFO1FBQ3JCLENBQUMsQ0FBQztRQUVGLE1BQU1DLEtBQUssU0FBU0wsUUFBUSxDQUFDTSxXQUFXLENBQUM7VUFDckNDLFFBQVEsRUFBRSxNQUFNO1VBQ2hCQyxTQUFTLEVBQUUsRUFBRTtVQUNiQyxRQUFRLEVBQUU7UUFDZCxDQUFDLENBQUM7O1FBRUY7UUFDQXpDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLHlDQUF5QyxDQUFDO1FBQ3RELE1BQU11RSxjQUFjLEdBQUd4RyxJQUFJLENBQUNrRCxHQUFHLENBQUMsQ0FBQztRQUVqQyxNQUFNdUQsYUFBYSxHQUFHQyxLQUFLLENBQUNDLElBQUksQ0FBQztVQUFFbEcsTUFBTSxFQUFFO1FBQUcsQ0FBQyxFQUFFLENBQUNtRyxDQUFDLEVBQUUvQixDQUFDLEtBQ2xEUixLQUFLLENBQUNVLEtBQUssQ0FBQztVQUNSQyxJQUFJLEVBQUUsT0FBTztVQUNickIsSUFBSSxFQUFFLGVBQWVrQixDQUFDO1FBQzFCLENBQUMsQ0FBQyxDQUFDTSxLQUFLLENBQUN6QyxLQUFLLElBQUk7VUFDZGdCLFFBQVEsQ0FBQ25DLE9BQU8sQ0FBQ0csTUFBTSxDQUFDdUIsSUFBSSxDQUFDO1lBQ3pCbUMsS0FBSyxFQUFFLE9BQU87WUFDZEYsS0FBSyxFQUFFTCxDQUFDO1lBQ1JuQyxLQUFLLEVBQUVBLEtBQUssQ0FBQzJDO1VBQ2pCLENBQUMsQ0FBQztVQUNGLE9BQU8sSUFBSTtRQUNmLENBQUMsQ0FDTCxDQUFDO1FBRUQsTUFBTXdCLGFBQWEsU0FBU3ZCLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDa0IsYUFBYSxDQUFDO1FBQ3REL0MsUUFBUSxDQUFDRyxNQUFNLEdBQUdnRCxhQUFhLENBQUNDLE1BQU0sQ0FBQzVCLEtBQUssSUFBSUEsS0FBSyxLQUFLLElBQUksQ0FBQztRQUMvRHhCLFFBQVEsQ0FBQ25DLE9BQU8sQ0FBQzhFLFNBQVMsR0FBR3JHLElBQUksQ0FBQ2tELEdBQUcsQ0FBQyxDQUFDLEdBQUdzRCxjQUFjO1FBRXhEeEUsT0FBTyxDQUFDQyxHQUFHLENBQUMsZ0JBQWdCeUIsUUFBUSxDQUFDRyxNQUFNLENBQUNwRCxNQUFNLGlCQUFpQmlELFFBQVEsQ0FBQ25DLE9BQU8sQ0FBQzhFLFNBQVMsSUFBSSxDQUFDOztRQUVsRztRQUNBckUsT0FBTyxDQUFDQyxHQUFHLENBQUMsc0NBQXNDLENBQUM7UUFDbkQsTUFBTThFLGFBQWEsR0FBRy9HLElBQUksQ0FBQ2tELEdBQUcsQ0FBQyxDQUFDO1FBQ2hDLElBQUk4RCxxQkFBcUIsR0FBRyxLQUFLO1FBRWpDLE1BQU1yQixZQUFZLEdBQUdqQyxRQUFRLENBQUNHLE1BQU0sQ0FBQytCLEdBQUcsQ0FBQyxDQUFDVixLQUFLLEVBQUVMLENBQUMsS0FBSztVQUNuRCxNQUFNaUIsU0FBUyxHQUFHOUYsSUFBSSxDQUFDa0QsR0FBRyxDQUFDLENBQUM7VUFDNUIsT0FBT2dDLEtBQUssQ0FBQ2EsT0FBTyxDQUFDO1lBQ2pCQyxJQUFJLEVBQUUsY0FBY25CLENBQUMscUNBQXFDO1lBQzFEb0IsT0FBTyxFQUFFO1VBQ2IsQ0FBQyxDQUFDLENBQUNoQixJQUFJLENBQUMsTUFBTTtZQUNWLE1BQU1nQyxZQUFZLEdBQUdqSCxJQUFJLENBQUNrRCxHQUFHLENBQUMsQ0FBQyxHQUFHNEMsU0FBUztZQUMzQyxJQUFJLENBQUNrQixxQkFBcUIsRUFBRTtjQUN4QnRELFFBQVEsQ0FBQ25DLE9BQU8sQ0FBQytFLGlCQUFpQixHQUFHdEcsSUFBSSxDQUFDa0QsR0FBRyxDQUFDLENBQUMsR0FBRzZELGFBQWE7Y0FDL0RDLHFCQUFxQixHQUFHLElBQUk7WUFDaEM7WUFDQSxPQUFPQyxZQUFZO1VBQ3ZCLENBQUMsQ0FBQyxDQUFDOUIsS0FBSyxDQUFDekMsS0FBSyxJQUFJO1lBQ2RnQixRQUFRLENBQUNuQyxPQUFPLENBQUNHLE1BQU0sQ0FBQ3VCLElBQUksQ0FBQztjQUN6Qm1DLEtBQUssRUFBRSxXQUFXO2NBQ2xCRixLQUFLLEVBQUVMLENBQUM7Y0FDUm5DLEtBQUssRUFBRUEsS0FBSyxDQUFDMkM7WUFDakIsQ0FBQyxDQUFDO1lBQ0YsT0FBTyxJQUFJO1VBQ2YsQ0FBQyxDQUFDO1FBQ04sQ0FBQyxDQUFDO1FBRUYsTUFBTTdELGFBQWEsU0FBUzhELE9BQU8sQ0FBQ0MsR0FBRyxDQUFDSSxZQUFZLENBQUM7UUFDckRqQyxRQUFRLENBQUNuQyxPQUFPLENBQUNnRixnQkFBZ0IsR0FBR3ZHLElBQUksQ0FBQ2tELEdBQUcsQ0FBQyxDQUFDLEdBQUc2RCxhQUFhO1FBRTlELE1BQU1HLGNBQWMsR0FBRzFGLGFBQWEsQ0FBQ3NGLE1BQU0sQ0FBQ0ssQ0FBQyxJQUFJQSxDQUFDLEtBQUssSUFBSSxDQUFDO1FBQzVEZixNQUFJLENBQUM3RSxPQUFPLENBQUNDLGFBQWEsQ0FBQ3lCLElBQUksQ0FBQyxHQUFHaUUsY0FBYyxDQUFDO1FBRWxEeEQsUUFBUSxDQUFDcEMsTUFBTSxHQUFHb0MsUUFBUSxDQUFDRyxNQUFNLENBQUNwRCxNQUFNLElBQUksRUFBRSxJQUFJaUQsUUFBUSxDQUFDbkMsT0FBTyxDQUFDRyxNQUFNLENBQUNqQixNQUFNLEdBQUcsRUFBRTtRQUVyRnVCLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLHNCQUFzQnlCLFFBQVEsQ0FBQ25DLE9BQU8sQ0FBQytFLGlCQUFpQixJQUFJLENBQUM7UUFDekV0RSxPQUFPLENBQUNDLEdBQUcsQ0FBQyxxQkFBcUJ5QixRQUFRLENBQUNuQyxPQUFPLENBQUNnRixnQkFBZ0IsSUFBSSxDQUFDO1FBQ3ZFdkUsT0FBTyxDQUFDQyxHQUFHLENBQUMsd0JBQXdCaUYsY0FBYyxDQUFDekcsTUFBTSxHQUFHLENBQUMsR0FBRzZDLElBQUksQ0FBQzhELEtBQUssQ0FBQ0YsY0FBYyxDQUFDRyxNQUFNLENBQUMsQ0FBQ0MsQ0FBQyxFQUFFQyxDQUFDLEtBQUtELENBQUMsR0FBR0MsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHTCxjQUFjLENBQUN6RyxNQUFNLENBQUMsR0FBRyxLQUFLLElBQUksQ0FBQztRQUMxSnVCLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLGNBQWN5QixRQUFRLENBQUNuQyxPQUFPLENBQUNHLE1BQU0sQ0FBQ2pCLE1BQU0sRUFBRSxDQUFDO01BRS9ELENBQUMsQ0FBQyxPQUFPaUMsS0FBSyxFQUFFO1FBQ1pnQixRQUFRLENBQUNoQixLQUFLLEdBQUdBLEtBQUssQ0FBQzJDLE9BQU87UUFDOUJyRCxPQUFPLENBQUNDLEdBQUcsQ0FBQyxnQkFBZ0JTLEtBQUssQ0FBQzJDLE9BQU8sRUFBRSxDQUFDO01BQ2hEO01BRUEzQixRQUFRLENBQUN5QyxRQUFRLEdBQUduRyxJQUFJLENBQUNrRCxHQUFHLENBQUMsQ0FBQyxHQUFHUSxRQUFRLENBQUNFLFNBQVM7TUFDbkR3QyxNQUFJLENBQUN0RyxXQUFXLENBQUNnQixTQUFTLENBQUNtQyxJQUFJLENBQUNTLFFBQVEsQ0FBQztNQUN6QzFCLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLEVBQUUsQ0FBQztJQUFDO0VBQ3BCO0VBRU1LLG9CQUFvQkEsQ0FBQSxFQUFHO0lBQUEsSUFBQWtGLE1BQUE7SUFBQSxPQUFBekYsaUJBQUE7TUFDekJDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLDZEQUE2RCxDQUFDO01BRTFFLE1BQU15QixRQUFRLEdBQUc7UUFDYkMsSUFBSSxFQUFFLHFCQUFxQjtRQUMzQkMsU0FBUyxFQUFFNUQsSUFBSSxDQUFDa0QsR0FBRyxDQUFDLENBQUM7UUFDckJXLE1BQU0sRUFBRSxFQUFFO1FBQ1Z0QyxPQUFPLEVBQUU7VUFDTGtHLGNBQWMsRUFBRSxDQUFDO1VBQ2pCQyxXQUFXLEVBQUUsQ0FBQztVQUNkQyxZQUFZLEVBQUUsQ0FBQztVQUNmakcsTUFBTSxFQUFFO1FBQ1osQ0FBQztRQUNESixNQUFNLEVBQUU7TUFDWixDQUFDO01BRUQsSUFBSTtRQUNBLE1BQU0wQyxRQUFRLFNBQVMxRSxRQUFRLENBQUMyRSxVQUFVLENBQUM7VUFDdkNDLG9CQUFvQixFQUFFLElBQUk7VUFDMUJDLGlCQUFpQixFQUFFLElBQUk7VUFDdkJ5RCxrQkFBa0IsRUFBRTtRQUN4QixDQUFDLENBQUM7UUFFRixNQUFNdkQsS0FBSyxTQUFTTCxRQUFRLENBQUNNLFdBQVcsQ0FBQztVQUNyQ0MsUUFBUSxFQUFFLE1BQU07VUFDaEJDLFNBQVMsRUFBRSxFQUFFO1VBQ2JDLFFBQVEsRUFBRTtRQUNkLENBQUMsQ0FBQzs7UUFFRjtRQUNBLE1BQU1nQyxhQUFhLEdBQUdDLEtBQUssQ0FBQ0MsSUFBSSxDQUFDO1VBQUVsRyxNQUFNLEVBQUU7UUFBRyxDQUFDLEVBQUUsQ0FBQ21HLENBQUMsRUFBRS9CLENBQUMsS0FDbERSLEtBQUssQ0FBQ1UsS0FBSyxDQUFDO1VBQ1JDLElBQUksRUFBRSxDQUFDLE9BQU8sRUFBRSxZQUFZLEVBQUUsU0FBUyxDQUFDLENBQUNILENBQUMsR0FBRyxDQUFDLENBQUM7VUFDL0NsQixJQUFJLEVBQUUsbUJBQW1Ca0IsQ0FBQztRQUM5QixDQUFDLENBQ0wsQ0FBQztRQUVEbkIsUUFBUSxDQUFDRyxNQUFNLFNBQVN5QixPQUFPLENBQUNDLEdBQUcsQ0FBQ2tCLGFBQWEsQ0FBQztRQUNsRHpFLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLGNBQWN5QixRQUFRLENBQUNHLE1BQU0sQ0FBQ3BELE1BQU0sU0FBUyxDQUFDO1FBRTFELE1BQU1vSCxhQUFhLEdBQUd6SCxPQUFPLENBQUMyQyxXQUFXLENBQUMsQ0FBQyxDQUFDSSxRQUFRO1FBQ3BELE1BQU0yRSxZQUFZLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQztRQUNwQyxNQUFNQyxPQUFPLEdBQUcvSCxJQUFJLENBQUNrRCxHQUFHLENBQUMsQ0FBQyxHQUFHNEUsWUFBWTtRQUN6QyxNQUFNRSxTQUFTLEdBQUcsRUFBRTtRQUVwQixJQUFJQyxXQUFXLEdBQUcsQ0FBQztRQUVuQmpHLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLDRDQUE0QyxDQUFDO1FBRXpELE9BQU9qQyxJQUFJLENBQUNrRCxHQUFHLENBQUMsQ0FBQyxHQUFHNkUsT0FBTyxFQUFFO1VBQ3pCLE1BQU1uRCxhQUFhLEdBQUdsQixRQUFRLENBQUNHLE1BQU0sQ0FBQytCLEdBQUc7WUFBQSxJQUFBc0MsSUFBQSxHQUFBbkcsaUJBQUEsQ0FBQyxXQUFPbUQsS0FBSyxFQUFFTCxDQUFDLEVBQUs7Y0FDMUQsTUFBTWlCLFNBQVMsR0FBRzlGLElBQUksQ0FBQ2tELEdBQUcsQ0FBQyxDQUFDO2NBQzVCLElBQUk7Z0JBQ0EsTUFBTWdDLEtBQUssQ0FBQ2EsT0FBTyxDQUFDO2tCQUNoQkMsSUFBSSxFQUFFLGtCQUFrQmlDLFdBQVcsd0JBQXdCQSxXQUFXLEdBQUcsR0FBRyxFQUFFO2tCQUM5RWhDLE9BQU8sRUFBRTtnQkFDYixDQUFDLENBQUM7Z0JBQ0YsTUFBTWtDLFFBQVEsR0FBR25JLElBQUksQ0FBQ2tELEdBQUcsQ0FBQyxDQUFDLEdBQUc0QyxTQUFTO2dCQUN2Q2tDLFNBQVMsQ0FBQy9FLElBQUksQ0FBQ2tGLFFBQVEsQ0FBQztnQkFDeEJ6RSxRQUFRLENBQUNuQyxPQUFPLENBQUNrRyxjQUFjLEVBQUU7Z0JBQ2pDLE9BQU8sSUFBSTtjQUNmLENBQUMsQ0FBQyxPQUFPL0UsS0FBSyxFQUFFO2dCQUNaZ0IsUUFBUSxDQUFDbkMsT0FBTyxDQUFDRyxNQUFNLENBQUN1QixJQUFJLENBQUM7a0JBQ3pCbUMsS0FBSyxFQUFFLHFCQUFxQjtrQkFDNUJGLEtBQUssRUFBRUwsQ0FBQztrQkFDUm1CLElBQUksRUFBRWlDLFdBQVc7a0JBQ2pCdkYsS0FBSyxFQUFFQSxLQUFLLENBQUMyQztnQkFDakIsQ0FBQyxDQUFDO2dCQUNGLE9BQU8sS0FBSztjQUNoQjtZQUNKLENBQUM7WUFBQSxpQkFBQStDLEVBQUEsRUFBQUMsR0FBQTtjQUFBLE9BQUFILElBQUEsQ0FBQUksS0FBQSxPQUFBQyxTQUFBO1lBQUE7VUFBQSxJQUFDO1VBRUYsTUFBTWpELE9BQU8sQ0FBQ0MsR0FBRyxDQUFDWCxhQUFhLENBQUM7VUFDaENxRCxXQUFXLEVBQUU7O1VBRWI7VUFDQSxNQUFNLElBQUkzQyxPQUFPLENBQUNPLE9BQU8sSUFBSUssVUFBVSxDQUFDTCxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7O1VBRXZEO1VBQ0EsSUFBSW9DLFdBQVcsR0FBRyxFQUFFLEtBQUssQ0FBQyxFQUFFO1lBQ3hCLE1BQU1PLE9BQU8sR0FBR3hJLElBQUksQ0FBQ2tELEdBQUcsQ0FBQyxDQUFDLEdBQUdRLFFBQVEsQ0FBQ0UsU0FBUztZQUMvQyxNQUFNNkUsU0FBUyxHQUFHVixPQUFPLEdBQUcvSCxJQUFJLENBQUNrRCxHQUFHLENBQUMsQ0FBQztZQUN0Q2xCLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLGtCQUFrQnFCLElBQUksQ0FBQzhELEtBQUssQ0FBQ29CLE9BQU8sR0FBRyxJQUFJLENBQUMsY0FBY2xGLElBQUksQ0FBQzhELEtBQUssQ0FBQ3FCLFNBQVMsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDO1lBQ2hIekcsT0FBTyxDQUFDQyxHQUFHLENBQUMseUJBQXlCeUIsUUFBUSxDQUFDbkMsT0FBTyxDQUFDa0csY0FBYyxhQUFhL0QsUUFBUSxDQUFDbkMsT0FBTyxDQUFDRyxNQUFNLENBQUNqQixNQUFNLEVBQUUsQ0FBQztVQUN0SDtRQUNKO1FBRUEsTUFBTWlJLFdBQVcsR0FBR3RJLE9BQU8sQ0FBQzJDLFdBQVcsQ0FBQyxDQUFDLENBQUNJLFFBQVE7UUFDbERPLFFBQVEsQ0FBQ25DLE9BQU8sQ0FBQ29HLFlBQVksR0FBR2UsV0FBVyxHQUFHYixhQUFhO1FBQzNEbkUsUUFBUSxDQUFDbkMsT0FBTyxDQUFDbUcsV0FBVyxHQUFHTSxTQUFTLENBQUN2SCxNQUFNLEdBQUcsQ0FBQyxHQUM3QzZDLElBQUksQ0FBQzhELEtBQUssQ0FBQ1ksU0FBUyxDQUFDWCxNQUFNLENBQUMsQ0FBQ0MsQ0FBQyxFQUFFQyxDQUFDLEtBQUtELENBQUMsR0FBR0MsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHUyxTQUFTLENBQUN2SCxNQUFNLENBQUMsR0FDbkUsQ0FBQztRQUVQaUQsUUFBUSxDQUFDcEMsTUFBTSxHQUFHb0MsUUFBUSxDQUFDbkMsT0FBTyxDQUFDa0csY0FBYyxJQUFJLElBQUksSUFDeEMvRCxRQUFRLENBQUNuQyxPQUFPLENBQUNHLE1BQU0sQ0FBQ2pCLE1BQU0sR0FBRyxFQUFFLElBQ25DaUQsUUFBUSxDQUFDbkMsT0FBTyxDQUFDb0csWUFBWSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUM7O1FBRXBFM0YsT0FBTyxDQUFDQyxHQUFHLENBQUMsdUJBQXVCeUIsUUFBUSxDQUFDbkMsT0FBTyxDQUFDa0csY0FBYyxFQUFFLENBQUM7UUFDckV6RixPQUFPLENBQUNDLEdBQUcsQ0FBQyx5QkFBeUJ5QixRQUFRLENBQUNuQyxPQUFPLENBQUNtRyxXQUFXLElBQUksQ0FBQztRQUN0RTFGLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLHFCQUFxQnFCLElBQUksQ0FBQzhELEtBQUssQ0FBQzFELFFBQVEsQ0FBQ25DLE9BQU8sQ0FBQ29HLFlBQVksR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztRQUM3RjNGLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLGtCQUFrQixDQUFFeUIsUUFBUSxDQUFDbkMsT0FBTyxDQUFDRyxNQUFNLENBQUNqQixNQUFNLEdBQUdpRCxRQUFRLENBQUNuQyxPQUFPLENBQUNrRyxjQUFjLEdBQUksR0FBRyxFQUFFN0UsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7TUFFM0gsQ0FBQyxDQUFDLE9BQU9GLEtBQUssRUFBRTtRQUNaZ0IsUUFBUSxDQUFDaEIsS0FBSyxHQUFHQSxLQUFLLENBQUMyQyxPQUFPO1FBQzlCckQsT0FBTyxDQUFDQyxHQUFHLENBQUMsZ0JBQWdCUyxLQUFLLENBQUMyQyxPQUFPLEVBQUUsQ0FBQztNQUNoRDtNQUVBM0IsUUFBUSxDQUFDeUMsUUFBUSxHQUFHbkcsSUFBSSxDQUFDa0QsR0FBRyxDQUFDLENBQUMsR0FBR1EsUUFBUSxDQUFDRSxTQUFTO01BQ25ENEQsTUFBSSxDQUFDMUgsV0FBVyxDQUFDZ0IsU0FBUyxDQUFDbUMsSUFBSSxDQUFDUyxRQUFRLENBQUM7TUFDekMxQixPQUFPLENBQUNDLEdBQUcsQ0FBQyxFQUFFLENBQUM7SUFBQztFQUNwQjtFQUVNTSxvQkFBb0JBLENBQUEsRUFBRztJQUFBLElBQUFvRyxNQUFBO0lBQUEsT0FBQTVHLGlCQUFBO01BQ3pCQyxPQUFPLENBQUNDLEdBQUcsQ0FBQyw0REFBNEQsQ0FBQztNQUV6RSxNQUFNeUIsUUFBUSxHQUFHO1FBQ2JDLElBQUksRUFBRSxxQkFBcUI7UUFDM0JDLFNBQVMsRUFBRTVELElBQUksQ0FBQ2tELEdBQUcsQ0FBQyxDQUFDO1FBQ3JCVyxNQUFNLEVBQUU7VUFDSitFLE1BQU0sRUFBRSxFQUFFO1VBQ1ZDLFdBQVcsRUFBRSxFQUFFO1VBQ2ZDLFFBQVEsRUFBRSxFQUFFO1VBQ1pDLFVBQVUsRUFBRSxFQUFFO1VBQ2RDLFlBQVksRUFBRTtRQUNsQixDQUFDO1FBQ0R6SCxPQUFPLEVBQUU7VUFDTDBILFdBQVcsRUFBRSxDQUFDLENBQUM7VUFDZkMsY0FBYyxFQUFFLENBQUMsQ0FBQztVQUNsQnhILE1BQU0sRUFBRTtRQUNaLENBQUM7UUFDREosTUFBTSxFQUFFO01BQ1osQ0FBQztNQUVELElBQUk7UUFDQSxNQUFNMEMsUUFBUSxTQUFTMUUsUUFBUSxDQUFDMkUsVUFBVSxDQUFDO1VBQ3ZDQyxvQkFBb0IsRUFBRSxJQUFJO1VBQzFCQyxpQkFBaUIsRUFBRSxJQUFJO1VBQ3ZCQyxlQUFlLEVBQUU7UUFDckIsQ0FBQyxDQUFDO1FBRUYsTUFBTUMsS0FBSyxTQUFTTCxRQUFRLENBQUNNLFdBQVcsQ0FBQztVQUNyQ0MsUUFBUSxFQUFFLGNBQWM7VUFDeEJDLFNBQVMsRUFBRSxFQUFFO1VBQ2JDLFFBQVEsRUFBRTtRQUNkLENBQUMsQ0FBQzs7UUFFRjtRQUNBLE1BQU0wRSxVQUFVLEdBQUcsQ0FDZjtVQUFFbkUsSUFBSSxFQUFFLE9BQU87VUFBRW9FLEtBQUssRUFBRTtRQUFHLENBQUMsRUFDNUI7VUFBRXBFLElBQUksRUFBRSxZQUFZO1VBQUVvRSxLQUFLLEVBQUU7UUFBRyxDQUFDLEVBQ2pDO1VBQUVwRSxJQUFJLEVBQUUsU0FBUztVQUFFb0UsS0FBSyxFQUFFO1FBQUcsQ0FBQyxFQUM5QjtVQUFFcEUsSUFBSSxFQUFFLFdBQVc7VUFBRW9FLEtBQUssRUFBRTtRQUFFLENBQUMsRUFDL0I7VUFBRXBFLElBQUksRUFBRSxhQUFhO1VBQUVvRSxLQUFLLEVBQUU7UUFBRSxDQUFDLENBQ3BDO1FBRURwSCxPQUFPLENBQUNDLEdBQUcsQ0FBQyxrQ0FBa0MsQ0FBQztRQUMvQyxLQUFLLE1BQU07VUFBRStDLElBQUk7VUFBRW9FO1FBQU0sQ0FBQyxJQUFJRCxVQUFVLEVBQUU7VUFDdEMsTUFBTUUsWUFBWSxHQUFHM0MsS0FBSyxDQUFDQyxJQUFJLENBQUM7WUFBRWxHLE1BQU0sRUFBRTJJO1VBQU0sQ0FBQyxFQUFFLENBQUN4QyxDQUFDLEVBQUUvQixDQUFDLEtBQ3BEUixLQUFLLENBQUNVLEtBQUssQ0FBQztZQUFFQyxJQUFJO1lBQUVyQixJQUFJLEVBQUUsR0FBR3FCLElBQUksSUFBSUgsQ0FBQztVQUFHLENBQUMsQ0FDOUMsQ0FBQztVQUVELE1BQU15RSxVQUFVLFNBQVNoRSxPQUFPLENBQUNDLEdBQUcsQ0FBQzhELFlBQVksQ0FBQztVQUNsRDNGLFFBQVEsQ0FBQ0csTUFBTSxDQUFDbUIsSUFBSSxHQUFHLEdBQUcsQ0FBQyxHQUFHc0UsVUFBVTtVQUN4QzVGLFFBQVEsQ0FBQ25DLE9BQU8sQ0FBQzBILFdBQVcsQ0FBQ2pFLElBQUksQ0FBQyxHQUFHLENBQUM7VUFDdEN0QixRQUFRLENBQUNuQyxPQUFPLENBQUMySCxjQUFjLENBQUNsRSxJQUFJLENBQUMsR0FBRyxFQUFFO1VBRTFDaEQsT0FBTyxDQUFDQyxHQUFHLENBQUMsUUFBUStDLElBQUksS0FBS3NFLFVBQVUsQ0FBQzdJLE1BQU0sU0FBUyxDQUFDO1FBQzVEOztRQUVBO1FBQ0F1QixPQUFPLENBQUNDLEdBQUcsQ0FBQyx5Q0FBeUMsQ0FBQztRQUV0RCxNQUFNc0gsZ0JBQWdCLEdBQUdDLE1BQU0sQ0FBQ0MsT0FBTyxDQUFDL0YsUUFBUSxDQUFDRyxNQUFNLENBQUMsQ0FBQytCLEdBQUc7VUFBQSxJQUFBOEQsS0FBQSxHQUFBM0gsaUJBQUEsQ0FBQyxXQUFPLENBQUM0SCxTQUFTLEVBQUU5RixNQUFNLENBQUMsRUFBSztZQUN4RixNQUFNbUIsSUFBSSxHQUFHMkUsU0FBUyxDQUFDQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7WUFFckMsT0FBT3RFLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDMUIsTUFBTSxDQUFDK0IsR0FBRztjQUFBLElBQUFpRSxLQUFBLEdBQUE5SCxpQkFBQSxDQUFDLFdBQU9tRCxLQUFLLEVBQUVMLENBQUMsRUFBSztnQkFDOUMsTUFBTWlGLEtBQUssR0FBR25CLE1BQUksQ0FBQ29CLGVBQWUsQ0FBQy9FLElBQUksRUFBRUgsQ0FBQyxDQUFDO2dCQUUzQyxLQUFLLE1BQU1tQixJQUFJLElBQUk4RCxLQUFLLEVBQUU7a0JBQ3RCLE1BQU1oRSxTQUFTLEdBQUc5RixJQUFJLENBQUNrRCxHQUFHLENBQUMsQ0FBQztrQkFDNUIsSUFBSTtvQkFDQSxNQUFNZ0MsS0FBSyxDQUFDYSxPQUFPLENBQUM7c0JBQ2hCQyxJQUFJLEVBQUVBLElBQUksQ0FBQ2dFLFdBQVc7c0JBQ3RCL0QsT0FBTyxFQUFFRCxJQUFJLENBQUNDO29CQUNsQixDQUFDLENBQUM7b0JBRUYsTUFBTWtDLFFBQVEsR0FBR25JLElBQUksQ0FBQ2tELEdBQUcsQ0FBQyxDQUFDLEdBQUc0QyxTQUFTO29CQUN2Q3BDLFFBQVEsQ0FBQ25DLE9BQU8sQ0FBQzJILGNBQWMsQ0FBQ2xFLElBQUksQ0FBQyxDQUFDL0IsSUFBSSxDQUFDa0YsUUFBUSxDQUFDO29CQUNwRHpFLFFBQVEsQ0FBQ25DLE9BQU8sQ0FBQzBILFdBQVcsQ0FBQ2pFLElBQUksQ0FBQyxFQUFFO2tCQUV4QyxDQUFDLENBQUMsT0FBT3RDLEtBQUssRUFBRTtvQkFDWmdCLFFBQVEsQ0FBQ25DLE9BQU8sQ0FBQ0csTUFBTSxDQUFDdUIsSUFBSSxDQUFDO3NCQUN6Qm1DLEtBQUssRUFBRSxnQkFBZ0I7c0JBQ3ZCdUUsU0FBUyxFQUFFM0UsSUFBSTtzQkFDZkUsS0FBSyxFQUFFTCxDQUFDO3NCQUNSbUIsSUFBSSxFQUFFQSxJQUFJLENBQUNnRSxXQUFXO3NCQUN0QnRILEtBQUssRUFBRUEsS0FBSyxDQUFDMkM7b0JBQ2pCLENBQUMsQ0FBQztrQkFDTjtnQkFDSjtjQUNKLENBQUM7Y0FBQSxpQkFBQTRFLEdBQUEsRUFBQUMsR0FBQTtnQkFBQSxPQUFBTCxLQUFBLENBQUF2QixLQUFBLE9BQUFDLFNBQUE7Y0FBQTtZQUFBLElBQUMsQ0FBQztVQUNQLENBQUM7VUFBQSxpQkFBQTRCLEdBQUE7WUFBQSxPQUFBVCxLQUFBLENBQUFwQixLQUFBLE9BQUFDLFNBQUE7VUFBQTtRQUFBLElBQUM7UUFFRixNQUFNakQsT0FBTyxDQUFDQyxHQUFHLENBQUNnRSxnQkFBZ0IsQ0FBQzs7UUFFbkM7UUFDQUMsTUFBTSxDQUFDQyxPQUFPLENBQUMvRixRQUFRLENBQUNuQyxPQUFPLENBQUMySCxjQUFjLENBQUMsQ0FBQ2tCLE9BQU8sQ0FBQyxDQUFDLENBQUNwRixJQUFJLEVBQUVxRixLQUFLLENBQUMsS0FBSztVQUN2RTNHLFFBQVEsQ0FBQ25DLE9BQU8sQ0FBQzJILGNBQWMsQ0FBQ2xFLElBQUksQ0FBQyxHQUFHcUYsS0FBSyxDQUFDNUosTUFBTSxHQUFHLENBQUMsR0FDbEQ2QyxJQUFJLENBQUM4RCxLQUFLLENBQUNpRCxLQUFLLENBQUNoRCxNQUFNLENBQUMsQ0FBQ0MsQ0FBQyxFQUFFQyxDQUFDLEtBQUtELENBQUMsR0FBR0MsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHOEMsS0FBSyxDQUFDNUosTUFBTSxDQUFDLEdBQzNELENBQUM7UUFDWCxDQUFDLENBQUM7UUFFRixNQUFNNkosV0FBVyxHQUFHZCxNQUFNLENBQUNlLE1BQU0sQ0FBQzdHLFFBQVEsQ0FBQ0csTUFBTSxDQUFDLENBQUMyRyxJQUFJLENBQUMsQ0FBQyxDQUFDL0osTUFBTTtRQUNoRSxNQUFNZ0ssVUFBVSxHQUFHakIsTUFBTSxDQUFDZSxNQUFNLENBQUM3RyxRQUFRLENBQUNuQyxPQUFPLENBQUMwSCxXQUFXLENBQUMsQ0FBQzVCLE1BQU0sQ0FBQyxDQUFDQyxDQUFDLEVBQUVDLENBQUMsS0FBS0QsQ0FBQyxHQUFHQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRXpGN0QsUUFBUSxDQUFDcEMsTUFBTSxHQUFHZ0osV0FBVyxJQUFJLEVBQUUsSUFDbEJHLFVBQVUsSUFBSSxHQUFHLElBQ2pCL0csUUFBUSxDQUFDbkMsT0FBTyxDQUFDRyxNQUFNLENBQUNqQixNQUFNLEdBQUcsRUFBRTtRQUVwRHVCLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLG9CQUFvQnFJLFdBQVcsRUFBRSxDQUFDO1FBQzlDdEksT0FBTyxDQUFDQyxHQUFHLENBQUMsbUJBQW1Cd0ksVUFBVSxFQUFFLENBQUM7UUFDNUN6SSxPQUFPLENBQUNDLEdBQUcsQ0FBQyxtQkFBbUIsRUFBRXlCLFFBQVEsQ0FBQ25DLE9BQU8sQ0FBQzBILFdBQVcsQ0FBQztRQUM5RGpILE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLHVCQUF1QixFQUFFeUIsUUFBUSxDQUFDbkMsT0FBTyxDQUFDMkgsY0FBYyxDQUFDO1FBQ3JFbEgsT0FBTyxDQUFDQyxHQUFHLENBQUMsY0FBY3lCLFFBQVEsQ0FBQ25DLE9BQU8sQ0FBQ0csTUFBTSxDQUFDakIsTUFBTSxFQUFFLENBQUM7TUFFL0QsQ0FBQyxDQUFDLE9BQU9pQyxLQUFLLEVBQUU7UUFDWmdCLFFBQVEsQ0FBQ2hCLEtBQUssR0FBR0EsS0FBSyxDQUFDMkMsT0FBTztRQUM5QnJELE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLGdCQUFnQlMsS0FBSyxDQUFDMkMsT0FBTyxFQUFFLENBQUM7TUFDaEQ7TUFFQTNCLFFBQVEsQ0FBQ3lDLFFBQVEsR0FBR25HLElBQUksQ0FBQ2tELEdBQUcsQ0FBQyxDQUFDLEdBQUdRLFFBQVEsQ0FBQ0UsU0FBUztNQUNuRCtFLE1BQUksQ0FBQzdJLFdBQVcsQ0FBQ2dCLFNBQVMsQ0FBQ21DLElBQUksQ0FBQ1MsUUFBUSxDQUFDO01BQ3pDMUIsT0FBTyxDQUFDQyxHQUFHLENBQUMsRUFBRSxDQUFDO0lBQUM7RUFDcEI7RUFFTU8sYUFBYUEsQ0FBQSxFQUFHO0lBQUEsSUFBQWtJLE1BQUE7SUFBQSxPQUFBM0ksaUJBQUE7TUFDbEJDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLHVEQUF1RCxDQUFDO01BRXBFLE1BQU15QixRQUFRLEdBQUc7UUFDYkMsSUFBSSxFQUFFLGFBQWE7UUFDbkJDLFNBQVMsRUFBRTVELElBQUksQ0FBQ2tELEdBQUcsQ0FBQyxDQUFDO1FBQ3JCeUgsZ0JBQWdCLEVBQUUsQ0FBQztRQUNuQkMsWUFBWSxFQUFFLElBQUk7UUFDbEJySixPQUFPLEVBQUU7VUFDTHNKLGVBQWUsRUFBRSxDQUFDO1VBQ2xCQyxrQkFBa0IsRUFBRSxDQUFDO1VBQ3JCQyxxQkFBcUIsRUFBRSxDQUFDO1VBQ3hCQyxZQUFZLEVBQUU7UUFDbEIsQ0FBQztRQUNEMUosTUFBTSxFQUFFO01BQ1osQ0FBQztNQUVELElBQUk7UUFDQSxNQUFNMEMsUUFBUSxTQUFTMUUsUUFBUSxDQUFDMkUsVUFBVSxDQUFDO1VBQ3ZDQyxvQkFBb0IsRUFBRSxJQUFJO1VBQzFCQyxpQkFBaUIsRUFBRSxLQUFLO1VBQ3hCQyxlQUFlLEVBQUU7UUFDckIsQ0FBQyxDQUFDO1FBRUYsTUFBTUMsS0FBSyxTQUFTTCxRQUFRLENBQUNNLFdBQVcsQ0FBQztVQUNyQ0MsUUFBUSxFQUFFLE1BQU07VUFDaEJDLFNBQVMsRUFBRSxHQUFHO1VBQUU7VUFDaEJDLFFBQVEsRUFBRTtRQUNkLENBQUMsQ0FBQztRQUVGekMsT0FBTyxDQUFDQyxHQUFHLENBQUMsbURBQW1ELENBQUM7UUFFaEUsSUFBSWdKLGFBQWEsR0FBRyxFQUFFO1FBQ3RCLElBQUlDLFNBQVMsR0FBRyxFQUFFO1FBQ2xCLElBQUlDLFlBQVksR0FBRyxFQUFFO1FBRXJCLEtBQUssSUFBSUMsV0FBVyxHQUFHLEVBQUUsRUFBRUEsV0FBVyxJQUFJLEdBQUcsRUFBRUEsV0FBVyxJQUFJRixTQUFTLEVBQUU7VUFDckVsSixPQUFPLENBQUNDLEdBQUcsQ0FBQywwQkFBMEJtSixXQUFXLFlBQVksQ0FBQztVQUU5RCxJQUFJO1lBQ0E7WUFDQSxNQUFNQyxTQUFTLEdBQUcsRUFBRTtZQUNwQixNQUFNNUUsYUFBYSxHQUFHLEVBQUU7WUFFeEIsS0FBSyxJQUFJNUIsQ0FBQyxHQUFHb0csYUFBYSxDQUFDeEssTUFBTSxFQUFFb0UsQ0FBQyxHQUFHdUcsV0FBVyxFQUFFdkcsQ0FBQyxFQUFFLEVBQUU7Y0FDckQ0QixhQUFhLENBQUN4RCxJQUFJLENBQ2RvQixLQUFLLENBQUNVLEtBQUssQ0FBQztnQkFDUkMsSUFBSSxFQUFFLE9BQU87Z0JBQ2JyQixJQUFJLEVBQUUsZ0JBQWdCa0IsQ0FBQztjQUMzQixDQUFDLENBQUMsQ0FBQ0ksSUFBSSxDQUFDQyxLQUFLLElBQUk7Z0JBQ2JtRyxTQUFTLENBQUNwSSxJQUFJLENBQUNpQyxLQUFLLENBQUM7Z0JBQ3JCLE9BQU9BLEtBQUs7Y0FDaEIsQ0FBQyxDQUFDLENBQUNDLEtBQUssQ0FBQ3pDLEtBQUssSUFBSTtnQkFDZGdCLFFBQVEsQ0FBQ25DLE9BQU8sQ0FBQ3VKLGtCQUFrQixFQUFFO2dCQUNyQ3BILFFBQVEsQ0FBQ25DLE9BQU8sQ0FBQ3lKLFlBQVksQ0FBQy9ILElBQUksQ0FBQztrQkFDL0JtQyxLQUFLLEVBQUUsT0FBTztrQkFDZEYsS0FBSyxFQUFFTCxDQUFDO2tCQUNSbkMsS0FBSyxFQUFFQSxLQUFLLENBQUMyQztnQkFDakIsQ0FBQyxDQUFDO2dCQUNGLE9BQU8sSUFBSTtjQUNmLENBQUMsQ0FDTCxDQUFDO1lBQ0w7WUFFQSxNQUFNaUcsWUFBWSxTQUFTaEcsT0FBTyxDQUFDQyxHQUFHLENBQUNrQixhQUFhLENBQUM7WUFDckR3RSxhQUFhLENBQUNoSSxJQUFJLENBQUMsR0FBR3FJLFlBQVksQ0FBQ3hFLE1BQU0sQ0FBQzVCLEtBQUssSUFBSUEsS0FBSyxLQUFLLElBQUksQ0FBQyxDQUFDO1lBQ25FeEIsUUFBUSxDQUFDaUgsZ0JBQWdCLEdBQUdNLGFBQWEsQ0FBQ3hLLE1BQU07WUFFaER1QixPQUFPLENBQUNDLEdBQUcsQ0FBQyw2QkFBNkJnSixhQUFhLENBQUN4SyxNQUFNLFNBQVMsQ0FBQzs7WUFFdkU7WUFDQSxNQUFNa0YsWUFBWSxHQUFHc0YsYUFBYSxDQUFDckYsR0FBRyxDQUFDLENBQUNWLEtBQUssRUFBRUwsQ0FBQyxLQUFLO2NBQ2pELElBQUksQ0FBQ0ssS0FBSyxFQUFFLE9BQU9JLE9BQU8sQ0FBQ08sT0FBTyxDQUFDLENBQUM7Y0FFcEMsT0FBT1gsS0FBSyxDQUFDYSxPQUFPLENBQUM7Z0JBQ2pCQyxJQUFJLEVBQUUsb0JBQW9CbkIsQ0FBQyxxQkFBcUI7Z0JBQ2hEb0IsT0FBTyxFQUFFO2NBQ2IsQ0FBQyxDQUFDLENBQUNkLEtBQUssQ0FBQ3pDLEtBQUssSUFBSTtnQkFDZGdCLFFBQVEsQ0FBQ25DLE9BQU8sQ0FBQ3dKLHFCQUFxQixFQUFFO2dCQUN4Q3JILFFBQVEsQ0FBQ25DLE9BQU8sQ0FBQ3lKLFlBQVksQ0FBQy9ILElBQUksQ0FBQztrQkFDL0JtQyxLQUFLLEVBQUUsV0FBVztrQkFDbEJGLEtBQUssRUFBRUwsQ0FBQztrQkFDUm5DLEtBQUssRUFBRUEsS0FBSyxDQUFDMkM7Z0JBQ2pCLENBQUMsQ0FBQztjQUNOLENBQUMsQ0FBQztZQUNOLENBQUMsQ0FBQztZQUVGLE1BQU1DLE9BQU8sQ0FBQ2lHLFVBQVUsQ0FBQzVGLFlBQVksQ0FBQzs7WUFFdEM7WUFDQSxNQUFNN0MsUUFBUSxHQUFHMUMsT0FBTyxDQUFDMkMsV0FBVyxDQUFDLENBQUM7WUFDdEMsTUFBTXlJLFFBQVEsR0FBRzFJLFFBQVEsQ0FBQ0ssUUFBUSxHQUFHLElBQUksR0FBRyxJQUFJO1lBRWhEbkIsT0FBTyxDQUFDQyxHQUFHLENBQUMsc0JBQXNCdUosUUFBUSxDQUFDNUksT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7WUFDMURaLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLHdCQUF3QnlCLFFBQVEsQ0FBQ25DLE9BQU8sQ0FBQ3VKLGtCQUFrQixFQUFFLENBQUM7WUFDMUU5SSxPQUFPLENBQUNDLEdBQUcsQ0FBQyw0QkFBNEJ5QixRQUFRLENBQUNuQyxPQUFPLENBQUN3SixxQkFBcUIsRUFBRSxDQUFDOztZQUVqRjtZQUNBLElBQUlTLFFBQVEsR0FBRyxJQUFJLElBQUk5SCxRQUFRLENBQUNuQyxPQUFPLENBQUN1SixrQkFBa0IsR0FBRyxFQUFFLEVBQUU7Y0FDN0RwSCxRQUFRLENBQUNrSCxZQUFZLEdBQUc7Z0JBQ3BCYSxVQUFVLEVBQUVSLGFBQWEsQ0FBQ3hLLE1BQU07Z0JBQ2hDaUwsTUFBTSxFQUFFRixRQUFRO2dCQUNoQkcsTUFBTSxFQUFFSCxRQUFRLEdBQUcsSUFBSSxHQUFHLGNBQWMsR0FBRztjQUMvQyxDQUFDO2NBQ0R4SixPQUFPLENBQUNDLEdBQUcsQ0FBQyw2QkFBNkJ5QixRQUFRLENBQUNrSCxZQUFZLENBQUNlLE1BQU0sRUFBRSxDQUFDO2NBQ3hFO1lBQ0o7O1lBRUE7WUFDQVQsU0FBUyxHQUFHNUgsSUFBSSxDQUFDc0ksR0FBRyxDQUFDVixTQUFTLEdBQUcsQ0FBQyxFQUFFQyxZQUFZLENBQUM7VUFFckQsQ0FBQyxDQUFDLE9BQU96SSxLQUFLLEVBQUU7WUFDWmdCLFFBQVEsQ0FBQ2tILFlBQVksR0FBRztjQUNwQmEsVUFBVSxFQUFFUixhQUFhLENBQUN4SyxNQUFNO2NBQ2hDaUwsTUFBTSxFQUFFdEwsT0FBTyxDQUFDMkMsV0FBVyxDQUFDLENBQUMsQ0FBQ0ksUUFBUSxHQUFHLElBQUksR0FBRyxJQUFJO2NBQ3BEd0ksTUFBTSxFQUFFLGNBQWM7Y0FDdEJqSixLQUFLLEVBQUVBLEtBQUssQ0FBQzJDO1lBQ2pCLENBQUM7WUFDRHJELE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLHNCQUFzQmdKLGFBQWEsQ0FBQ3hLLE1BQU0sWUFBWWlDLEtBQUssQ0FBQzJDLE9BQU8sRUFBRSxDQUFDO1lBQ2xGO1VBQ0o7O1VBRUE7VUFDQSxNQUFNLElBQUlDLE9BQU8sQ0FBQ08sT0FBTyxJQUFJSyxVQUFVLENBQUNMLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztRQUMzRDtRQUVBbkMsUUFBUSxDQUFDbkMsT0FBTyxDQUFDc0osZUFBZSxHQUFHekssT0FBTyxDQUFDMkMsV0FBVyxDQUFDLENBQUMsQ0FBQ0ksUUFBUSxHQUFHLElBQUksR0FBRyxJQUFJO1FBQy9FTyxRQUFRLENBQUNwQyxNQUFNLEdBQUdvQyxRQUFRLENBQUNpSCxnQkFBZ0IsSUFBSSxFQUFFLENBQUMsQ0FBQzs7UUFFbkQzSSxPQUFPLENBQUNDLEdBQUcsQ0FBQyw4QkFBOEJ5QixRQUFRLENBQUNpSCxnQkFBZ0IsRUFBRSxDQUFDO1FBQ3RFM0ksT0FBTyxDQUFDQyxHQUFHLENBQUMsbUJBQW1CLEVBQUV5QixRQUFRLENBQUNrSCxZQUFZLElBQUksb0JBQW9CLENBQUM7UUFDL0U1SSxPQUFPLENBQUNDLEdBQUcsQ0FBQyxxQkFBcUJ5QixRQUFRLENBQUNuQyxPQUFPLENBQUNzSixlQUFlLENBQUNqSSxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztNQUVyRixDQUFDLENBQUMsT0FBT0YsS0FBSyxFQUFFO1FBQ1pnQixRQUFRLENBQUNoQixLQUFLLEdBQUdBLEtBQUssQ0FBQzJDLE9BQU87UUFDOUJyRCxPQUFPLENBQUNDLEdBQUcsQ0FBQyxnQkFBZ0JTLEtBQUssQ0FBQzJDLE9BQU8sRUFBRSxDQUFDO01BQ2hEO01BRUEzQixRQUFRLENBQUN5QyxRQUFRLEdBQUduRyxJQUFJLENBQUNrRCxHQUFHLENBQUMsQ0FBQyxHQUFHUSxRQUFRLENBQUNFLFNBQVM7TUFDbkQ4RyxNQUFJLENBQUM1SyxXQUFXLENBQUNnQixTQUFTLENBQUNtQyxJQUFJLENBQUNTLFFBQVEsQ0FBQztNQUN6QzFCLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLEVBQUUsQ0FBQztJQUFDO0VBQ3BCO0VBRUE4SCxlQUFlQSxDQUFDL0UsSUFBSSxFQUFFNkcsVUFBVSxFQUFFO0lBQzlCLE1BQU1DLFFBQVEsR0FBRztNQUNiQyxLQUFLLEVBQUUsQ0FDSDtRQUFFL0IsV0FBVyxFQUFFLG9CQUFvQjZCLFVBQVUsK0JBQStCO1FBQUU1RixPQUFPLEVBQUU7TUFBSyxDQUFDLEVBQzdGO1FBQUUrRCxXQUFXLEVBQUUsdUJBQXVCNkIsVUFBVSwyQkFBMkI7UUFBRTVGLE9BQU8sRUFBRTtNQUFNLENBQUMsRUFDN0Y7UUFBRStELFdBQVcsRUFBRSxjQUFjNkIsVUFBVSxvQkFBb0I7UUFBRTVGLE9BQU8sRUFBRTtNQUFNLENBQUMsQ0FDaEY7TUFDRCtGLFVBQVUsRUFBRSxDQUNSO1FBQUVoQyxXQUFXLEVBQUUsaUJBQWlCNkIsVUFBVSwyQkFBMkI7UUFBRTVGLE9BQU8sRUFBRTtNQUFNLENBQUMsRUFDdkY7UUFBRStELFdBQVcsRUFBRSxpQkFBaUI2QixVQUFVLGtCQUFrQjtRQUFFNUYsT0FBTyxFQUFFO01BQU0sQ0FBQyxDQUNqRjtNQUNEZ0csT0FBTyxFQUFFLENBQ0w7UUFBRWpDLFdBQVcsRUFBRSxpQkFBaUI2QixVQUFVLG1CQUFtQjtRQUFFNUYsT0FBTyxFQUFFO01BQU0sQ0FBQyxFQUMvRTtRQUFFK0QsV0FBVyxFQUFFLHdCQUF3QjZCLFVBQVUscUJBQXFCO1FBQUU1RixPQUFPLEVBQUU7TUFBSyxDQUFDLENBQzFGO01BQ0RpRyxTQUFTLEVBQUUsQ0FDUDtRQUFFbEMsV0FBVyxFQUFFLHFCQUFxQjZCLFVBQVUsb0JBQW9CO1FBQUU1RixPQUFPLEVBQUU7TUFBTSxDQUFDLEVBQ3BGO1FBQUUrRCxXQUFXLEVBQUUsb0JBQW9CNkIsVUFBVSx1QkFBdUI7UUFBRTVGLE9BQU8sRUFBRTtNQUFNLENBQUMsQ0FDekY7TUFDRGtHLFdBQVcsRUFBRSxDQUNUO1FBQUVuQyxXQUFXLEVBQUUscUJBQXFCNkIsVUFBVSxtQkFBbUI7UUFBRTVGLE9BQU8sRUFBRTtNQUFLLENBQUMsRUFDbEY7UUFBRStELFdBQVcsRUFBRSxtQkFBbUI2QixVQUFVLHVCQUF1QjtRQUFFNUYsT0FBTyxFQUFFO01BQUssQ0FBQztJQUU1RixDQUFDO0lBRUQsT0FBTzZGLFFBQVEsQ0FBQzlHLElBQUksQ0FBQyxJQUFJLENBQUM7TUFBRWdGLFdBQVcsRUFBRSxnQkFBZ0I2QixVQUFVLEVBQUU7TUFBRTVGLE9BQU8sRUFBRTtJQUFLLENBQUMsQ0FBQztFQUMzRjtFQUVNeEQsc0JBQXNCQSxDQUFBLEVBQUc7SUFBQSxJQUFBMkosTUFBQTtJQUFBLE9BQUFySyxpQkFBQTtNQUMzQkMsT0FBTyxDQUFDQyxHQUFHLENBQUMsbUNBQW1DLENBQUM7O01BRWhEO01BQ0EsTUFBTW9LLGVBQWUsR0FBR0QsTUFBSSxDQUFDdE0sV0FBVyxDQUFDZ0IsU0FBUyxDQUFDZ0csTUFBTSxDQUFDd0YsQ0FBQyxJQUFJQSxDQUFDLENBQUNoTCxNQUFNLENBQUMsQ0FBQ2IsTUFBTTtNQUMvRSxNQUFNOEwsY0FBYyxHQUFHSCxNQUFJLENBQUN0TSxXQUFXLENBQUNnQixTQUFTLENBQUNMLE1BQU07TUFFeEQyTCxNQUFJLENBQUN0TSxXQUFXLENBQUNpQixXQUFXLENBQUNFLGVBQWUsR0FBR21MLE1BQUksQ0FBQzdLLE9BQU8sQ0FBQ0MsYUFBYSxDQUFDZixNQUFNLEdBQUcsQ0FBQyxHQUM5RTZDLElBQUksQ0FBQzhELEtBQUssQ0FBQ2dGLE1BQUksQ0FBQzdLLE9BQU8sQ0FBQ0MsYUFBYSxDQUFDNkYsTUFBTSxDQUFDLENBQUNDLENBQUMsRUFBRUMsQ0FBQyxLQUFLRCxDQUFDLEdBQUdDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRzZFLE1BQUksQ0FBQzdLLE9BQU8sQ0FBQ0MsYUFBYSxDQUFDZixNQUFNLENBQUMsR0FDckcsQ0FBQztNQUVQMkwsTUFBSSxDQUFDdE0sV0FBVyxDQUFDaUIsV0FBVyxDQUFDSSxTQUFTLEdBQUdpTCxNQUFJLENBQUM3SyxPQUFPLENBQUNHLE1BQU0sQ0FBQ2pCLE1BQU0sR0FBRyxDQUFDLEdBQ2pFLENBQUUyTCxNQUFJLENBQUM3SyxPQUFPLENBQUNHLE1BQU0sQ0FBQ2pCLE1BQU0sSUFBSTJMLE1BQUksQ0FBQzdLLE9BQU8sQ0FBQ0MsYUFBYSxDQUFDZixNQUFNLEdBQUcyTCxNQUFJLENBQUM3SyxPQUFPLENBQUNHLE1BQU0sQ0FBQ2pCLE1BQU0sQ0FBQyxHQUFJLEdBQUcsRUFBRW1DLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FDbEgsQ0FBQztNQUVQd0osTUFBSSxDQUFDdE0sV0FBVyxDQUFDaUIsV0FBVyxDQUFDSyxVQUFVLEdBQUdnTCxNQUFJLENBQUN0TSxXQUFXLENBQUNpQixXQUFXLENBQUNLLFVBQVUsR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUM7O01BRWpHZ0wsTUFBSSxDQUFDdE0sV0FBVyxDQUFDd0IsTUFBTSxHQUFHK0ssZUFBZSxJQUFJLENBQUMsQ0FBQyxDQUFDOztNQUVoRCxNQUFNRyxNQUFNLEdBQUFDLGFBQUEsQ0FBQUEsYUFBQSxLQUNMTCxNQUFJLENBQUN0TSxXQUFXO1FBQ25CNE0sT0FBTyxFQUFFO1VBQ0xILGNBQWM7VUFDZEYsZUFBZTtVQUNmTSxlQUFlLEVBQUVKLGNBQWMsR0FBR0YsZUFBZTtVQUNqRE8sV0FBVyxFQUFFLENBQUVQLGVBQWUsR0FBR0UsY0FBYyxHQUFJLEdBQUcsRUFBRTNKLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHO1VBQ3hFaUssYUFBYSxFQUFFVCxNQUFJLENBQUN0TSxXQUFXLENBQUN3QjtRQUNwQztNQUFDLEVBQ0o7O01BRUQ7TUFDQSxNQUFNd0wsVUFBVSxHQUFHLCtEQUErRDtNQUNsRixNQUFNck4sRUFBRSxDQUFDc04sU0FBUyxDQUFDRCxVQUFVLEVBQUVFLElBQUksQ0FBQ0MsU0FBUyxDQUFDVCxNQUFNLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDOztNQUUvRDtNQUNBeEssT0FBTyxDQUFDQyxHQUFHLENBQUMsd0JBQXdCLENBQUM7TUFDckNELE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLHNCQUFzQixDQUFDO01BQ25DRCxPQUFPLENBQUNDLEdBQUcsQ0FBQyxxQkFBcUJvSyxlQUFlLElBQUlFLGNBQWMsS0FBS0MsTUFBTSxDQUFDRSxPQUFPLENBQUNFLFdBQVcsR0FBRyxDQUFDO01BQ3JHNUssT0FBTyxDQUFDQyxHQUFHLENBQUMsMEJBQTBCbUssTUFBSSxDQUFDdE0sV0FBVyxDQUFDaUIsV0FBVyxDQUFDQyxtQkFBbUIsRUFBRSxDQUFDO01BQ3pGZ0IsT0FBTyxDQUFDQyxHQUFHLENBQUMsMEJBQTBCbUssTUFBSSxDQUFDdE0sV0FBVyxDQUFDaUIsV0FBVyxDQUFDRSxlQUFlLElBQUksQ0FBQztNQUN2RmUsT0FBTyxDQUFDQyxHQUFHLENBQUMsZUFBZW1LLE1BQUksQ0FBQ3RNLFdBQVcsQ0FBQ2lCLFdBQVcsQ0FBQ0ksU0FBUyxHQUFHLENBQUM7TUFDckVhLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLHNCQUFzQm1LLE1BQUksQ0FBQ3RNLFdBQVcsQ0FBQ2lCLFdBQVcsQ0FBQ0ssVUFBVSxDQUFDd0IsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7TUFDekZaLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLG1CQUFtQm1LLE1BQUksQ0FBQ3RNLFdBQVcsQ0FBQ3dCLE1BQU0sR0FBRyxVQUFVLEdBQUcsVUFBVSxFQUFFLENBQUM7TUFFbkZVLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLHdCQUF3QixDQUFDO01BQ3JDbUssTUFBSSxDQUFDdE0sV0FBVyxDQUFDZ0IsU0FBUyxDQUFDc0osT0FBTyxDQUFDMUcsUUFBUSxJQUFJO1FBQzNDMUIsT0FBTyxDQUFDQyxHQUFHLENBQUMsTUFBTXlCLFFBQVEsQ0FBQ3BDLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJb0MsUUFBUSxDQUFDQyxJQUFJLEtBQUtELFFBQVEsQ0FBQ3lDLFFBQVEsS0FBSyxDQUFDO01BQzlGLENBQUMsQ0FBQztNQUVGbkUsT0FBTyxDQUFDQyxHQUFHLENBQUMsa0NBQWtDNkssVUFBVSxFQUFFLENBQUM7TUFFM0QsT0FBT04sTUFBTTtJQUFDO0VBQ2xCO0FBQ0o7O0FBRUE7QUFBQSxTQUNlM0ssWUFBWUEsQ0FBQTtFQUFBLE9BQUFxTCxhQUFBLENBQUE1RSxLQUFBLE9BQUFDLFNBQUE7QUFBQTtBQUFBLFNBQUEyRSxjQUFBO0VBQUFBLGFBQUEsR0FBQW5MLGlCQUFBLENBQTNCLGFBQThCO0lBQzFCLElBQUk7TUFDQSxNQUFNb0wsVUFBVSxHQUFHLElBQUl2TixnQkFBZ0IsQ0FBQyxDQUFDO01BQ3pDLE1BQU13TixPQUFPLFNBQVNELFVBQVUsQ0FBQ3RMLFlBQVksQ0FBQyxDQUFDO01BRS9DekIsT0FBTyxDQUFDaU4sSUFBSSxDQUFDRCxPQUFPLENBQUM5TCxNQUFNLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN4QyxDQUFDLENBQUMsT0FBT29CLEtBQUssRUFBRTtNQUNaVixPQUFPLENBQUNVLEtBQUssQ0FBQyx5QkFBeUIsRUFBRUEsS0FBSyxDQUFDO01BQy9DdEMsT0FBTyxDQUFDaU4sSUFBSSxDQUFDLENBQUMsQ0FBQztJQUNuQjtFQUNKLENBQUM7RUFBQSxPQUFBSCxhQUFBLENBQUE1RSxLQUFBLE9BQUFDLFNBQUE7QUFBQTtBQUVELElBQUloSixPQUFPLENBQUMrTixJQUFJLEtBQUtDLE1BQU0sRUFBRTtFQUN6QjFMLFlBQVksQ0FBQyxDQUFDO0FBQ2xCO0FBRUEwTCxNQUFNLENBQUNDLE9BQU8sR0FBRztFQUFFNU47QUFBaUIsQ0FBQyIsImlnbm9yZUxpc3QiOltdfQ==