b5322df8df675582986c5ed075e85843
// Mock dependencies
_getJestObj().mock('../../src/index-enhanced.js');
_getJestObj().mock('../../src/persistence.js');
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _getJestObj() {
  const {
    jest
  } = require("@jest/globals");
  _getJestObj = () => jest;
  return jest;
}
/**
 * MCP Tools Validation Edge Cases
 * Tests all boundary conditions and error scenarios for MCP tool validation
 */

import { describe, it, expect, jest, beforeEach, afterEach } from '@jest/globals';
import { EnhancedMCPTools } from '../../src/mcp-tools-enhanced.js';
import { RuvSwarm } from '../../src/index-enhanced.js';
describe('MCP Validation Edge Cases', () => {
  let mcpTools;
  let mockRuvSwarm;
  beforeEach(() => {
    mockRuvSwarm = {
      createSwarm: jest.fn(),
      detectFeatures: jest.fn(),
      benchmark: jest.fn()
    };
    RuvSwarm.initialize = jest.fn().mockResolvedValue(mockRuvSwarm);
    mcpTools = new EnhancedMCPTools();
  });
  afterEach(() => {
    jest.clearAllMocks();
  });
  describe('Iteration Validation Edge Cases', () => {
    it('should reject iterations at boundary values', /*#__PURE__*/_asyncToGenerator(function* () {
      yield mcpTools.initialize(mockRuvSwarm);

      // Test boundary values
      const boundaryValues = [{
        value: 0,
        shouldFail: true
      }, {
        value: 1,
        shouldFail: false
      }, {
        value: 1000,
        shouldFail: false
      }, {
        value: 1001,
        shouldFail: true
      }, {
        value: -1,
        shouldFail: true
      }, {
        value: null,
        shouldFail: true
      }, {
        value: undefined,
        shouldFail: true
      }, {
        value: NaN,
        shouldFail: true
      }, {
        value: Infinity,
        shouldFail: true
      }, {
        value: -Infinity,
        shouldFail: true
      }, {
        value: '10',
        shouldFail: true
      }, {
        value: [10],
        shouldFail: true
      }, {
        value: {
          iterations: 10
        },
        shouldFail: true
      }, {
        value: 1.5,
        shouldFail: false
      },
      // Should be floored to 1
      {
        value: 999.999,
        shouldFail: false
      } // Should be floored to 999
      ];
      for (const {
        value,
        shouldFail
      } of boundaryValues) {
        if (shouldFail) {
          yield expect(mcpTools.benchmark_run({
            iterations: value
          })).rejects.toThrow(/Iterations must be/);
        } else {
          // Should not throw
          mockRuvSwarm.benchmark.mockResolvedValue({
            results: []
          });
          yield mcpTools.benchmark_run({
            iterations: value
          });
        }
      }
    }));
    it('should handle floating point precision issues', /*#__PURE__*/_asyncToGenerator(function* () {
      yield mcpTools.initialize(mockRuvSwarm);
      mockRuvSwarm.benchmark.mockResolvedValue({
        results: []
      });

      // Floating point edge cases
      const floatCases = [0.999999999999999,
      // Just under 1
      1.000000000000001,
      // Just over 1
      999.999999999999,
      // Just under 1000
      1000.000000000001 // Just over 1000 (should fail)
      ];
      for (const value of floatCases) {
        if (value > 1000) {
          yield expect(mcpTools.benchmark_run({
            iterations: value
          })).rejects.toThrow();
        } else {
          yield mcpTools.benchmark_run({
            iterations: value
          });
        }
      }
    }));
  });
  describe('Learning Rate Validation Edge Cases', () => {
    it('should validate learning rate boundaries', /*#__PURE__*/_asyncToGenerator(function* () {
      yield mcpTools.initialize(mockRuvSwarm);
      const learningRateTests = [{
        value: 0,
        shouldFail: true
      }, {
        value: 0.000001,
        shouldFail: false
      }, {
        value: 0.5,
        shouldFail: false
      }, {
        value: 1,
        shouldFail: false
      }, {
        value: 1.000001,
        shouldFail: true
      }, {
        value: -0.1,
        shouldFail: true
      }, {
        value: Number.EPSILON,
        shouldFail: false
      }, {
        value: 1 - Number.EPSILON,
        shouldFail: false
      }];
      for (const {
        value,
        shouldFail
      } of learningRateTests) {
        const mockSwarm = {
          spawn: jest.fn().mockResolvedValue({
            id: 'agent-1',
            train: jest.fn().mockResolvedValue({
              loss: 0.1
            })
          })
        };
        mcpTools.activeSwarms.set('test-swarm', mockSwarm);
        if (shouldFail) {
          yield expect(mcpTools.neural_train({
            swarmId: 'test-swarm',
            learningRate: value
          })).rejects.toThrow(/Learning rate must be/);
        } else {
          yield mcpTools.neural_train({
            swarmId: 'test-swarm',
            learningRate: value
          });
        }
      }
    }));
  });
  describe('Model Type Validation Edge Cases', () => {
    it('should handle case sensitivity and whitespace in model types', /*#__PURE__*/_asyncToGenerator(function* () {
      yield mcpTools.initialize(mockRuvSwarm);
      const modelTypeTests = [{
        value: 'feedforward',
        shouldFail: false
      }, {
        value: 'FEEDFORWARD',
        shouldFail: true
      }, {
        value: 'FeedForward',
        shouldFail: true
      }, {
        value: ' feedforward ',
        shouldFail: true
      }, {
        value: 'feedforward\n',
        shouldFail: true
      }, {
        value: 'feed forward',
        shouldFail: true
      }, {
        value: '',
        shouldFail: true
      }, {
        value: null,
        shouldFail: true
      }, {
        value: undefined,
        shouldFail: true
      }, {
        value: 123,
        shouldFail: true
      }, {
        value: ['feedforward'],
        shouldFail: true
      }];
      for (const {
        value,
        shouldFail
      } of modelTypeTests) {
        const mockSwarm = {
          spawn: jest.fn().mockResolvedValue({
            id: 'agent-1',
            capabilities: ['neural']
          })
        };
        mcpTools.activeSwarms.set('test-swarm', mockSwarm);
        if (shouldFail) {
          yield expect(mcpTools.agent_spawn({
            swarmId: 'test-swarm',
            type: 'neural',
            modelType: value
          })).rejects.toThrow();
        } else {
          yield mcpTools.agent_spawn({
            swarmId: 'test-swarm',
            type: 'neural',
            modelType: value
          });
        }
      }
    }));
  });
  describe('Swarm ID Edge Cases', () => {
    it('should handle special characters in swarm IDs', /*#__PURE__*/_asyncToGenerator(function* () {
      yield mcpTools.initialize(mockRuvSwarm);
      const specialIds = ['swarm-with-dashes', 'swarm_with_underscores', 'swarm.with.dots', 'swarm/with/slashes', 'swarm\\with\\backslashes', 'swarm with spaces', 'swarm\twith\ttabs', 'swarm\nwith\nnewlines', 'üêùemoji-swarmüêù', 'swarm;drop table swarms;--', 'swarm<script>alert("xss")</script>', '',
      // Empty string
      '.',
      // Just a dot
      '..',
      // Two dots
      'a'.repeat(1000) // Very long ID
      ];
      mockRuvSwarm.createSwarm.mockResolvedValue({
        id: 'created-swarm',
        topology: 'mesh',
        agents: []
      });
      for (const id of specialIds) {
        // Should handle all IDs gracefully
        const result = yield mcpTools.swarm_init({
          swarmId: id,
          topology: 'mesh'
        });

        // Some IDs might be normalized or rejected
        expect(result).toBeDefined();
      }
    }));
  });
  describe('Concurrent Operation Edge Cases', () => {
    it('should handle race conditions in swarm initialization', /*#__PURE__*/_asyncToGenerator(function* () {
      yield mcpTools.initialize(mockRuvSwarm);
      let callCount = 0;
      mockRuvSwarm.createSwarm.mockImplementation(/*#__PURE__*/_asyncToGenerator(function* () {
        callCount++;
        // Simulate varying processing times
        yield new Promise(resolve => setTimeout(resolve, Math.random() * 100));
        return {
          id: `swarm-${callCount}`,
          topology: 'mesh',
          agents: []
        };
      }));

      // Create many swarms concurrently
      const promises = [];
      for (let i = 0; i < 50; i++) {
        promises.push(mcpTools.swarm_init({
          swarmId: `concurrent-${i}`,
          topology: 'mesh'
        }));
      }
      const results = yield Promise.allSettled(promises);
      const successful = results.filter(r => r.status === 'fulfilled');
      expect(successful.length).toBeGreaterThan(0);
      expect(mcpTools.activeSwarms.size).toBe(successful.length);
    }));
    it('should handle concurrent operations on the same swarm', /*#__PURE__*/_asyncToGenerator(function* () {
      yield mcpTools.initialize(mockRuvSwarm);
      const mockSwarm = {
        id: 'test-swarm',
        spawn: jest.fn().mockImplementation(/*#__PURE__*/_asyncToGenerator(function* () {
          // Simulate processing delay
          yield new Promise(resolve => setTimeout(resolve, 10));
          return {
            id: `agent-${Date.now()}`,
            type: 'researcher'
          };
        })),
        agents: []
      };
      mockRuvSwarm.createSwarm.mockResolvedValue(mockSwarm);
      yield mcpTools.swarm_init({
        topology: 'mesh'
      });

      // Spawn many agents concurrently on the same swarm
      const spawnPromises = [];
      for (let i = 0; i < 20; i++) {
        spawnPromises.push(mcpTools.agent_spawn({
          swarmId: mockSwarm.id,
          type: 'researcher'
        }));
      }
      const results = yield Promise.allSettled(spawnPromises);
      const successful = results.filter(r => r.status === 'fulfilled');
      expect(successful.length).toBe(20);
      expect(mockSwarm.spawn).toHaveBeenCalledTimes(20);
    }));
  });
  describe('Memory Pressure Edge Cases', () => {
    it('should handle memory limits when creating large swarms', /*#__PURE__*/_asyncToGenerator(function* () {
      yield mcpTools.initialize(mockRuvSwarm);
      mockRuvSwarm.createSwarm.mockImplementation(/*#__PURE__*/function () {
        var _ref1 = _asyncToGenerator(function* (config) {
          if (config.maxAgents > 100) {
            throw new Error('Memory limit exceeded');
          }
          return {
            id: 'swarm-1',
            topology: config.topology,
            maxAgents: config.maxAgents,
            agents: []
          };
        });
        return function (_x) {
          return _ref1.apply(this, arguments);
        };
      }());

      // Test various agent counts
      yield expect(mcpTools.swarm_init({
        topology: 'mesh',
        maxAgents: 1000
      })).rejects.toThrow(/Memory limit/);

      // Should succeed with reasonable limits
      const result = yield mcpTools.swarm_init({
        topology: 'mesh',
        maxAgents: 50
      });
      expect(result.maxAgents).toBe(50);
    }));
    it('should handle memory cleanup on failure', /*#__PURE__*/_asyncToGenerator(function* () {
      yield mcpTools.initialize(mockRuvSwarm);
      let swarmCount = 0;
      mockRuvSwarm.createSwarm.mockImplementation(/*#__PURE__*/_asyncToGenerator(function* () {
        swarmCount++;
        if (swarmCount > 5) {
          throw new Error('Resource exhausted');
        }
        return {
          id: `swarm-${swarmCount}`,
          topology: 'mesh',
          terminate: jest.fn()
        };
      }));

      // Create swarms until failure
      const promises = [];
      for (let i = 0; i < 10; i++) {
        promises.push(mcpTools.swarm_init({
          topology: 'mesh'
        }));
      }
      const results = yield Promise.allSettled(promises);
      const failed = results.filter(r => r.status === 'rejected');
      expect(failed.length).toBe(4); // Should fail after 5 successful
      expect(mcpTools.activeSwarms.size).toBeLessThanOrEqual(5);
    }));
  });
  describe('Input Sanitization Edge Cases', () => {
    it('should sanitize potentially malicious inputs', /*#__PURE__*/_asyncToGenerator(function* () {
      yield mcpTools.initialize(mockRuvSwarm);
      const maliciousInputs = [{
        task: '<script>alert("xss")</script>'
      }, {
        task: '"; DROP TABLE swarms; --'
      }, {
        task: '${process.exit(1)}'
      }, {
        task: '`rm -rf /`'
      }, {
        task: '../../../etc/passwd'
      }, {
        task: 'file:///etc/passwd'
      }, {
        task: String.fromCharCode(0)
      },
      // Null character
      {
        task: '\x00\x01\x02\x03'
      } // Control characters
      ];
      const mockSwarm = {
        orchestrate: jest.fn().mockResolvedValue({
          id: 'task-1',
          status: 'completed'
        })
      };
      mcpTools.activeSwarms.set('test-swarm', mockSwarm);
      for (const input of maliciousInputs) {
        // Should sanitize and not throw
        const result = yield mcpTools.task_orchestrate(_objectSpread({
          swarmId: 'test-swarm'
        }, input));
        expect(result).toBeDefined();
        expect(result.status).toBe('completed');
      }
    }));
  });
  describe('Network and Timeout Edge Cases', () => {
    it('should handle network timeouts gracefully', /*#__PURE__*/_asyncToGenerator(function* () {
      yield mcpTools.initialize(mockRuvSwarm);
      const mockSwarm = {
        monitor: jest.fn().mockImplementation(/*#__PURE__*/_asyncToGenerator(function* () {
          // Simulate long network delay
          yield new Promise(resolve => setTimeout(resolve, 5000));
          return {
            status: 'timeout'
          };
        }))
      };
      mcpTools.activeSwarms.set('test-swarm', mockSwarm);

      // Set a shorter timeout for the test
      const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Operation timeout')), 100));
      yield expect(Promise.race([mcpTools.swarm_monitor({
        swarmId: 'test-swarm'
      }), timeoutPromise])).rejects.toThrow(/timeout/i);
    }));
  });
  describe('State Consistency Edge Cases', () => {
    it('should maintain consistency during rapid state changes', /*#__PURE__*/_asyncToGenerator(function* () {
      yield mcpTools.initialize(mockRuvSwarm);
      const mockSwarm = {
        id: 'test-swarm',
        reconfigure: jest.fn().mockResolvedValue(true),
        getStatus: jest.fn().mockReturnValue({
          topology: 'mesh'
        })
      };
      mockRuvSwarm.createSwarm.mockResolvedValue(mockSwarm);
      yield mcpTools.swarm_init({
        topology: 'mesh'
      });

      // Rapid topology changes
      const topologies = ['star', 'ring', 'hierarchical', 'mesh'];
      const promises = [];
      for (let i = 0; i < 100; i++) {
        const topology = topologies[i % topologies.length];
        promises.push(mcpTools.swarm_reconfigure({
          swarmId: 'test-swarm',
          topology
        }).catch(() => null) // Ignore errors
        );
      }
      yield Promise.all(promises);

      // Check final state is consistent
      const status = yield mcpTools.swarm_status({
        swarmId: 'test-swarm'
      });
      expect(status).toBeDefined();
      expect(topologies).toContain(status.topology);
    }));
  });
});

// Run tests when executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  console.log('Running MCP validation edge case tests...');

  // Run all tests
  const {
    run
  } = await import('../test-runner.js');
  await run(__filename);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfZ2V0SmVzdE9iaiIsIm1vY2siLCJvd25LZXlzIiwiZSIsInIiLCJ0IiwiT2JqZWN0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsIm8iLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsImFyZ3VtZW50cyIsImxlbmd0aCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImRlZmluZVByb3BlcnR5IiwiX3RvUHJvcGVydHlLZXkiLCJ2YWx1ZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiaSIsIl90b1ByaW1pdGl2ZSIsIlN5bWJvbCIsInRvUHJpbWl0aXZlIiwiY2FsbCIsIlR5cGVFcnJvciIsIlN0cmluZyIsIk51bWJlciIsImFzeW5jR2VuZXJhdG9yU3RlcCIsIm4iLCJhIiwiYyIsInUiLCJkb25lIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJfbmV4dCIsIl90aHJvdyIsImplc3QiLCJyZXF1aXJlIiwiZGVzY3JpYmUiLCJpdCIsImV4cGVjdCIsImJlZm9yZUVhY2giLCJhZnRlckVhY2giLCJFbmhhbmNlZE1DUFRvb2xzIiwiUnV2U3dhcm0iLCJtY3BUb29scyIsIm1vY2tSdXZTd2FybSIsImNyZWF0ZVN3YXJtIiwiZm4iLCJkZXRlY3RGZWF0dXJlcyIsImJlbmNobWFyayIsImluaXRpYWxpemUiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsImNsZWFyQWxsTW9ja3MiLCJib3VuZGFyeVZhbHVlcyIsInNob3VsZEZhaWwiLCJ1bmRlZmluZWQiLCJOYU4iLCJJbmZpbml0eSIsIml0ZXJhdGlvbnMiLCJiZW5jaG1hcmtfcnVuIiwicmVqZWN0cyIsInRvVGhyb3ciLCJyZXN1bHRzIiwiZmxvYXRDYXNlcyIsImxlYXJuaW5nUmF0ZVRlc3RzIiwiRVBTSUxPTiIsIm1vY2tTd2FybSIsInNwYXduIiwiaWQiLCJ0cmFpbiIsImxvc3MiLCJhY3RpdmVTd2FybXMiLCJzZXQiLCJuZXVyYWxfdHJhaW4iLCJzd2FybUlkIiwibGVhcm5pbmdSYXRlIiwibW9kZWxUeXBlVGVzdHMiLCJjYXBhYmlsaXRpZXMiLCJhZ2VudF9zcGF3biIsInR5cGUiLCJtb2RlbFR5cGUiLCJzcGVjaWFsSWRzIiwicmVwZWF0IiwidG9wb2xvZ3kiLCJhZ2VudHMiLCJyZXN1bHQiLCJzd2FybV9pbml0IiwidG9CZURlZmluZWQiLCJjYWxsQ291bnQiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJzZXRUaW1lb3V0IiwiTWF0aCIsInJhbmRvbSIsInByb21pc2VzIiwiYWxsU2V0dGxlZCIsInN1Y2Nlc3NmdWwiLCJzdGF0dXMiLCJ0b0JlR3JlYXRlclRoYW4iLCJzaXplIiwidG9CZSIsIkRhdGUiLCJub3ciLCJzcGF3blByb21pc2VzIiwidG9IYXZlQmVlbkNhbGxlZFRpbWVzIiwiX3JlZjEiLCJjb25maWciLCJtYXhBZ2VudHMiLCJFcnJvciIsIl94Iiwic3dhcm1Db3VudCIsInRlcm1pbmF0ZSIsImZhaWxlZCIsInRvQmVMZXNzVGhhbk9yRXF1YWwiLCJtYWxpY2lvdXNJbnB1dHMiLCJ0YXNrIiwiZnJvbUNoYXJDb2RlIiwib3JjaGVzdHJhdGUiLCJpbnB1dCIsInRhc2tfb3JjaGVzdHJhdGUiLCJtb25pdG9yIiwidGltZW91dFByb21pc2UiLCJfIiwicmVqZWN0IiwicmFjZSIsInN3YXJtX21vbml0b3IiLCJyZWNvbmZpZ3VyZSIsImdldFN0YXR1cyIsIm1vY2tSZXR1cm5WYWx1ZSIsInRvcG9sb2dpZXMiLCJzd2FybV9yZWNvbmZpZ3VyZSIsImNhdGNoIiwiYWxsIiwic3dhcm1fc3RhdHVzIiwidG9Db250YWluIiwiaW1wb3J0IiwibWV0YSIsInVybCIsInByb2Nlc3MiLCJhcmd2IiwiY29uc29sZSIsImxvZyIsInJ1biIsIl9fZmlsZW5hbWUiXSwic291cmNlcyI6WyJtY3AtdmFsaWRhdGlvbi1lZGdlLWNhc2VzLnRlc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNQ1AgVG9vbHMgVmFsaWRhdGlvbiBFZGdlIENhc2VzXG4gKiBUZXN0cyBhbGwgYm91bmRhcnkgY29uZGl0aW9ucyBhbmQgZXJyb3Igc2NlbmFyaW9zIGZvciBNQ1AgdG9vbCB2YWxpZGF0aW9uXG4gKi9cblxuaW1wb3J0IHsgZGVzY3JpYmUsIGl0LCBleHBlY3QsIGplc3QsIGJlZm9yZUVhY2gsIGFmdGVyRWFjaCB9IGZyb20gJ0BqZXN0L2dsb2JhbHMnO1xuaW1wb3J0IHsgRW5oYW5jZWRNQ1BUb29scyB9IGZyb20gJy4uLy4uL3NyYy9tY3AtdG9vbHMtZW5oYW5jZWQuanMnO1xuaW1wb3J0IHsgUnV2U3dhcm0gfSBmcm9tICcuLi8uLi9zcmMvaW5kZXgtZW5oYW5jZWQuanMnO1xuXG4vLyBNb2NrIGRlcGVuZGVuY2llc1xuamVzdC5tb2NrKCcuLi8uLi9zcmMvaW5kZXgtZW5oYW5jZWQuanMnKTtcbmplc3QubW9jaygnLi4vLi4vc3JjL3BlcnNpc3RlbmNlLmpzJyk7XG5cbmRlc2NyaWJlKCdNQ1AgVmFsaWRhdGlvbiBFZGdlIENhc2VzJywgKCkgPT4ge1xuICBsZXQgbWNwVG9vbHM7XG4gIGxldCBtb2NrUnV2U3dhcm07XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgbW9ja1J1dlN3YXJtID0ge1xuICAgICAgY3JlYXRlU3dhcm06IGplc3QuZm4oKSxcbiAgICAgIGRldGVjdEZlYXR1cmVzOiBqZXN0LmZuKCksXG4gICAgICBiZW5jaG1hcms6IGplc3QuZm4oKSxcbiAgICB9O1xuICAgIFJ1dlN3YXJtLmluaXRpYWxpemUgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUobW9ja1J1dlN3YXJtKTtcbiAgICBtY3BUb29scyA9IG5ldyBFbmhhbmNlZE1DUFRvb2xzKCk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdJdGVyYXRpb24gVmFsaWRhdGlvbiBFZGdlIENhc2VzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmVqZWN0IGl0ZXJhdGlvbnMgYXQgYm91bmRhcnkgdmFsdWVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgbWNwVG9vbHMuaW5pdGlhbGl6ZShtb2NrUnV2U3dhcm0pO1xuXG4gICAgICAvLyBUZXN0IGJvdW5kYXJ5IHZhbHVlc1xuICAgICAgY29uc3QgYm91bmRhcnlWYWx1ZXMgPSBbXG4gICAgICAgIHsgdmFsdWU6IDAsIHNob3VsZEZhaWw6IHRydWUgfSxcbiAgICAgICAgeyB2YWx1ZTogMSwgc2hvdWxkRmFpbDogZmFsc2UgfSxcbiAgICAgICAgeyB2YWx1ZTogMTAwMCwgc2hvdWxkRmFpbDogZmFsc2UgfSxcbiAgICAgICAgeyB2YWx1ZTogMTAwMSwgc2hvdWxkRmFpbDogdHJ1ZSB9LFxuICAgICAgICB7IHZhbHVlOiAtMSwgc2hvdWxkRmFpbDogdHJ1ZSB9LFxuICAgICAgICB7IHZhbHVlOiBudWxsLCBzaG91bGRGYWlsOiB0cnVlIH0sXG4gICAgICAgIHsgdmFsdWU6IHVuZGVmaW5lZCwgc2hvdWxkRmFpbDogdHJ1ZSB9LFxuICAgICAgICB7IHZhbHVlOiBOYU4sIHNob3VsZEZhaWw6IHRydWUgfSxcbiAgICAgICAgeyB2YWx1ZTogSW5maW5pdHksIHNob3VsZEZhaWw6IHRydWUgfSxcbiAgICAgICAgeyB2YWx1ZTogLUluZmluaXR5LCBzaG91bGRGYWlsOiB0cnVlIH0sXG4gICAgICAgIHsgdmFsdWU6ICcxMCcsIHNob3VsZEZhaWw6IHRydWUgfSxcbiAgICAgICAgeyB2YWx1ZTogWzEwXSwgc2hvdWxkRmFpbDogdHJ1ZSB9LFxuICAgICAgICB7IHZhbHVlOiB7IGl0ZXJhdGlvbnM6IDEwIH0sIHNob3VsZEZhaWw6IHRydWUgfSxcbiAgICAgICAgeyB2YWx1ZTogMS41LCBzaG91bGRGYWlsOiBmYWxzZSB9LCAvLyBTaG91bGQgYmUgZmxvb3JlZCB0byAxXG4gICAgICAgIHsgdmFsdWU6IDk5OS45OTksIHNob3VsZEZhaWw6IGZhbHNlIH0sIC8vIFNob3VsZCBiZSBmbG9vcmVkIHRvIDk5OVxuICAgICAgXTtcblxuICAgICAgZm9yIChjb25zdCB7IHZhbHVlLCBzaG91bGRGYWlsIH0gb2YgYm91bmRhcnlWYWx1ZXMpIHtcbiAgICAgICAgaWYgKHNob3VsZEZhaWwpIHtcbiAgICAgICAgICBhd2FpdCBleHBlY3QoXG4gICAgICAgICAgICBtY3BUb29scy5iZW5jaG1hcmtfcnVuKHsgaXRlcmF0aW9uczogdmFsdWUgfSlcbiAgICAgICAgICApLnJlamVjdHMudG9UaHJvdygvSXRlcmF0aW9ucyBtdXN0IGJlLyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2hvdWxkIG5vdCB0aHJvd1xuICAgICAgICAgIG1vY2tSdXZTd2FybS5iZW5jaG1hcmsubW9ja1Jlc29sdmVkVmFsdWUoeyByZXN1bHRzOiBbXSB9KTtcbiAgICAgICAgICBhd2FpdCBtY3BUb29scy5iZW5jaG1hcmtfcnVuKHsgaXRlcmF0aW9uczogdmFsdWUgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbiBpc3N1ZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBtY3BUb29scy5pbml0aWFsaXplKG1vY2tSdXZTd2FybSk7XG4gICAgICBtb2NrUnV2U3dhcm0uYmVuY2htYXJrLm1vY2tSZXNvbHZlZFZhbHVlKHsgcmVzdWx0czogW10gfSk7XG5cbiAgICAgIC8vIEZsb2F0aW5nIHBvaW50IGVkZ2UgY2FzZXNcbiAgICAgIGNvbnN0IGZsb2F0Q2FzZXMgPSBbXG4gICAgICAgIDAuOTk5OTk5OTk5OTk5OTk5LCAgLy8gSnVzdCB1bmRlciAxXG4gICAgICAgIDEuMDAwMDAwMDAwMDAwMDAxLCAgLy8gSnVzdCBvdmVyIDFcbiAgICAgICAgOTk5Ljk5OTk5OTk5OTk5OSwgICAvLyBKdXN0IHVuZGVyIDEwMDBcbiAgICAgICAgMTAwMC4wMDAwMDAwMDAwMDEsICAvLyBKdXN0IG92ZXIgMTAwMCAoc2hvdWxkIGZhaWwpXG4gICAgICBdO1xuXG4gICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGZsb2F0Q2FzZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlID4gMTAwMCkge1xuICAgICAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgICAgIG1jcFRvb2xzLmJlbmNobWFya19ydW4oeyBpdGVyYXRpb25zOiB2YWx1ZSB9KVxuICAgICAgICAgICkucmVqZWN0cy50b1Rocm93KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXdhaXQgbWNwVG9vbHMuYmVuY2htYXJrX3J1bih7IGl0ZXJhdGlvbnM6IHZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdMZWFybmluZyBSYXRlIFZhbGlkYXRpb24gRWRnZSBDYXNlcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIGxlYXJuaW5nIHJhdGUgYm91bmRhcmllcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IG1jcFRvb2xzLmluaXRpYWxpemUobW9ja1J1dlN3YXJtKTtcblxuICAgICAgY29uc3QgbGVhcm5pbmdSYXRlVGVzdHMgPSBbXG4gICAgICAgIHsgdmFsdWU6IDAsIHNob3VsZEZhaWw6IHRydWUgfSxcbiAgICAgICAgeyB2YWx1ZTogMC4wMDAwMDEsIHNob3VsZEZhaWw6IGZhbHNlIH0sXG4gICAgICAgIHsgdmFsdWU6IDAuNSwgc2hvdWxkRmFpbDogZmFsc2UgfSxcbiAgICAgICAgeyB2YWx1ZTogMSwgc2hvdWxkRmFpbDogZmFsc2UgfSxcbiAgICAgICAgeyB2YWx1ZTogMS4wMDAwMDEsIHNob3VsZEZhaWw6IHRydWUgfSxcbiAgICAgICAgeyB2YWx1ZTogLTAuMSwgc2hvdWxkRmFpbDogdHJ1ZSB9LFxuICAgICAgICB7IHZhbHVlOiBOdW1iZXIuRVBTSUxPTiwgc2hvdWxkRmFpbDogZmFsc2UgfSxcbiAgICAgICAgeyB2YWx1ZTogMSAtIE51bWJlci5FUFNJTE9OLCBzaG91bGRGYWlsOiBmYWxzZSB9LFxuICAgICAgXTtcblxuICAgICAgZm9yIChjb25zdCB7IHZhbHVlLCBzaG91bGRGYWlsIH0gb2YgbGVhcm5pbmdSYXRlVGVzdHMpIHtcbiAgICAgICAgY29uc3QgbW9ja1N3YXJtID0ge1xuICAgICAgICAgIHNwYXduOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgaWQ6ICdhZ2VudC0xJyxcbiAgICAgICAgICAgIHRyYWluOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBsb3NzOiAwLjEgfSksXG4gICAgICAgICAgfSksXG4gICAgICAgIH07XG4gICAgICAgIG1jcFRvb2xzLmFjdGl2ZVN3YXJtcy5zZXQoJ3Rlc3Qtc3dhcm0nLCBtb2NrU3dhcm0pO1xuXG4gICAgICAgIGlmIChzaG91bGRGYWlsKSB7XG4gICAgICAgICAgYXdhaXQgZXhwZWN0KFxuICAgICAgICAgICAgbWNwVG9vbHMubmV1cmFsX3RyYWluKHsgXG4gICAgICAgICAgICAgIHN3YXJtSWQ6ICd0ZXN0LXN3YXJtJyxcbiAgICAgICAgICAgICAgbGVhcm5pbmdSYXRlOiB2YWx1ZSBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKS5yZWplY3RzLnRvVGhyb3coL0xlYXJuaW5nIHJhdGUgbXVzdCBiZS8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF3YWl0IG1jcFRvb2xzLm5ldXJhbF90cmFpbih7IFxuICAgICAgICAgICAgc3dhcm1JZDogJ3Rlc3Qtc3dhcm0nLFxuICAgICAgICAgICAgbGVhcm5pbmdSYXRlOiB2YWx1ZSBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnTW9kZWwgVHlwZSBWYWxpZGF0aW9uIEVkZ2UgQ2FzZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY2FzZSBzZW5zaXRpdml0eSBhbmQgd2hpdGVzcGFjZSBpbiBtb2RlbCB0eXBlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IG1jcFRvb2xzLmluaXRpYWxpemUobW9ja1J1dlN3YXJtKTtcblxuICAgICAgY29uc3QgbW9kZWxUeXBlVGVzdHMgPSBbXG4gICAgICAgIHsgdmFsdWU6ICdmZWVkZm9yd2FyZCcsIHNob3VsZEZhaWw6IGZhbHNlIH0sXG4gICAgICAgIHsgdmFsdWU6ICdGRUVERk9SV0FSRCcsIHNob3VsZEZhaWw6IHRydWUgfSxcbiAgICAgICAgeyB2YWx1ZTogJ0ZlZWRGb3J3YXJkJywgc2hvdWxkRmFpbDogdHJ1ZSB9LFxuICAgICAgICB7IHZhbHVlOiAnIGZlZWRmb3J3YXJkICcsIHNob3VsZEZhaWw6IHRydWUgfSxcbiAgICAgICAgeyB2YWx1ZTogJ2ZlZWRmb3J3YXJkXFxuJywgc2hvdWxkRmFpbDogdHJ1ZSB9LFxuICAgICAgICB7IHZhbHVlOiAnZmVlZCBmb3J3YXJkJywgc2hvdWxkRmFpbDogdHJ1ZSB9LFxuICAgICAgICB7IHZhbHVlOiAnJywgc2hvdWxkRmFpbDogdHJ1ZSB9LFxuICAgICAgICB7IHZhbHVlOiBudWxsLCBzaG91bGRGYWlsOiB0cnVlIH0sXG4gICAgICAgIHsgdmFsdWU6IHVuZGVmaW5lZCwgc2hvdWxkRmFpbDogdHJ1ZSB9LFxuICAgICAgICB7IHZhbHVlOiAxMjMsIHNob3VsZEZhaWw6IHRydWUgfSxcbiAgICAgICAgeyB2YWx1ZTogWydmZWVkZm9yd2FyZCddLCBzaG91bGRGYWlsOiB0cnVlIH0sXG4gICAgICBdO1xuXG4gICAgICBmb3IgKGNvbnN0IHsgdmFsdWUsIHNob3VsZEZhaWwgfSBvZiBtb2RlbFR5cGVUZXN0cykge1xuICAgICAgICBjb25zdCBtb2NrU3dhcm0gPSB7XG4gICAgICAgICAgc3Bhd246IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICBpZDogJ2FnZW50LTEnLFxuICAgICAgICAgICAgY2FwYWJpbGl0aWVzOiBbJ25ldXJhbCddLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgICAgICBtY3BUb29scy5hY3RpdmVTd2FybXMuc2V0KCd0ZXN0LXN3YXJtJywgbW9ja1N3YXJtKTtcblxuICAgICAgICBpZiAoc2hvdWxkRmFpbCkge1xuICAgICAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgICAgIG1jcFRvb2xzLmFnZW50X3NwYXduKHtcbiAgICAgICAgICAgICAgc3dhcm1JZDogJ3Rlc3Qtc3dhcm0nLFxuICAgICAgICAgICAgICB0eXBlOiAnbmV1cmFsJyxcbiAgICAgICAgICAgICAgbW9kZWxUeXBlOiB2YWx1ZSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKS5yZWplY3RzLnRvVGhyb3coKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhd2FpdCBtY3BUb29scy5hZ2VudF9zcGF3bih7XG4gICAgICAgICAgICBzd2FybUlkOiAndGVzdC1zd2FybScsXG4gICAgICAgICAgICB0eXBlOiAnbmV1cmFsJyxcbiAgICAgICAgICAgIG1vZGVsVHlwZTogdmFsdWUsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1N3YXJtIElEIEVkZ2UgQ2FzZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgc3BlY2lhbCBjaGFyYWN0ZXJzIGluIHN3YXJtIElEcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IG1jcFRvb2xzLmluaXRpYWxpemUobW9ja1J1dlN3YXJtKTtcblxuICAgICAgY29uc3Qgc3BlY2lhbElkcyA9IFtcbiAgICAgICAgJ3N3YXJtLXdpdGgtZGFzaGVzJyxcbiAgICAgICAgJ3N3YXJtX3dpdGhfdW5kZXJzY29yZXMnLFxuICAgICAgICAnc3dhcm0ud2l0aC5kb3RzJyxcbiAgICAgICAgJ3N3YXJtL3dpdGgvc2xhc2hlcycsXG4gICAgICAgICdzd2FybVxcXFx3aXRoXFxcXGJhY2tzbGFzaGVzJyxcbiAgICAgICAgJ3N3YXJtIHdpdGggc3BhY2VzJyxcbiAgICAgICAgJ3N3YXJtXFx0d2l0aFxcdHRhYnMnLFxuICAgICAgICAnc3dhcm1cXG53aXRoXFxubmV3bGluZXMnLFxuICAgICAgICAn8J+QnWVtb2ppLXN3YXJt8J+QnScsXG4gICAgICAgICdzd2FybTtkcm9wIHRhYmxlIHN3YXJtczstLScsXG4gICAgICAgICdzd2FybTxzY3JpcHQ+YWxlcnQoXCJ4c3NcIik8L3NjcmlwdD4nLFxuICAgICAgICAnJywgIC8vIEVtcHR5IHN0cmluZ1xuICAgICAgICAnLicsICAvLyBKdXN0IGEgZG90XG4gICAgICAgICcuLicsICAvLyBUd28gZG90c1xuICAgICAgICAnYScucmVwZWF0KDEwMDApLCAgLy8gVmVyeSBsb25nIElEXG4gICAgICBdO1xuXG4gICAgICBtb2NrUnV2U3dhcm0uY3JlYXRlU3dhcm0ubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBpZDogJ2NyZWF0ZWQtc3dhcm0nLFxuICAgICAgICB0b3BvbG9neTogJ21lc2gnLFxuICAgICAgICBhZ2VudHM6IFtdLFxuICAgICAgfSk7XG5cbiAgICAgIGZvciAoY29uc3QgaWQgb2Ygc3BlY2lhbElkcykge1xuICAgICAgICAvLyBTaG91bGQgaGFuZGxlIGFsbCBJRHMgZ3JhY2VmdWxseVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtY3BUb29scy5zd2FybV9pbml0KHtcbiAgICAgICAgICBzd2FybUlkOiBpZCxcbiAgICAgICAgICB0b3BvbG9neTogJ21lc2gnLFxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNvbWUgSURzIG1pZ2h0IGJlIG5vcm1hbGl6ZWQgb3IgcmVqZWN0ZWRcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZURlZmluZWQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NvbmN1cnJlbnQgT3BlcmF0aW9uIEVkZ2UgQ2FzZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgcmFjZSBjb25kaXRpb25zIGluIHN3YXJtIGluaXRpYWxpemF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgbWNwVG9vbHMuaW5pdGlhbGl6ZShtb2NrUnV2U3dhcm0pO1xuXG4gICAgICBsZXQgY2FsbENvdW50ID0gMDtcbiAgICAgIG1vY2tSdXZTd2FybS5jcmVhdGVTd2FybS5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgICBjYWxsQ291bnQrKztcbiAgICAgICAgLy8gU2ltdWxhdGUgdmFyeWluZyBwcm9jZXNzaW5nIHRpbWVzXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBNYXRoLnJhbmRvbSgpICogMTAwKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6IGBzd2FybS0ke2NhbGxDb3VudH1gLFxuICAgICAgICAgIHRvcG9sb2d5OiAnbWVzaCcsXG4gICAgICAgICAgYWdlbnRzOiBbXSxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBDcmVhdGUgbWFueSBzd2FybXMgY29uY3VycmVudGx5XG4gICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1MDsgaSsrKSB7XG4gICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgbWNwVG9vbHMuc3dhcm1faW5pdCh7XG4gICAgICAgICAgICBzd2FybUlkOiBgY29uY3VycmVudC0ke2l9YCxcbiAgICAgICAgICAgIHRvcG9sb2d5OiAnbWVzaCcsXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChwcm9taXNlcyk7XG4gICAgICBjb25zdCBzdWNjZXNzZnVsID0gcmVzdWx0cy5maWx0ZXIociA9PiByLnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcpO1xuICAgICAgXG4gICAgICBleHBlY3Qoc3VjY2Vzc2Z1bC5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIGV4cGVjdChtY3BUb29scy5hY3RpdmVTd2FybXMuc2l6ZSkudG9CZShzdWNjZXNzZnVsLmxlbmd0aCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb25jdXJyZW50IG9wZXJhdGlvbnMgb24gdGhlIHNhbWUgc3dhcm0nLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBtY3BUb29scy5pbml0aWFsaXplKG1vY2tSdXZTd2FybSk7XG5cbiAgICAgIGNvbnN0IG1vY2tTd2FybSA9IHtcbiAgICAgICAgaWQ6ICd0ZXN0LXN3YXJtJyxcbiAgICAgICAgc3Bhd246IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIC8vIFNpbXVsYXRlIHByb2Nlc3NpbmcgZGVsYXlcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTApKTtcbiAgICAgICAgICByZXR1cm4geyBpZDogYGFnZW50LSR7RGF0ZS5ub3coKX1gLCB0eXBlOiAncmVzZWFyY2hlcicgfTtcbiAgICAgICAgfSksXG4gICAgICAgIGFnZW50czogW10sXG4gICAgICB9O1xuXG4gICAgICBtb2NrUnV2U3dhcm0uY3JlYXRlU3dhcm0ubW9ja1Jlc29sdmVkVmFsdWUobW9ja1N3YXJtKTtcbiAgICAgIGF3YWl0IG1jcFRvb2xzLnN3YXJtX2luaXQoeyB0b3BvbG9neTogJ21lc2gnIH0pO1xuXG4gICAgICAvLyBTcGF3biBtYW55IGFnZW50cyBjb25jdXJyZW50bHkgb24gdGhlIHNhbWUgc3dhcm1cbiAgICAgIGNvbnN0IHNwYXduUHJvbWlzZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjA7IGkrKykge1xuICAgICAgICBzcGF3blByb21pc2VzLnB1c2goXG4gICAgICAgICAgbWNwVG9vbHMuYWdlbnRfc3Bhd24oe1xuICAgICAgICAgICAgc3dhcm1JZDogbW9ja1N3YXJtLmlkLFxuICAgICAgICAgICAgdHlwZTogJ3Jlc2VhcmNoZXInLFxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoc3Bhd25Qcm9taXNlcyk7XG4gICAgICBjb25zdCBzdWNjZXNzZnVsID0gcmVzdWx0cy5maWx0ZXIociA9PiByLnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcpO1xuICAgICAgXG4gICAgICBleHBlY3Qoc3VjY2Vzc2Z1bC5sZW5ndGgpLnRvQmUoMjApO1xuICAgICAgZXhwZWN0KG1vY2tTd2FybS5zcGF3bikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ01lbW9yeSBQcmVzc3VyZSBFZGdlIENhc2VzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIG1lbW9yeSBsaW1pdHMgd2hlbiBjcmVhdGluZyBsYXJnZSBzd2FybXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBtY3BUb29scy5pbml0aWFsaXplKG1vY2tSdXZTd2FybSk7XG5cbiAgICAgIG1vY2tSdXZTd2FybS5jcmVhdGVTd2FybS5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKGNvbmZpZykgPT4ge1xuICAgICAgICBpZiAoY29uZmlnLm1heEFnZW50cyA+IDEwMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWVtb3J5IGxpbWl0IGV4Y2VlZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogJ3N3YXJtLTEnLFxuICAgICAgICAgIHRvcG9sb2d5OiBjb25maWcudG9wb2xvZ3ksXG4gICAgICAgICAgbWF4QWdlbnRzOiBjb25maWcubWF4QWdlbnRzLFxuICAgICAgICAgIGFnZW50czogW10sXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgLy8gVGVzdCB2YXJpb3VzIGFnZW50IGNvdW50c1xuICAgICAgYXdhaXQgZXhwZWN0KFxuICAgICAgICBtY3BUb29scy5zd2FybV9pbml0KHsgdG9wb2xvZ3k6ICdtZXNoJywgbWF4QWdlbnRzOiAxMDAwIH0pXG4gICAgICApLnJlamVjdHMudG9UaHJvdygvTWVtb3J5IGxpbWl0Lyk7XG5cbiAgICAgIC8vIFNob3VsZCBzdWNjZWVkIHdpdGggcmVhc29uYWJsZSBsaW1pdHNcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1jcFRvb2xzLnN3YXJtX2luaXQoeyBcbiAgICAgICAgdG9wb2xvZ3k6ICdtZXNoJywgXG4gICAgICAgIG1heEFnZW50czogNTAgXG4gICAgICB9KTtcbiAgICAgIGV4cGVjdChyZXN1bHQubWF4QWdlbnRzKS50b0JlKDUwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG1lbW9yeSBjbGVhbnVwIG9uIGZhaWx1cmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBtY3BUb29scy5pbml0aWFsaXplKG1vY2tSdXZTd2FybSk7XG5cbiAgICAgIGxldCBzd2FybUNvdW50ID0gMDtcbiAgICAgIG1vY2tSdXZTd2FybS5jcmVhdGVTd2FybS5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgICBzd2FybUNvdW50Kys7XG4gICAgICAgIGlmIChzd2FybUNvdW50ID4gNSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzb3VyY2UgZXhoYXVzdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogYHN3YXJtLSR7c3dhcm1Db3VudH1gLFxuICAgICAgICAgIHRvcG9sb2d5OiAnbWVzaCcsXG4gICAgICAgICAgdGVybWluYXRlOiBqZXN0LmZuKCksXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgLy8gQ3JlYXRlIHN3YXJtcyB1bnRpbCBmYWlsdXJlXG4gICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgbWNwVG9vbHMuc3dhcm1faW5pdCh7IHRvcG9sb2d5OiAnbWVzaCcgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChwcm9taXNlcyk7XG4gICAgICBjb25zdCBmYWlsZWQgPSByZXN1bHRzLmZpbHRlcihyID0+IHIuc3RhdHVzID09PSAncmVqZWN0ZWQnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGZhaWxlZC5sZW5ndGgpLnRvQmUoNCk7IC8vIFNob3VsZCBmYWlsIGFmdGVyIDUgc3VjY2Vzc2Z1bFxuICAgICAgZXhwZWN0KG1jcFRvb2xzLmFjdGl2ZVN3YXJtcy5zaXplKS50b0JlTGVzc1RoYW5PckVxdWFsKDUpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnSW5wdXQgU2FuaXRpemF0aW9uIEVkZ2UgQ2FzZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBzYW5pdGl6ZSBwb3RlbnRpYWxseSBtYWxpY2lvdXMgaW5wdXRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgbWNwVG9vbHMuaW5pdGlhbGl6ZShtb2NrUnV2U3dhcm0pO1xuXG4gICAgICBjb25zdCBtYWxpY2lvdXNJbnB1dHMgPSBbXG4gICAgICAgIHsgdGFzazogJzxzY3JpcHQ+YWxlcnQoXCJ4c3NcIik8L3NjcmlwdD4nIH0sXG4gICAgICAgIHsgdGFzazogJ1wiOyBEUk9QIFRBQkxFIHN3YXJtczsgLS0nIH0sXG4gICAgICAgIHsgdGFzazogJyR7cHJvY2Vzcy5leGl0KDEpfScgfSxcbiAgICAgICAgeyB0YXNrOiAnYHJtIC1yZiAvYCcgfSxcbiAgICAgICAgeyB0YXNrOiAnLi4vLi4vLi4vZXRjL3Bhc3N3ZCcgfSxcbiAgICAgICAgeyB0YXNrOiAnZmlsZTovLy9ldGMvcGFzc3dkJyB9LFxuICAgICAgICB7IHRhc2s6IFN0cmluZy5mcm9tQ2hhckNvZGUoMCksIH0sIC8vIE51bGwgY2hhcmFjdGVyXG4gICAgICAgIHsgdGFzazogJ1xceDAwXFx4MDFcXHgwMlxceDAzJyB9LCAvLyBDb250cm9sIGNoYXJhY3RlcnNcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IG1vY2tTd2FybSA9IHtcbiAgICAgICAgb3JjaGVzdHJhdGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgaWQ6ICd0YXNrLTEnLFxuICAgICAgICAgIHN0YXR1czogJ2NvbXBsZXRlZCcsXG4gICAgICAgIH0pLFxuICAgICAgfTtcbiAgICAgIG1jcFRvb2xzLmFjdGl2ZVN3YXJtcy5zZXQoJ3Rlc3Qtc3dhcm0nLCBtb2NrU3dhcm0pO1xuXG4gICAgICBmb3IgKGNvbnN0IGlucHV0IG9mIG1hbGljaW91c0lucHV0cykge1xuICAgICAgICAvLyBTaG91bGQgc2FuaXRpemUgYW5kIG5vdCB0aHJvd1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtY3BUb29scy50YXNrX29yY2hlc3RyYXRlKHtcbiAgICAgICAgICBzd2FybUlkOiAndGVzdC1zd2FybScsXG4gICAgICAgICAgLi4uaW5wdXQsXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZURlZmluZWQoKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5zdGF0dXMpLnRvQmUoJ2NvbXBsZXRlZCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnTmV0d29yayBhbmQgVGltZW91dCBFZGdlIENhc2VzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIG5ldHdvcmsgdGltZW91dHMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IG1jcFRvb2xzLmluaXRpYWxpemUobW9ja1J1dlN3YXJtKTtcblxuICAgICAgY29uc3QgbW9ja1N3YXJtID0ge1xuICAgICAgICBtb25pdG9yOiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAvLyBTaW11bGF0ZSBsb25nIG5ldHdvcmsgZGVsYXlcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwMCkpO1xuICAgICAgICAgIHJldHVybiB7IHN0YXR1czogJ3RpbWVvdXQnIH07XG4gICAgICAgIH0pLFxuICAgICAgfTtcbiAgICAgIG1jcFRvb2xzLmFjdGl2ZVN3YXJtcy5zZXQoJ3Rlc3Qtc3dhcm0nLCBtb2NrU3dhcm0pO1xuXG4gICAgICAvLyBTZXQgYSBzaG9ydGVyIHRpbWVvdXQgZm9yIHRoZSB0ZXN0XG4gICAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IFxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoJ09wZXJhdGlvbiB0aW1lb3V0JykpLCAxMDApXG4gICAgICApO1xuXG4gICAgICBhd2FpdCBleHBlY3QoXG4gICAgICAgIFByb21pc2UucmFjZShbXG4gICAgICAgICAgbWNwVG9vbHMuc3dhcm1fbW9uaXRvcih7IHN3YXJtSWQ6ICd0ZXN0LXN3YXJtJyB9KSxcbiAgICAgICAgICB0aW1lb3V0UHJvbWlzZSxcbiAgICAgICAgXSlcbiAgICAgICkucmVqZWN0cy50b1Rocm93KC90aW1lb3V0L2kpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU3RhdGUgQ29uc2lzdGVuY3kgRWRnZSBDYXNlcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIG1haW50YWluIGNvbnNpc3RlbmN5IGR1cmluZyByYXBpZCBzdGF0ZSBjaGFuZ2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgbWNwVG9vbHMuaW5pdGlhbGl6ZShtb2NrUnV2U3dhcm0pO1xuXG4gICAgICBjb25zdCBtb2NrU3dhcm0gPSB7XG4gICAgICAgIGlkOiAndGVzdC1zd2FybScsXG4gICAgICAgIHJlY29uZmlndXJlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSksXG4gICAgICAgIGdldFN0YXR1czogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHRvcG9sb2d5OiAnbWVzaCcgfSksXG4gICAgICB9O1xuXG4gICAgICBtb2NrUnV2U3dhcm0uY3JlYXRlU3dhcm0ubW9ja1Jlc29sdmVkVmFsdWUobW9ja1N3YXJtKTtcbiAgICAgIGF3YWl0IG1jcFRvb2xzLnN3YXJtX2luaXQoeyB0b3BvbG9neTogJ21lc2gnIH0pO1xuXG4gICAgICAvLyBSYXBpZCB0b3BvbG9neSBjaGFuZ2VzXG4gICAgICBjb25zdCB0b3BvbG9naWVzID0gWydzdGFyJywgJ3JpbmcnLCAnaGllcmFyY2hpY2FsJywgJ21lc2gnXTtcbiAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwOyBpKyspIHtcbiAgICAgICAgY29uc3QgdG9wb2xvZ3kgPSB0b3BvbG9naWVzW2kgJSB0b3BvbG9naWVzLmxlbmd0aF07XG4gICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgbWNwVG9vbHMuc3dhcm1fcmVjb25maWd1cmUoe1xuICAgICAgICAgICAgc3dhcm1JZDogJ3Rlc3Qtc3dhcm0nLFxuICAgICAgICAgICAgdG9wb2xvZ3ksXG4gICAgICAgICAgfSkuY2F0Y2goKCkgPT4gbnVsbCkgLy8gSWdub3JlIGVycm9yc1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZpbmFsIHN0YXRlIGlzIGNvbnNpc3RlbnRcbiAgICAgIGNvbnN0IHN0YXR1cyA9IGF3YWl0IG1jcFRvb2xzLnN3YXJtX3N0YXR1cyh7IHN3YXJtSWQ6ICd0ZXN0LXN3YXJtJyB9KTtcbiAgICAgIGV4cGVjdChzdGF0dXMpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QodG9wb2xvZ2llcykudG9Db250YWluKHN0YXR1cy50b3BvbG9neSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cbi8vIFJ1biB0ZXN0cyB3aGVuIGV4ZWN1dGVkIGRpcmVjdGx5XG5pZiAoaW1wb3J0Lm1ldGEudXJsID09PSBgZmlsZTovLyR7cHJvY2Vzcy5hcmd2WzFdfWApIHtcbiAgY29uc29sZS5sb2coJ1J1bm5pbmcgTUNQIHZhbGlkYXRpb24gZWRnZSBjYXNlIHRlc3RzLi4uJyk7XG4gIFxuICAvLyBSdW4gYWxsIHRlc3RzXG4gIGNvbnN0IHsgcnVuIH0gPSBhd2FpdCBpbXBvcnQoJy4uL3Rlc3QtcnVubmVyLmpzJyk7XG4gIGF3YWl0IHJ1bihfX2ZpbGVuYW1lKTtcbn0iXSwibWFwcGluZ3MiOiJBQVNBO0FBQ0FBLFdBQUEsR0FBS0MsSUFBSSxDQUFDLDZCQUE2QixDQUFDO0FBQ3hDRCxXQUFBLEdBQUtDLElBQUksQ0FBQywwQkFBMEIsQ0FBQztBQUFDLFNBQUFDLFFBQUFDLENBQUEsRUFBQUMsQ0FBQSxRQUFBQyxDQUFBLEdBQUFDLE1BQUEsQ0FBQUMsSUFBQSxDQUFBSixDQUFBLE9BQUFHLE1BQUEsQ0FBQUUscUJBQUEsUUFBQUMsQ0FBQSxHQUFBSCxNQUFBLENBQUFFLHFCQUFBLENBQUFMLENBQUEsR0FBQUMsQ0FBQSxLQUFBSyxDQUFBLEdBQUFBLENBQUEsQ0FBQUMsTUFBQSxXQUFBTixDQUFBLFdBQUFFLE1BQUEsQ0FBQUssd0JBQUEsQ0FBQVIsQ0FBQSxFQUFBQyxDQUFBLEVBQUFRLFVBQUEsT0FBQVAsQ0FBQSxDQUFBUSxJQUFBLENBQUFDLEtBQUEsQ0FBQVQsQ0FBQSxFQUFBSSxDQUFBLFlBQUFKLENBQUE7QUFBQSxTQUFBVSxjQUFBWixDQUFBLGFBQUFDLENBQUEsTUFBQUEsQ0FBQSxHQUFBWSxTQUFBLENBQUFDLE1BQUEsRUFBQWIsQ0FBQSxVQUFBQyxD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