9ebcc927bb3cc9180ab201fa813a1814
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
/**
 * Comprehensive MCP Protocol Integration Test Suite
 * Tests the MCP protocol handling and communication
 * 
 * @author Test Coverage Champion
 * @version 1.0.0
 */

import { strict as assert } from 'assert';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { spawn } from 'child_process';
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
class MCPProtocolIntegrationTestSuite {
  constructor() {
    this.results = {
      totalTests: 0,
      passed: 0,
      failed: 0,
      errors: [],
      coverage: {
        protocol: 0,
        communication: 0,
        serialization: 0,
        errorHandling: 0,
        performance: 0,
        security: 0,
        compatibility: 0,
        stress: 0
      }
    };
  }
  runTest(name, testFn) {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.results.totalTests++;
      try {
        yield testFn();
        _this.results.passed++;
        console.log(`‚úÖ ${name}`);
        return true;
      } catch (error) {
        _this.results.failed++;
        _this.results.errors.push({
          name,
          error: error.message
        });
        console.log(`‚ùå ${name}: ${error.message}`);
        return false;
      }
    })();
  }

  // Test MCP Protocol Basics
  testMCPProtocolBasics() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      console.log('\nüîç Testing MCP Protocol Basics...');
      yield _this2.runTest('Protocol - Message structure validation', /*#__PURE__*/_asyncToGenerator(function* () {
        const mcpMessage = {
          jsonrpc: '2.0',
          method: 'tools/call',
          params: {
            name: 'swarm_init',
            arguments: {
              topology: 'mesh'
            }
          },
          id: 1
        };

        // Validate required fields
        assert(mcpMessage.jsonrpc === '2.0', 'Should have correct JSON-RPC version');
        assert(typeof mcpMessage.method === 'string', 'Should have method field');
        assert(typeof mcpMessage.params === 'object', 'Should have params object');
        assert(typeof mcpMessage.id !== 'undefined', 'Should have request ID');
        _this2.results.coverage.protocol++;
      }));
      yield _this2.runTest('Protocol - Response structure validation', /*#__PURE__*/_asyncToGenerator(function* () {
        const mcpResponse = {
          jsonrpc: '2.0',
          result: {
            content: [{
              type: 'text',
              text: 'Swarm initialized successfully'
            }]
          },
          id: 1
        };
        assert(mcpResponse.jsonrpc === '2.0', 'Response should have correct JSON-RPC version');
        assert(typeof mcpResponse.result === 'object', 'Should have result object');
        assert(Array.isArray(mcpResponse.result.content), 'Should have content array');
        _this2.results.coverage.protocol++;
      }));
      yield _this2.runTest('Protocol - Error response structure', /*#__PURE__*/_asyncToGenerator(function* () {
        const mcpErrorResponse = {
          jsonrpc: '2.0',
          error: {
            code: -32602,
            message: 'Invalid params',
            data: {
              details: 'topology parameter is required'
            }
          },
          id: 1
        };
        assert(mcpErrorResponse.jsonrpc === '2.0', 'Error response should have correct JSON-RPC version');
        assert(typeof mcpErrorResponse.error === 'object', 'Should have error object');
        assert(typeof mcpErrorResponse.error.code === 'number', 'Error should have numeric code');
        assert(typeof mcpErrorResponse.error.message === 'string', 'Error should have message');
        _this2.results.coverage.protocol++;
      }));
      yield _this2.runTest('Protocol - Tool list request', /*#__PURE__*/_asyncToGenerator(function* () {
        const toolListRequest = {
          jsonrpc: '2.0',
          method: 'tools/list',
          params: {},
          id: 2
        };
        assert(toolListRequest.method === 'tools/list', 'Should request tool list');
        assert(typeof toolListRequest.params === 'object', 'Should have params object');
        _this2.results.coverage.protocol++;
      }));
    })();
  }

  // Test MCP Communication
  testMCPCommunication() {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      console.log('\nüîç Testing MCP Communication...');
      yield _this3.runTest('Communication - JSON-RPC request/response cycle', /*#__PURE__*/_asyncToGenerator(function* () {
        // Simulate a complete request/response cycle
        const request = {
          jsonrpc: '2.0',
          method: 'tools/call',
          params: {
            name: 'swarm_status',
            arguments: {
              verbose: false
            }
          },
          id: 3
        };

        // Simulate processing
        const response = {
          jsonrpc: '2.0',
          result: {
            content: [{
              type: 'text',
              text: JSON.stringify({
                status: 'active',
                agents: 0
              })
            }]
          },
          id: request.id
        };
        assert(response.id === request.id, 'Response ID should match request ID');
        assert(response.result.content[0].type === 'text', 'Should return text content');
        _this3.results.coverage.communication++;
      }));
      yield _this3.runTest('Communication - Batch request handling', /*#__PURE__*/_asyncToGenerator(function* () {
        const batchRequest = [{
          jsonrpc: '2.0',
          method: 'tools/call',
          params: {
            name: 'swarm_status',
            arguments: {}
          },
          id: 4
        }, {
          jsonrpc: '2.0',
          method: 'tools/call',
          params: {
            name: 'agent_list',
            arguments: {}
          },
          id: 5
        }];

        // Simulate batch processing
        const batchResponse = batchRequest.map(req => ({
          jsonrpc: '2.0',
          result: {
            content: [{
              type: 'text',
              text: `Response for ${req.params.name}`
            }]
          },
          id: req.id
        }));
        assert(Array.isArray(batchResponse), 'Should handle batch requests');
        assert(batchResponse.length === batchRequest.length, 'Should return same number of responses');
        _this3.results.coverage.communication++;
      }));
      yield _this3.runTest('Communication - Notification handling', /*#__PURE__*/_asyncToGenerator(function* () {
        const notification = {
          jsonrpc: '2.0',
          method: 'notifications/message',
          params: {
            level: 'info',
            logger: 'ruv-swarm',
            data: 'Agent spawned successfully'
          }
        };

        // Notifications don't have ID and don't expect responses
        assert(notification.id === undefined, 'Notifications should not have ID');
        assert(notification.method.startsWith('notifications/'), 'Should be notification method');
        _this3.results.coverage.communication++;
      }));
    })();
  }

  // Test MCP Serialization
  testMCPSerialization() {
    var _this4 = this;
    return _asyncToGenerator(function* () {
      console.log('\nüîç Testing MCP Serialization...');
      yield _this4.runTest('Serialization - JSON serialization/deserialization', /*#__PURE__*/_asyncToGenerator(function* () {
        const originalMessage = {
          jsonrpc: '2.0',
          method: 'tools/call',
          params: {
            name: 'agent_spawn',
            arguments: {
              type: 'researcher',
              capabilities: ['search', 'analyze', 'summarize'],
              config: {
                timeout: 30000,
                retries: 3,
                priority: 'high'
              }
            }
          },
          id: 6
        };
        const serialized = JSON.stringify(originalMessage);
        const deserialized = JSON.parse(serialized);
        assert(JSON.stringify(deserialized) === JSON.stringify(originalMessage), 'Should preserve message integrity');
        assert(deserialized.params.arguments.capabilities.length === 3, 'Should preserve array data');
        assert(deserialized.params.arguments.config.timeout === 30000, 'Should preserve nested objects');
        _this4.results.coverage.serialization++;
      }));
      yield _this4.runTest('Serialization - Binary data handling', /*#__PURE__*/_asyncToGenerator(function* () {
        const binaryData = Buffer.from('Hello, World!', 'utf8');
        const base64Data = binaryData.toString('base64');
        const messageWithBinary = {
          jsonrpc: '2.0',
          method: 'tools/call',
          params: {
            name: 'process_binary',
            arguments: {
              data: base64Data,
              encoding: 'base64'
            }
          },
          id: 7
        };
        const serialized = JSON.stringify(messageWithBinary);
        const deserialized = JSON.parse(serialized);
        const recoveredBinary = Buffer.from(deserialized.params.arguments.data, 'base64');
        assert(recoveredBinary.toString('utf8') === 'Hello, World!', 'Should handle binary data correctly');
        _this4.results.coverage.serialization++;
      }));
      yield _this4.runTest('Serialization - Unicode and special characters', /*#__PURE__*/_asyncToGenerator(function* () {
        const unicodeMessage = {
          jsonrpc: '2.0',
          method: 'tools/call',
          params: {
            name: 'process_text',
            arguments: {
              text: 'Hello üåç! Caf√© na√Øve r√©sum√© ‰∏≠Êñá ‰∏≠Êñá üöÄ',
              emoji: 'üöÄüåçüíªü§ñ',
              math: 'œÄ ‚â† 3.14159...',
              quotes: '"Smart quotes" and ‚Äòsingle quotes‚Äô'
            }
          },
          id: 8
        };
        const serialized = JSON.stringify(unicodeMessage);
        const deserialized = JSON.parse(serialized);
        assert(deserialized.params.arguments.text.includes('üåç'), 'Should preserve emoji');
        assert(deserialized.params.arguments.text.includes('‰∏≠Êñá'), 'Should preserve Chinese characters');
        assert(deserialized.params.arguments.math.includes('œÄ'), 'Should preserve mathematical symbols');
        _this4.results.coverage.serialization++;
      }));
    })();
  }

  // Test MCP Error Handling
  testMCPErrorHandling() {
    var _this5 = this;
    return _asyncToGenerator(function* () {
      console.log('\nüîç Testing MCP Error Handling...');
      yield _this5.runTest('Error Handling - Invalid JSON-RPC version', /*#__PURE__*/_asyncToGenerator(function* () {
        const invalidRequest = {
          jsonrpc: '1.0',
          // Invalid version
          method: 'tools/call',
          params: {
            name: 'test'
          },
          id: 9
        };
        const errorResponse = {
          jsonrpc: '2.0',
          error: {
            code: -32600,
            message: 'Invalid Request',
            data: 'Unsupported JSON-RPC version'
          },
          id: 9
        };
        assert(errorResponse.error.code === -32600, 'Should return Invalid Request error');
        _this5.results.coverage.errorHandling++;
      }));
      yield _this5.runTest('Error Handling - Method not found', /*#__PURE__*/_asyncToGenerator(function* () {
        const unknownMethodRequest = {
          jsonrpc: '2.0',
          method: 'unknown/method',
          params: {},
          id: 10
        };
        const errorResponse = {
          jsonrpc: '2.0',
          error: {
            code: -32601,
            message: 'Method not found',
            data: 'Method unknown/method not supported'
          },
          id: 10
        };
        assert(errorResponse.error.code === -32601, 'Should return Method not found error');
        _this5.results.coverage.errorHandling++;
      }));
      yield _this5.runTest('Error Handling - Invalid parameters', /*#__PURE__*/_asyncToGenerator(function* () {
        const invalidParamsRequest = {
          jsonrpc: '2.0',
          method: 'tools/call',
          params: {
            name: 'swarm_init'
            // Missing required arguments
          },
          id: 11
        };
        const errorResponse = {
          jsonrpc: '2.0',
          error: {
            code: -32602,
            message: 'Invalid params',
            data: 'Missing required parameter: topology'
          },
          id: 11
        };
        assert(errorResponse.error.code === -32602, 'Should return Invalid params error');
        _this5.results.coverage.errorHandling++;
      }));
      yield _this5.runTest('Error Handling - Parse error', /*#__PURE__*/_asyncToGenerator(function* () {
        const malformedJSON = '{"jsonrpc":"2.0","method":"tools/call","params":{"name":"test"},';
        try {
          JSON.parse(malformedJSON);
          assert.fail('Should have thrown parse error');
        } catch (error) {
          const parseErrorResponse = {
            jsonrpc: '2.0',
            error: {
              code: -32700,
              message: 'Parse error',
              data: 'Invalid JSON format'
            },
            id: null
          };
          assert(parseErrorResponse.error.code === -32700, 'Should return Parse error');
        }
        _this5.results.coverage.errorHandling++;
      }));
    })();
  }

  // Test MCP Performance
  testMCPPerformance() {
    var _this6 = this;
    return _asyncToGenerator(function* () {
      console.log('\nüîç Testing MCP Performance...');
      yield _this6.runTest('Performance - Large payload handling', /*#__PURE__*/_asyncToGenerator(function* () {
        const largeArray = new Array(10000).fill(0).map((_, i) => `item-${i}`);
        const largeRequest = {
          jsonrpc: '2.0',
          method: 'tools/call',
          params: {
            name: 'process_large_data',
            arguments: {
              data: largeArray,
              metadata: {
                count: largeArray.length,
                timestamp: Date.now()
              }
            }
          },
          id: 12
        };
        const startTime = performance.now();
        const serialized = JSON.stringify(largeRequest);
        const deserialized = JSON.parse(serialized);
        const endTime = performance.now();
        const processingTime = endTime - startTime;
        assert(deserialized.params.arguments.data.length === 10000, 'Should handle large arrays');
        assert(processingTime < 1000, 'Should process large payloads efficiently'); // Less than 1 second

        _this6.results.coverage.performance++;
      }));
      yield _this6.runTest('Performance - Concurrent request simulation', /*#__PURE__*/_asyncToGenerator(function* () {
        const createRequest = id => ({
          jsonrpc: '2.0',
          method: 'tools/call',
          params: {
            name: 'agent_metrics',
            arguments: {
              metric: 'all'
            }
          },
          id: id
        });
        const startTime = performance.now();

        // Simulate 100 concurrent requests
        const requests = Array.from({
          length: 100
        }, (_, i) => createRequest(i + 13));
        const responses = requests.map(req => ({
          jsonrpc: '2.0',
          result: {
            content: [{
              type: 'text',
              text: JSON.stringify({
                metrics: {
                  cpu: Math.random() * 100
                }
              })
            }]
          },
          id: req.id
        }));
        const endTime = performance.now();
        const processingTime = endTime - startTime;
        assert(responses.length === 100, 'Should handle concurrent requests');
        assert(processingTime < 500, 'Should process concurrent requests efficiently');
        _this6.results.coverage.performance++;
      }));
      yield _this6.runTest('Performance - Memory usage monitoring', /*#__PURE__*/_asyncToGenerator(function* () {
        const initialMemory = process.memoryUsage();

        // Create many large objects to test memory handling
        const largeObjects = [];
        for (let i = 0; i < 1000; i++) {
          largeObjects.push({
            jsonrpc: '2.0',
            method: 'tools/call',
            params: {
              name: `test_method_${i}`,
              arguments: {
                data: new Array(100).fill(`test-data-${i}`),
                timestamp: Date.now()
              }
            },
            id: i + 113
          });
        }
        const peakMemory = process.memoryUsage();

        // Clear objects
        largeObjects.length = 0;

        // Force garbage collection if available
        if (global.gc) {
          global.gc();
        }
        const finalMemory = process.memoryUsage();
        const memoryIncrease = peakMemory.heapUsed - initialMemory.heapUsed;
        const memoryRecovered = peakMemory.heapUsed - finalMemory.heapUsed;
        assert(memoryIncrease > 0, 'Should show memory usage increase');
        // Memory recovery depends on GC, so we don't assert it

        _this6.results.coverage.performance++;
      }));
    })();
  }

  // Test MCP Security
  testMCPSecurity() {
    var _this7 = this;
    return _asyncToGenerator(function* () {
      console.log('\nüîç Testing MCP Security...');
      yield _this7.runTest('Security - Input sanitization', /*#__PURE__*/_asyncToGenerator(function* () {
        const maliciousRequest = {
          jsonrpc: '2.0',
          method: 'tools/call',
          params: {
            name: 'swarm_init',
            arguments: {
              topology: '<script>alert("XSS")</script>',
              config: {
                command: 'rm -rf /',
                sql: "'; DROP TABLE users; --"
              }
            }
          },
          id: 116
        };

        // Simulate input sanitization
        const sanitizedArgs = {
          topology: maliciousRequest.params.arguments.topology.replace(/<script[^>]*>.*?<\/script>/gi, ''),
          config: {
            command: maliciousRequest.params.arguments.config.command.replace(/[;&|`$()]/g, ''),
            sql: maliciousRequest.params.arguments.config.sql.replace(/['";<>]/g, '')
          }
        };
        assert(!sanitizedArgs.topology.includes('<script>'), 'Should sanitize XSS attempts');
        assert(!sanitizedArgs.config.command.includes('rm -rf'), 'Should sanitize command injection');
        assert(!sanitizedArgs.config.sql.includes('DROP TABLE'), 'Should sanitize SQL injection');
        _this7.results.coverage.security++;
      }));
      yield _this7.runTest('Security - Request size limits', /*#__PURE__*/_asyncToGenerator(function* () {
        const oversizedData = 'x'.repeat(10 * 1024 * 1024); // 10MB string

        const oversizedRequest = {
          jsonrpc: '2.0',
          method: 'tools/call',
          params: {
            name: 'process_data',
            arguments: {
              data: oversizedData
            }
          },
          id: 117
        };
        const requestSize = JSON.stringify(oversizedRequest).length;
        const maxSize = 5 * 1024 * 1024; // 5MB limit

        if (requestSize > maxSize) {
          const errorResponse = {
            jsonrpc: '2.0',
            error: {
              code: -32000,
              message: 'Request too large',
              data: `Request size ${requestSize} exceeds limit ${maxSize}`
            },
            id: 117
          };
          assert(errorResponse.error.code === -32000, 'Should reject oversized requests');
        }
        _this7.results.coverage.security++;
      }));
      yield _this7.runTest('Security - Method whitelisting', /*#__PURE__*/_asyncToGenerator(function* () {
        const allowedMethods = ['tools/call', 'tools/list', 'notifications/message', 'resources/list', 'resources/read'];
        const unauthorizedRequest = {
          jsonrpc: '2.0',
          method: 'system/shutdown',
          params: {},
          id: 118
        };
        const isAllowed = allowedMethods.includes(unauthorizedRequest.method);
        if (!isAllowed) {
          const errorResponse = {
            jsonrpc: '2.0',
            error: {
              code: -32601,
              message: 'Method not found',
              data: 'Method not in whitelist'
            },
            id: 118
          };
          assert(errorResponse.error.code === -32601, 'Should reject non-whitelisted methods');
        }
        _this7.results.coverage.security++;
      }));
    })();
  }

  // Test MCP Compatibility
  testMCPCompatibility() {
    var _this8 = this;
    return _asyncToGenerator(function* () {
      console.log('\nüîç Testing MCP Compatibility...');
      yield _this8.runTest('Compatibility - Different JSON-RPC clients', /*#__PURE__*/_asyncToGenerator(function* () {
        // Test compatibility with various client formats
        const clientFormats = [{
          name: 'Standard client',
          request: {
            jsonrpc: '2.0',
            method: 'tools/call',
            params: {
              name: 'test',
              arguments: {}
            },
            id: 119
          }
        }, {
          name: 'Client with extra fields',
          request: {
            jsonrpc: '2.0',
            method: 'tools/call',
            params: {
              name: 'test',
              arguments: {}
            },
            id: 120,
            timestamp: Date.now(),
            client: 'test-client'
          }
        }, {
          name: 'Client with string ID',
          request: {
            jsonrpc: '2.0',
            method: 'tools/call',
            params: {
              name: 'test',
              arguments: {}
            },
            id: 'string-id-121'
          }
        }];
        for (const format of clientFormats) {
          const response = {
            jsonrpc: '2.0',
            result: {
              content: [{
                type: 'text',
                text: 'Test response'
              }]
            },
            id: format.request.id
          };
          assert(response.id === format.request.id, `Should handle ${format.name}`);
        }
        _this8.results.coverage.compatibility++;
      }));
      yield _this8.runTest('Compatibility - Content type variations', /*#__PURE__*/_asyncToGenerator(function* () {
        const contentTypes = [{
          type: 'text',
          text: 'Plain text response'
        }, {
          type: 'text',
          text: JSON.stringify({
            structured: 'data'
          })
        }, {
          type: 'image',
          data: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==',
          mimeType: 'image/png'
        }, {
          type: 'resource',
          resource: {
            uri: 'file:///test.txt',
            mimeType: 'text/plain'
          }
        }];
        for (const content of contentTypes) {
          const response = {
            jsonrpc: '2.0',
            result: {
              content: [content]
            },
            id: 122
          };
          assert(response.result.content[0].type === content.type, `Should handle ${content.type} content`);
        }
        _this8.results.coverage.compatibility++;
      }));
    })();
  }
  generateReport() {
    const passRate = (this.results.passed / this.results.totalTests * 100).toFixed(1);
    const totalCoverage = Object.values(this.results.coverage).reduce((a, b) => a + b, 0);
    const report = {
      timestamp: new Date().toISOString(),
      summary: {
        totalTests: this.results.totalTests,
        passed: this.results.passed,
        failed: this.results.failed,
        passRate: `${passRate}%`,
        totalCoveragePoints: totalCoverage
      },
      coverage: this.results.coverage,
      errors: this.results.errors,
      recommendations: this.generateRecommendations()
    };
    return report;
  }
  generateRecommendations() {
    const recommendations = [];
    const coverage = this.results.coverage;
    if (this.results.failed > 0) {
      recommendations.push('Fix failing MCP protocol tests to ensure compliance');
    }
    if (coverage.protocol < 4) {
      recommendations.push('Add more MCP protocol conformance tests');
    }
    if (coverage.communication < 3) {
      recommendations.push('Expand MCP communication pattern tests');
    }
    if (coverage.serialization < 3) {
      recommendations.push('Add more serialization and encoding tests');
    }
    if (coverage.errorHandling < 4) {
      recommendations.push('Enhance MCP error handling test coverage');
    }
    if (coverage.performance < 3) {
      recommendations.push('Add more MCP performance benchmarks');
    }
    if (coverage.security < 3) {
      recommendations.push('Strengthen MCP security testing');
    }
    if (coverage.compatibility < 2) {
      recommendations.push('Add more client compatibility tests');
    }
    if (recommendations.length === 0) {
      recommendations.push('Excellent MCP protocol coverage! Consider adding stress tests.');
    }
    return recommendations;
  }
  run() {
    var _this9 = this;
    return _asyncToGenerator(function* () {
      console.log('üîó Starting Comprehensive MCP Protocol Integration Test Suite');
      console.log('='.repeat(75));
      yield _this9.testMCPProtocolBasics();
      yield _this9.testMCPCommunication();
      yield _this9.testMCPSerialization();
      yield _this9.testMCPErrorHandling();
      yield _this9.testMCPPerformance();
      yield _this9.testMCPSecurity();
      yield _this9.testMCPCompatibility();
      const report = _this9.generateReport();
      console.log('\nüìä MCP Protocol Test Results Summary');
      console.log('='.repeat(75));
      console.log(`Total Tests: ${report.summary.totalTests}`);
      console.log(`Passed: ${report.summary.passed}`);
      console.log(`Failed: ${report.summary.failed}`);
      console.log(`Pass Rate: ${report.summary.passRate}`);
      console.log(`Total Coverage Points: ${report.summary.totalCoveragePoints}`);
      console.log('\nüìä Coverage Breakdown:');
      Object.entries(report.coverage).forEach(([area, count]) => {
        console.log(`  ${area}: ${count} tests`);
      });
      if (report.errors.length > 0) {
        console.log('\n‚ùå Errors:');
        report.errors.forEach(error => {
          console.log(`  - ${error.name}: ${error.error}`);
        });
      }
      console.log('\nüí° Recommendations:');
      report.recommendations.forEach(rec => {
        console.log(`  - ${rec}`);
      });

      // Save report to file
      const reportPath = path.join(__dirname, '../test-reports/mcp-protocol-test-report.json');
      fs.mkdirSync(path.dirname(reportPath), {
        recursive: true
      });
      fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
      console.log(`\nüìÑ Report saved to: ${reportPath}`);
      console.log('\n‚úÖ MCP Protocol Integration Test Suite Complete!');
      return report;
    })();
  }
}

// Run the test suite if this file is executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  const testSuite = new MCPProtocolIntegrationTestSuite();
  try {
    await testSuite.run();
    process.exit(0);
  } catch (error) {
    console.error('‚ùå MCP protocol test suite failed:', error);
    process.exit(1);
  }
}
export { MCPProtocolIntegrationTestSuite };
export default MCPProtocolIntegrationTestSuite;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJzdHJpY3QiLCJhc3NlcnQiLCJmcyIsInBhdGgiLCJmaWxlVVJMVG9QYXRoIiwic3Bhd24iLCJfX2ZpbGVuYW1lIiwiaW1wb3J0IiwibWV0YSIsInVybCIsIl9fZGlybmFtZSIsImRpcm5hbWUiLCJNQ1BQcm90b2NvbEludGVncmF0aW9uVGVzdFN1aXRlIiwiY29uc3RydWN0b3IiLCJyZXN1bHRzIiwidG90YWxUZXN0cyIsInBhc3NlZCIsImZhaWxlZCIsImVycm9ycyIsImNvdmVyYWdlIiwicHJvdG9jb2wiLCJjb21tdW5pY2F0aW9uIiwic2VyaWFsaXphdGlvbiIsImVycm9ySGFuZGxpbmciLCJwZXJmb3JtYW5jZSIsInNlY3VyaXR5IiwiY29tcGF0aWJpbGl0eSIsInN0cmVzcyIsInJ1blRlc3QiLCJuYW1lIiwidGVzdEZuIiwiX3RoaXMiLCJfYXN5bmNUb0dlbmVyYXRvciIsImNvbnNvbGUiLCJsb2ciLCJlcnJvciIsInB1c2giLCJtZXNzYWdlIiwidGVzdE1DUFByb3RvY29sQmFzaWNzIiwiX3RoaXMyIiwibWNwTWVzc2FnZSIsImpzb25ycGMiLCJtZXRob2QiLCJwYXJhbXMiLCJhcmd1bWVudHMiLCJ0b3BvbG9neSIsImlkIiwibWNwUmVzcG9uc2UiLCJyZXN1bHQiLCJjb250ZW50IiwidHlwZSIsInRleHQiLCJBcnJheSIsImlzQXJyYXkiLCJtY3BFcnJvclJlc3BvbnNlIiwiY29kZSIsImRhdGEiLCJkZXRhaWxzIiwidG9vbExpc3RSZXF1ZXN0IiwidGVzdE1DUENvbW11bmljYXRpb24iLCJfdGhpczMiLCJyZXF1ZXN0IiwidmVyYm9zZSIsInJlc3BvbnNlIiwiSlNPTiIsInN0cmluZ2lmeSIsInN0YXR1cyIsImFnZW50cyIsImJhdGNoUmVxdWVzdCIsImJhdGNoUmVzcG9uc2UiLCJtYXAiLCJyZXEiLCJsZW5ndGgiLCJub3RpZmljYXRpb24iLCJsZXZlbCIsImxvZ2dlciIsInVuZGVmaW5lZCIsInN0YXJ0c1dpdGgiLCJ0ZXN0TUNQU2VyaWFsaXphdGlvbiIsIl90aGlzNCIsIm9yaWdpbmFsTWVzc2FnZSIsImNhcGFiaWxpdGllcyIsImNvbmZpZyIsInRpbWVvdXQiLCJyZXRyaWVzIiwicHJpb3JpdHkiLCJzZXJpYWxpemVkIiwiZGVzZXJpYWxpemVkIiwicGFyc2UiLCJiaW5hcnlEYXRhIiwiQnVmZmVyIiwiZnJvbSIsImJhc2U2NERhdGEiLCJ0b1N0cmluZyIsIm1lc3NhZ2VXaXRoQmluYXJ5IiwiZW5jb2RpbmciLCJyZWNvdmVyZWRCaW5hcnkiLCJ1bmljb2RlTWVzc2FnZSIsImVtb2ppIiwibWF0aCIsInF1b3RlcyIsImluY2x1ZGVzIiwidGVzdE1DUEVycm9ySGFuZGxpbmciLCJfdGhpczUiLCJpbnZhbGlkUmVxdWVzdCIsImVycm9yUmVzcG9uc2UiLCJ1bmtub3duTWV0aG9kUmVxdWVzdCIsImludmFsaWRQYXJhbXNSZXF1ZXN0IiwibWFsZm9ybWVkSlNPTiIsImZhaWwiLCJwYXJzZUVycm9yUmVzcG9uc2UiLCJ0ZXN0TUNQUGVyZm9ybWFuY2UiLCJfdGhpczYiLCJsYXJnZUFycmF5IiwiZmlsbCIsIl8iLCJpIiwibGFyZ2VSZXF1ZXN0IiwibWV0YWRhdGEiLCJjb3VudCIsInRpbWVzdGFtcCIsIkRhdGUiLCJub3ciLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwicHJvY2Vzc2luZ1RpbWUiLCJjcmVhdGVSZXF1ZXN0IiwibWV0cmljIiwicmVxdWVzdHMiLCJyZXNwb25zZXMiLCJtZXRyaWNzIiwiY3B1IiwiTWF0aCIsInJhbmRvbSIsImluaXRpYWxNZW1vcnkiLCJwcm9jZXNzIiwibWVtb3J5VXNhZ2UiLCJsYXJnZU9iamVjdHMiLCJwZWFrTWVtb3J5IiwiZ2xvYmFsIiwiZ2MiLCJmaW5hbE1lbW9yeSIsIm1lbW9yeUluY3JlYXNlIiwiaGVhcFVzZWQiLCJtZW1vcnlSZWNvdmVyZWQiLCJ0ZXN0TUNQU2VjdXJpdHkiLCJfdGhpczciLCJtYWxpY2lvdXNSZXF1ZXN0IiwiY29tbWFuZCIsInNxbCIsInNhbml0aXplZEFyZ3MiLCJyZXBsYWNlIiwib3ZlcnNpemVkRGF0YSIsInJlcGVhdCIsIm92ZXJzaXplZFJlcXVlc3QiLCJyZXF1ZXN0U2l6ZSIsIm1heFNpemUiLCJhbGxvd2VkTWV0aG9kcyIsInVuYXV0aG9yaXplZFJlcXVlc3QiLCJpc0FsbG93ZWQiLCJ0ZXN0TUNQQ29tcGF0aWJpbGl0eSIsIl90aGlzOCIsImNsaWVudEZvcm1hdHMiLCJjbGllbnQiLCJmb3JtYXQiLCJjb250ZW50VHlwZXMiLCJzdHJ1Y3R1cmVkIiwibWltZVR5cGUiLCJyZXNvdXJjZSIsInVyaSIsImdlbmVyYXRlUmVwb3J0IiwicGFzc1JhdGUiLCJ0b0ZpeGVkIiwidG90YWxDb3ZlcmFnZSIsIk9iamVjdCIsInZhbHVlcyIsInJlZHVjZSIsImEiLCJiIiwicmVwb3J0IiwidG9JU09TdHJpbmciLCJzdW1tYXJ5IiwidG90YWxDb3ZlcmFnZVBvaW50cyIsInJlY29tbWVuZGF0aW9ucyIsImdlbmVyYXRlUmVjb21tZW5kYXRpb25zIiwicnVuIiwiX3RoaXM5IiwiZW50cmllcyIsImZvckVhY2giLCJhcmVhIiwicmVjIiwicmVwb3J0UGF0aCIsImpvaW4iLCJta2RpclN5bmMiLCJyZWN1cnNpdmUiLCJ3cml0ZUZpbGVTeW5jIiwiYXJndiIsInRlc3RTdWl0ZSIsImV4aXQiXSwic291cmNlcyI6WyJtY3AtcHJvdG9jb2wtaW50ZWdyYXRpb24udGVzdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuLyoqXG4gKiBDb21wcmVoZW5zaXZlIE1DUCBQcm90b2NvbCBJbnRlZ3JhdGlvbiBUZXN0IFN1aXRlXG4gKiBUZXN0cyB0aGUgTUNQIHByb3RvY29sIGhhbmRsaW5nIGFuZCBjb21tdW5pY2F0aW9uXG4gKiBcbiAqIEBhdXRob3IgVGVzdCBDb3ZlcmFnZSBDaGFtcGlvblxuICogQHZlcnNpb24gMS4wLjBcbiAqL1xuXG5pbXBvcnQgeyBzdHJpY3QgYXMgYXNzZXJ0IH0gZnJvbSAnYXNzZXJ0JztcbmltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IGZpbGVVUkxUb1BhdGggfSBmcm9tICd1cmwnO1xuaW1wb3J0IHsgc3Bhd24gfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcblxuY29uc3QgX19maWxlbmFtZSA9IGZpbGVVUkxUb1BhdGgoaW1wb3J0Lm1ldGEudXJsKTtcbmNvbnN0IF9fZGlybmFtZSA9IHBhdGguZGlybmFtZShfX2ZpbGVuYW1lKTtcblxuY2xhc3MgTUNQUHJvdG9jb2xJbnRlZ3JhdGlvblRlc3RTdWl0ZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucmVzdWx0cyA9IHtcbiAgICAgIHRvdGFsVGVzdHM6IDAsXG4gICAgICBwYXNzZWQ6IDAsXG4gICAgICBmYWlsZWQ6IDAsXG4gICAgICBlcnJvcnM6IFtdLFxuICAgICAgY292ZXJhZ2U6IHtcbiAgICAgICAgcHJvdG9jb2w6IDAsXG4gICAgICAgIGNvbW11bmljYXRpb246IDAsXG4gICAgICAgIHNlcmlhbGl6YXRpb246IDAsXG4gICAgICAgIGVycm9ySGFuZGxpbmc6IDAsXG4gICAgICAgIHBlcmZvcm1hbmNlOiAwLFxuICAgICAgICBzZWN1cml0eTogMCxcbiAgICAgICAgY29tcGF0aWJpbGl0eTogMCxcbiAgICAgICAgc3RyZXNzOiAwXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIHJ1blRlc3QobmFtZSwgdGVzdEZuKSB7XG4gICAgdGhpcy5yZXN1bHRzLnRvdGFsVGVzdHMrKztcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGVzdEZuKCk7XG4gICAgICB0aGlzLnJlc3VsdHMucGFzc2VkKys7XG4gICAgICBjb25zb2xlLmxvZyhg4pyFICR7bmFtZX1gKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLnJlc3VsdHMuZmFpbGVkKys7XG4gICAgICB0aGlzLnJlc3VsdHMuZXJyb3JzLnB1c2goeyBuYW1lLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9KTtcbiAgICAgIGNvbnNvbGUubG9nKGDinYwgJHtuYW1lfTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRlc3QgTUNQIFByb3RvY29sIEJhc2ljc1xuICBhc3luYyB0ZXN0TUNQUHJvdG9jb2xCYXNpY3MoKSB7XG4gICAgY29uc29sZS5sb2coJ1xcbvCflI0gVGVzdGluZyBNQ1AgUHJvdG9jb2wgQmFzaWNzLi4uJyk7XG5cbiAgICBhd2FpdCB0aGlzLnJ1blRlc3QoJ1Byb3RvY29sIC0gTWVzc2FnZSBzdHJ1Y3R1cmUgdmFsaWRhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1jcE1lc3NhZ2UgPSB7XG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBtZXRob2Q6ICd0b29scy9jYWxsJyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgbmFtZTogJ3N3YXJtX2luaXQnLFxuICAgICAgICAgIGFyZ3VtZW50czogeyB0b3BvbG9neTogJ21lc2gnIH1cbiAgICAgICAgfSxcbiAgICAgICAgaWQ6IDFcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIFZhbGlkYXRlIHJlcXVpcmVkIGZpZWxkc1xuICAgICAgYXNzZXJ0KG1jcE1lc3NhZ2UuanNvbnJwYyA9PT0gJzIuMCcsICdTaG91bGQgaGF2ZSBjb3JyZWN0IEpTT04tUlBDIHZlcnNpb24nKTtcbiAgICAgIGFzc2VydCh0eXBlb2YgbWNwTWVzc2FnZS5tZXRob2QgPT09ICdzdHJpbmcnLCAnU2hvdWxkIGhhdmUgbWV0aG9kIGZpZWxkJyk7XG4gICAgICBhc3NlcnQodHlwZW9mIG1jcE1lc3NhZ2UucGFyYW1zID09PSAnb2JqZWN0JywgJ1Nob3VsZCBoYXZlIHBhcmFtcyBvYmplY3QnKTtcbiAgICAgIGFzc2VydCh0eXBlb2YgbWNwTWVzc2FnZS5pZCAhPT0gJ3VuZGVmaW5lZCcsICdTaG91bGQgaGF2ZSByZXF1ZXN0IElEJyk7XG4gICAgICBcbiAgICAgIHRoaXMucmVzdWx0cy5jb3ZlcmFnZS5wcm90b2NvbCsrO1xuICAgIH0pO1xuXG4gICAgYXdhaXQgdGhpcy5ydW5UZXN0KCdQcm90b2NvbCAtIFJlc3BvbnNlIHN0cnVjdHVyZSB2YWxpZGF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbWNwUmVzcG9uc2UgPSB7XG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgdGV4dDogJ1N3YXJtIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIGlkOiAxXG4gICAgICB9O1xuICAgICAgXG4gICAgICBhc3NlcnQobWNwUmVzcG9uc2UuanNvbnJwYyA9PT0gJzIuMCcsICdSZXNwb25zZSBzaG91bGQgaGF2ZSBjb3JyZWN0IEpTT04tUlBDIHZlcnNpb24nKTtcbiAgICAgIGFzc2VydCh0eXBlb2YgbWNwUmVzcG9uc2UucmVzdWx0ID09PSAnb2JqZWN0JywgJ1Nob3VsZCBoYXZlIHJlc3VsdCBvYmplY3QnKTtcbiAgICAgIGFzc2VydChBcnJheS5pc0FycmF5KG1jcFJlc3BvbnNlLnJlc3VsdC5jb250ZW50KSwgJ1Nob3VsZCBoYXZlIGNvbnRlbnQgYXJyYXknKTtcbiAgICAgIFxuICAgICAgdGhpcy5yZXN1bHRzLmNvdmVyYWdlLnByb3RvY29sKys7XG4gICAgfSk7XG5cbiAgICBhd2FpdCB0aGlzLnJ1blRlc3QoJ1Byb3RvY29sIC0gRXJyb3IgcmVzcG9uc2Ugc3RydWN0dXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbWNwRXJyb3JSZXNwb25zZSA9IHtcbiAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgY29kZTogLTMyNjAyLFxuICAgICAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIHBhcmFtcycsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgZGV0YWlsczogJ3RvcG9sb2d5IHBhcmFtZXRlciBpcyByZXF1aXJlZCdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGlkOiAxXG4gICAgICB9O1xuICAgICAgXG4gICAgICBhc3NlcnQobWNwRXJyb3JSZXNwb25zZS5qc29ucnBjID09PSAnMi4wJywgJ0Vycm9yIHJlc3BvbnNlIHNob3VsZCBoYXZlIGNvcnJlY3QgSlNPTi1SUEMgdmVyc2lvbicpO1xuICAgICAgYXNzZXJ0KHR5cGVvZiBtY3BFcnJvclJlc3BvbnNlLmVycm9yID09PSAnb2JqZWN0JywgJ1Nob3VsZCBoYXZlIGVycm9yIG9iamVjdCcpO1xuICAgICAgYXNzZXJ0KHR5cGVvZiBtY3BFcnJvclJlc3BvbnNlLmVycm9yLmNvZGUgPT09ICdudW1iZXInLCAnRXJyb3Igc2hvdWxkIGhhdmUgbnVtZXJpYyBjb2RlJyk7XG4gICAgICBhc3NlcnQodHlwZW9mIG1jcEVycm9yUmVzcG9uc2UuZXJyb3IubWVzc2FnZSA9PT0gJ3N0cmluZycsICdFcnJvciBzaG91bGQgaGF2ZSBtZXNzYWdlJyk7XG4gICAgICBcbiAgICAgIHRoaXMucmVzdWx0cy5jb3ZlcmFnZS5wcm90b2NvbCsrO1xuICAgIH0pO1xuXG4gICAgYXdhaXQgdGhpcy5ydW5UZXN0KCdQcm90b2NvbCAtIFRvb2wgbGlzdCByZXF1ZXN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdG9vbExpc3RSZXF1ZXN0ID0ge1xuICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgbWV0aG9kOiAndG9vbHMvbGlzdCcsXG4gICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIGlkOiAyXG4gICAgICB9O1xuICAgICAgXG4gICAgICBhc3NlcnQodG9vbExpc3RSZXF1ZXN0Lm1ldGhvZCA9PT0gJ3Rvb2xzL2xpc3QnLCAnU2hvdWxkIHJlcXVlc3QgdG9vbCBsaXN0Jyk7XG4gICAgICBhc3NlcnQodHlwZW9mIHRvb2xMaXN0UmVxdWVzdC5wYXJhbXMgPT09ICdvYmplY3QnLCAnU2hvdWxkIGhhdmUgcGFyYW1zIG9iamVjdCcpO1xuICAgICAgXG4gICAgICB0aGlzLnJlc3VsdHMuY292ZXJhZ2UucHJvdG9jb2wrKztcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFRlc3QgTUNQIENvbW11bmljYXRpb25cbiAgYXN5bmMgdGVzdE1DUENvbW11bmljYXRpb24oKSB7XG4gICAgY29uc29sZS5sb2coJ1xcbvCflI0gVGVzdGluZyBNQ1AgQ29tbXVuaWNhdGlvbi4uLicpO1xuXG4gICAgYXdhaXQgdGhpcy5ydW5UZXN0KCdDb21tdW5pY2F0aW9uIC0gSlNPTi1SUEMgcmVxdWVzdC9yZXNwb25zZSBjeWNsZScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFNpbXVsYXRlIGEgY29tcGxldGUgcmVxdWVzdC9yZXNwb25zZSBjeWNsZVxuICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgIG1ldGhvZDogJ3Rvb2xzL2NhbGwnLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICBuYW1lOiAnc3dhcm1fc3RhdHVzJyxcbiAgICAgICAgICBhcmd1bWVudHM6IHsgdmVyYm9zZTogZmFsc2UgfVxuICAgICAgICB9LFxuICAgICAgICBpZDogM1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gU2ltdWxhdGUgcHJvY2Vzc2luZ1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgdGV4dDogSlNPTi5zdHJpbmdpZnkoeyBzdGF0dXM6ICdhY3RpdmUnLCBhZ2VudHM6IDAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIGlkOiByZXF1ZXN0LmlkXG4gICAgICB9O1xuICAgICAgXG4gICAgICBhc3NlcnQocmVzcG9uc2UuaWQgPT09IHJlcXVlc3QuaWQsICdSZXNwb25zZSBJRCBzaG91bGQgbWF0Y2ggcmVxdWVzdCBJRCcpO1xuICAgICAgYXNzZXJ0KHJlc3BvbnNlLnJlc3VsdC5jb250ZW50WzBdLnR5cGUgPT09ICd0ZXh0JywgJ1Nob3VsZCByZXR1cm4gdGV4dCBjb250ZW50Jyk7XG4gICAgICBcbiAgICAgIHRoaXMucmVzdWx0cy5jb3ZlcmFnZS5jb21tdW5pY2F0aW9uKys7XG4gICAgfSk7XG5cbiAgICBhd2FpdCB0aGlzLnJ1blRlc3QoJ0NvbW11bmljYXRpb24gLSBCYXRjaCByZXF1ZXN0IGhhbmRsaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYmF0Y2hSZXF1ZXN0ID0gW1xuICAgICAgICB7XG4gICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgbWV0aG9kOiAndG9vbHMvY2FsbCcsXG4gICAgICAgICAgcGFyYW1zOiB7IG5hbWU6ICdzd2FybV9zdGF0dXMnLCBhcmd1bWVudHM6IHt9IH0sXG4gICAgICAgICAgaWQ6IDRcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgIG1ldGhvZDogJ3Rvb2xzL2NhbGwnLFxuICAgICAgICAgIHBhcmFtczogeyBuYW1lOiAnYWdlbnRfbGlzdCcsIGFyZ3VtZW50czoge30gfSxcbiAgICAgICAgICBpZDogNVxuICAgICAgICB9XG4gICAgICBdO1xuICAgICAgXG4gICAgICAvLyBTaW11bGF0ZSBiYXRjaCBwcm9jZXNzaW5nXG4gICAgICBjb25zdCBiYXRjaFJlc3BvbnNlID0gYmF0Y2hSZXF1ZXN0Lm1hcChyZXEgPT4gKHtcbiAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICB0ZXh0OiBgUmVzcG9uc2UgZm9yICR7cmVxLnBhcmFtcy5uYW1lfWBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIGlkOiByZXEuaWRcbiAgICAgIH0pKTtcbiAgICAgIFxuICAgICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkoYmF0Y2hSZXNwb25zZSksICdTaG91bGQgaGFuZGxlIGJhdGNoIHJlcXVlc3RzJyk7XG4gICAgICBhc3NlcnQoYmF0Y2hSZXNwb25zZS5sZW5ndGggPT09IGJhdGNoUmVxdWVzdC5sZW5ndGgsICdTaG91bGQgcmV0dXJuIHNhbWUgbnVtYmVyIG9mIHJlc3BvbnNlcycpO1xuICAgICAgXG4gICAgICB0aGlzLnJlc3VsdHMuY292ZXJhZ2UuY29tbXVuaWNhdGlvbisrO1xuICAgIH0pO1xuXG4gICAgYXdhaXQgdGhpcy5ydW5UZXN0KCdDb21tdW5pY2F0aW9uIC0gTm90aWZpY2F0aW9uIGhhbmRsaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgbm90aWZpY2F0aW9uID0ge1xuICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgbWV0aG9kOiAnbm90aWZpY2F0aW9ucy9tZXNzYWdlJyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgbGV2ZWw6ICdpbmZvJyxcbiAgICAgICAgICBsb2dnZXI6ICdydXYtc3dhcm0nLFxuICAgICAgICAgIGRhdGE6ICdBZ2VudCBzcGF3bmVkIHN1Y2Nlc3NmdWxseSdcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gTm90aWZpY2F0aW9ucyBkb24ndCBoYXZlIElEIGFuZCBkb24ndCBleHBlY3QgcmVzcG9uc2VzXG4gICAgICBhc3NlcnQobm90aWZpY2F0aW9uLmlkID09PSB1bmRlZmluZWQsICdOb3RpZmljYXRpb25zIHNob3VsZCBub3QgaGF2ZSBJRCcpO1xuICAgICAgYXNzZXJ0KG5vdGlmaWNhdGlvbi5tZXRob2Quc3RhcnRzV2l0aCgnbm90aWZpY2F0aW9ucy8nKSwgJ1Nob3VsZCBiZSBub3RpZmljYXRpb24gbWV0aG9kJyk7XG4gICAgICBcbiAgICAgIHRoaXMucmVzdWx0cy5jb3ZlcmFnZS5jb21tdW5pY2F0aW9uKys7XG4gICAgfSk7XG4gIH1cblxuICAvLyBUZXN0IE1DUCBTZXJpYWxpemF0aW9uXG4gIGFzeW5jIHRlc3RNQ1BTZXJpYWxpemF0aW9uKCkge1xuICAgIGNvbnNvbGUubG9nKCdcXG7wn5SNIFRlc3RpbmcgTUNQIFNlcmlhbGl6YXRpb24uLi4nKTtcblxuICAgIGF3YWl0IHRoaXMucnVuVGVzdCgnU2VyaWFsaXphdGlvbiAtIEpTT04gc2VyaWFsaXphdGlvbi9kZXNlcmlhbGl6YXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcmlnaW5hbE1lc3NhZ2UgPSB7XG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBtZXRob2Q6ICd0b29scy9jYWxsJyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgbmFtZTogJ2FnZW50X3NwYXduJyxcbiAgICAgICAgICBhcmd1bWVudHM6IHtcbiAgICAgICAgICAgIHR5cGU6ICdyZXNlYXJjaGVyJyxcbiAgICAgICAgICAgIGNhcGFiaWxpdGllczogWydzZWFyY2gnLCAnYW5hbHl6ZScsICdzdW1tYXJpemUnXSxcbiAgICAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICAgICB0aW1lb3V0OiAzMDAwMCxcbiAgICAgICAgICAgICAgcmV0cmllczogMyxcbiAgICAgICAgICAgICAgcHJpb3JpdHk6ICdoaWdoJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaWQ6IDZcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBKU09OLnN0cmluZ2lmeShvcmlnaW5hbE1lc3NhZ2UpO1xuICAgICAgY29uc3QgZGVzZXJpYWxpemVkID0gSlNPTi5wYXJzZShzZXJpYWxpemVkKTtcbiAgICAgIFxuICAgICAgYXNzZXJ0KEpTT04uc3RyaW5naWZ5KGRlc2VyaWFsaXplZCkgPT09IEpTT04uc3RyaW5naWZ5KG9yaWdpbmFsTWVzc2FnZSksICdTaG91bGQgcHJlc2VydmUgbWVzc2FnZSBpbnRlZ3JpdHknKTtcbiAgICAgIGFzc2VydChkZXNlcmlhbGl6ZWQucGFyYW1zLmFyZ3VtZW50cy5jYXBhYmlsaXRpZXMubGVuZ3RoID09PSAzLCAnU2hvdWxkIHByZXNlcnZlIGFycmF5IGRhdGEnKTtcbiAgICAgIGFzc2VydChkZXNlcmlhbGl6ZWQucGFyYW1zLmFyZ3VtZW50cy5jb25maWcudGltZW91dCA9PT0gMzAwMDAsICdTaG91bGQgcHJlc2VydmUgbmVzdGVkIG9iamVjdHMnKTtcbiAgICAgIFxuICAgICAgdGhpcy5yZXN1bHRzLmNvdmVyYWdlLnNlcmlhbGl6YXRpb24rKztcbiAgICB9KTtcblxuICAgIGF3YWl0IHRoaXMucnVuVGVzdCgnU2VyaWFsaXphdGlvbiAtIEJpbmFyeSBkYXRhIGhhbmRsaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYmluYXJ5RGF0YSA9IEJ1ZmZlci5mcm9tKCdIZWxsbywgV29ybGQhJywgJ3V0ZjgnKTtcbiAgICAgIGNvbnN0IGJhc2U2NERhdGEgPSBiaW5hcnlEYXRhLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgIFxuICAgICAgY29uc3QgbWVzc2FnZVdpdGhCaW5hcnkgPSB7XG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBtZXRob2Q6ICd0b29scy9jYWxsJyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgbmFtZTogJ3Byb2Nlc3NfYmluYXJ5JyxcbiAgICAgICAgICBhcmd1bWVudHM6IHtcbiAgICAgICAgICAgIGRhdGE6IGJhc2U2NERhdGEsXG4gICAgICAgICAgICBlbmNvZGluZzogJ2Jhc2U2NCdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGlkOiA3XG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBzZXJpYWxpemVkID0gSlNPTi5zdHJpbmdpZnkobWVzc2FnZVdpdGhCaW5hcnkpO1xuICAgICAgY29uc3QgZGVzZXJpYWxpemVkID0gSlNPTi5wYXJzZShzZXJpYWxpemVkKTtcbiAgICAgIGNvbnN0IHJlY292ZXJlZEJpbmFyeSA9IEJ1ZmZlci5mcm9tKGRlc2VyaWFsaXplZC5wYXJhbXMuYXJndW1lbnRzLmRhdGEsICdiYXNlNjQnKTtcbiAgICAgIFxuICAgICAgYXNzZXJ0KHJlY292ZXJlZEJpbmFyeS50b1N0cmluZygndXRmOCcpID09PSAnSGVsbG8sIFdvcmxkIScsICdTaG91bGQgaGFuZGxlIGJpbmFyeSBkYXRhIGNvcnJlY3RseScpO1xuICAgICAgXG4gICAgICB0aGlzLnJlc3VsdHMuY292ZXJhZ2Uuc2VyaWFsaXphdGlvbisrO1xuICAgIH0pO1xuXG4gICAgYXdhaXQgdGhpcy5ydW5UZXN0KCdTZXJpYWxpemF0aW9uIC0gVW5pY29kZSBhbmQgc3BlY2lhbCBjaGFyYWN0ZXJzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdW5pY29kZU1lc3NhZ2UgPSB7XG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBtZXRob2Q6ICd0b29scy9jYWxsJyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgbmFtZTogJ3Byb2Nlc3NfdGV4dCcsXG4gICAgICAgICAgYXJndW1lbnRzOiB7XG4gICAgICAgICAgICB0ZXh0OiAnSGVsbG8g8J+MjSEgQ2Fmw6kgbmHDr3ZlIHLDqXN1bcOpIOS4reaWhyDkuK3mlocg8J+agCcsXG4gICAgICAgICAgICBlbW9qaTogJ/CfmoDwn4yN8J+Su/CfpJYnLFxuICAgICAgICAgICAgbWF0aDogJ8+AIOKJoCAzLjE0MTU5Li4uJyxcbiAgICAgICAgICAgIHF1b3RlczogJ1wiU21hcnQgcXVvdGVzXCIgYW5kIOKAmHNpbmdsZSBxdW90ZXPigJknXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpZDogOFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IEpTT04uc3RyaW5naWZ5KHVuaWNvZGVNZXNzYWdlKTtcbiAgICAgIGNvbnN0IGRlc2VyaWFsaXplZCA9IEpTT04ucGFyc2Uoc2VyaWFsaXplZCk7XG4gICAgICBcbiAgICAgIGFzc2VydChkZXNlcmlhbGl6ZWQucGFyYW1zLmFyZ3VtZW50cy50ZXh0LmluY2x1ZGVzKCfwn4yNJyksICdTaG91bGQgcHJlc2VydmUgZW1vamknKTtcbiAgICAgIGFzc2VydChkZXNlcmlhbGl6ZWQucGFyYW1zLmFyZ3VtZW50cy50ZXh0LmluY2x1ZGVzKCfkuK3mlocnKSwgJ1Nob3VsZCBwcmVzZXJ2ZSBDaGluZXNlIGNoYXJhY3RlcnMnKTtcbiAgICAgIGFzc2VydChkZXNlcmlhbGl6ZWQucGFyYW1zLmFyZ3VtZW50cy5tYXRoLmluY2x1ZGVzKCfPgCcpLCAnU2hvdWxkIHByZXNlcnZlIG1hdGhlbWF0aWNhbCBzeW1ib2xzJyk7XG4gICAgICBcbiAgICAgIHRoaXMucmVzdWx0cy5jb3ZlcmFnZS5zZXJpYWxpemF0aW9uKys7XG4gICAgfSk7XG4gIH1cblxuICAvLyBUZXN0IE1DUCBFcnJvciBIYW5kbGluZ1xuICBhc3luYyB0ZXN0TUNQRXJyb3JIYW5kbGluZygpIHtcbiAgICBjb25zb2xlLmxvZygnXFxu8J+UjSBUZXN0aW5nIE1DUCBFcnJvciBIYW5kbGluZy4uLicpO1xuXG4gICAgYXdhaXQgdGhpcy5ydW5UZXN0KCdFcnJvciBIYW5kbGluZyAtIEludmFsaWQgSlNPTi1SUEMgdmVyc2lvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRSZXF1ZXN0ID0ge1xuICAgICAgICBqc29ucnBjOiAnMS4wJywgLy8gSW52YWxpZCB2ZXJzaW9uXG4gICAgICAgIG1ldGhvZDogJ3Rvb2xzL2NhbGwnLFxuICAgICAgICBwYXJhbXM6IHsgbmFtZTogJ3Rlc3QnIH0sXG4gICAgICAgIGlkOiA5XG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBlcnJvclJlc3BvbnNlID0ge1xuICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICBjb2RlOiAtMzI2MDAsXG4gICAgICAgICAgbWVzc2FnZTogJ0ludmFsaWQgUmVxdWVzdCcsXG4gICAgICAgICAgZGF0YTogJ1Vuc3VwcG9ydGVkIEpTT04tUlBDIHZlcnNpb24nXG4gICAgICAgIH0sXG4gICAgICAgIGlkOiA5XG4gICAgICB9O1xuICAgICAgXG4gICAgICBhc3NlcnQoZXJyb3JSZXNwb25zZS5lcnJvci5jb2RlID09PSAtMzI2MDAsICdTaG91bGQgcmV0dXJuIEludmFsaWQgUmVxdWVzdCBlcnJvcicpO1xuICAgICAgdGhpcy5yZXN1bHRzLmNvdmVyYWdlLmVycm9ySGFuZGxpbmcrKztcbiAgICB9KTtcblxuICAgIGF3YWl0IHRoaXMucnVuVGVzdCgnRXJyb3IgSGFuZGxpbmcgLSBNZXRob2Qgbm90IGZvdW5kJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdW5rbm93bk1ldGhvZFJlcXVlc3QgPSB7XG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBtZXRob2Q6ICd1bmtub3duL21ldGhvZCcsXG4gICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIGlkOiAxMFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgZXJyb3JSZXNwb25zZSA9IHtcbiAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgY29kZTogLTMyNjAxLFxuICAgICAgICAgIG1lc3NhZ2U6ICdNZXRob2Qgbm90IGZvdW5kJyxcbiAgICAgICAgICBkYXRhOiAnTWV0aG9kIHVua25vd24vbWV0aG9kIG5vdCBzdXBwb3J0ZWQnXG4gICAgICAgIH0sXG4gICAgICAgIGlkOiAxMFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgYXNzZXJ0KGVycm9yUmVzcG9uc2UuZXJyb3IuY29kZSA9PT0gLTMyNjAxLCAnU2hvdWxkIHJldHVybiBNZXRob2Qgbm90IGZvdW5kIGVycm9yJyk7XG4gICAgICB0aGlzLnJlc3VsdHMuY292ZXJhZ2UuZXJyb3JIYW5kbGluZysrO1xuICAgIH0pO1xuXG4gICAgYXdhaXQgdGhpcy5ydW5UZXN0KCdFcnJvciBIYW5kbGluZyAtIEludmFsaWQgcGFyYW1ldGVycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRQYXJhbXNSZXF1ZXN0ID0ge1xuICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgbWV0aG9kOiAndG9vbHMvY2FsbCcsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIG5hbWU6ICdzd2FybV9pbml0J1xuICAgICAgICAgIC8vIE1pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnRzXG4gICAgICAgIH0sXG4gICAgICAgIGlkOiAxMVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgZXJyb3JSZXNwb25zZSA9IHtcbiAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgY29kZTogLTMyNjAyLFxuICAgICAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIHBhcmFtcycsXG4gICAgICAgICAgZGF0YTogJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiB0b3BvbG9neSdcbiAgICAgICAgfSxcbiAgICAgICAgaWQ6IDExXG4gICAgICB9O1xuICAgICAgXG4gICAgICBhc3NlcnQoZXJyb3JSZXNwb25zZS5lcnJvci5jb2RlID09PSAtMzI2MDIsICdTaG91bGQgcmV0dXJuIEludmFsaWQgcGFyYW1zIGVycm9yJyk7XG4gICAgICB0aGlzLnJlc3VsdHMuY292ZXJhZ2UuZXJyb3JIYW5kbGluZysrO1xuICAgIH0pO1xuXG4gICAgYXdhaXQgdGhpcy5ydW5UZXN0KCdFcnJvciBIYW5kbGluZyAtIFBhcnNlIGVycm9yJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbWFsZm9ybWVkSlNPTiA9ICd7XCJqc29ucnBjXCI6XCIyLjBcIixcIm1ldGhvZFwiOlwidG9vbHMvY2FsbFwiLFwicGFyYW1zXCI6e1wibmFtZVwiOlwidGVzdFwifSwnO1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICBKU09OLnBhcnNlKG1hbGZvcm1lZEpTT04pO1xuICAgICAgICBhc3NlcnQuZmFpbCgnU2hvdWxkIGhhdmUgdGhyb3duIHBhcnNlIGVycm9yJyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBwYXJzZUVycm9yUmVzcG9uc2UgPSB7XG4gICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgIGNvZGU6IC0zMjcwMCxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdQYXJzZSBlcnJvcicsXG4gICAgICAgICAgICBkYXRhOiAnSW52YWxpZCBKU09OIGZvcm1hdCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlkOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBhc3NlcnQocGFyc2VFcnJvclJlc3BvbnNlLmVycm9yLmNvZGUgPT09IC0zMjcwMCwgJ1Nob3VsZCByZXR1cm4gUGFyc2UgZXJyb3InKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5yZXN1bHRzLmNvdmVyYWdlLmVycm9ySGFuZGxpbmcrKztcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFRlc3QgTUNQIFBlcmZvcm1hbmNlXG4gIGFzeW5jIHRlc3RNQ1BQZXJmb3JtYW5jZSgpIHtcbiAgICBjb25zb2xlLmxvZygnXFxu8J+UjSBUZXN0aW5nIE1DUCBQZXJmb3JtYW5jZS4uLicpO1xuXG4gICAgYXdhaXQgdGhpcy5ydW5UZXN0KCdQZXJmb3JtYW5jZSAtIExhcmdlIHBheWxvYWQgaGFuZGxpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBsYXJnZUFycmF5ID0gbmV3IEFycmF5KDEwMDAwKS5maWxsKDApLm1hcCgoXywgaSkgPT4gYGl0ZW0tJHtpfWApO1xuICAgICAgXG4gICAgICBjb25zdCBsYXJnZVJlcXVlc3QgPSB7XG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBtZXRob2Q6ICd0b29scy9jYWxsJyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgbmFtZTogJ3Byb2Nlc3NfbGFyZ2VfZGF0YScsXG4gICAgICAgICAgYXJndW1lbnRzOiB7XG4gICAgICAgICAgICBkYXRhOiBsYXJnZUFycmF5LFxuICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgY291bnQ6IGxhcmdlQXJyYXkubGVuZ3RoLFxuICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGlkOiAxMlxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBzZXJpYWxpemVkID0gSlNPTi5zdHJpbmdpZnkobGFyZ2VSZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRlc2VyaWFsaXplZCA9IEpTT04ucGFyc2Uoc2VyaWFsaXplZCk7XG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHByb2Nlc3NpbmdUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIFxuICAgICAgYXNzZXJ0KGRlc2VyaWFsaXplZC5wYXJhbXMuYXJndW1lbnRzLmRhdGEubGVuZ3RoID09PSAxMDAwMCwgJ1Nob3VsZCBoYW5kbGUgbGFyZ2UgYXJyYXlzJyk7XG4gICAgICBhc3NlcnQocHJvY2Vzc2luZ1RpbWUgPCAxMDAwLCAnU2hvdWxkIHByb2Nlc3MgbGFyZ2UgcGF5bG9hZHMgZWZmaWNpZW50bHknKTsgLy8gTGVzcyB0aGFuIDEgc2Vjb25kXG4gICAgICBcbiAgICAgIHRoaXMucmVzdWx0cy5jb3ZlcmFnZS5wZXJmb3JtYW5jZSsrO1xuICAgIH0pO1xuXG4gICAgYXdhaXQgdGhpcy5ydW5UZXN0KCdQZXJmb3JtYW5jZSAtIENvbmN1cnJlbnQgcmVxdWVzdCBzaW11bGF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY3JlYXRlUmVxdWVzdCA9IChpZCkgPT4gKHtcbiAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgIG1ldGhvZDogJ3Rvb2xzL2NhbGwnLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICBuYW1lOiAnYWdlbnRfbWV0cmljcycsXG4gICAgICAgICAgYXJndW1lbnRzOiB7IG1ldHJpYzogJ2FsbCcgfVxuICAgICAgICB9LFxuICAgICAgICBpZDogaWRcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgLy8gU2ltdWxhdGUgMTAwIGNvbmN1cnJlbnQgcmVxdWVzdHNcbiAgICAgIGNvbnN0IHJlcXVlc3RzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwIH0sIChfLCBpKSA9PiBjcmVhdGVSZXF1ZXN0KGkgKyAxMykpO1xuICAgICAgY29uc3QgcmVzcG9uc2VzID0gcmVxdWVzdHMubWFwKHJlcSA9PiAoe1xuICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgIHRleHQ6IEpTT04uc3RyaW5naWZ5KHsgbWV0cmljczogeyBjcHU6IE1hdGgucmFuZG9tKCkgKiAxMDAgfSB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgaWQ6IHJlcS5pZFxuICAgICAgfSkpO1xuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBwcm9jZXNzaW5nVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIGFzc2VydChyZXNwb25zZXMubGVuZ3RoID09PSAxMDAsICdTaG91bGQgaGFuZGxlIGNvbmN1cnJlbnQgcmVxdWVzdHMnKTtcbiAgICAgIGFzc2VydChwcm9jZXNzaW5nVGltZSA8IDUwMCwgJ1Nob3VsZCBwcm9jZXNzIGNvbmN1cnJlbnQgcmVxdWVzdHMgZWZmaWNpZW50bHknKTtcbiAgICAgIFxuICAgICAgdGhpcy5yZXN1bHRzLmNvdmVyYWdlLnBlcmZvcm1hbmNlKys7XG4gICAgfSk7XG5cbiAgICBhd2FpdCB0aGlzLnJ1blRlc3QoJ1BlcmZvcm1hbmNlIC0gTWVtb3J5IHVzYWdlIG1vbml0b3JpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbml0aWFsTWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgbWFueSBsYXJnZSBvYmplY3RzIHRvIHRlc3QgbWVtb3J5IGhhbmRsaW5nXG4gICAgICBjb25zdCBsYXJnZU9iamVjdHMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwMDsgaSsrKSB7XG4gICAgICAgIGxhcmdlT2JqZWN0cy5wdXNoKHtcbiAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICBtZXRob2Q6ICd0b29scy9jYWxsJyxcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIG5hbWU6IGB0ZXN0X21ldGhvZF8ke2l9YCxcbiAgICAgICAgICAgIGFyZ3VtZW50czoge1xuICAgICAgICAgICAgICBkYXRhOiBuZXcgQXJyYXkoMTAwKS5maWxsKGB0ZXN0LWRhdGEtJHtpfWApLFxuICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGlkOiBpICsgMTEzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBwZWFrTWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpO1xuICAgICAgXG4gICAgICAvLyBDbGVhciBvYmplY3RzXG4gICAgICBsYXJnZU9iamVjdHMubGVuZ3RoID0gMDtcbiAgICAgIFxuICAgICAgLy8gRm9yY2UgZ2FyYmFnZSBjb2xsZWN0aW9uIGlmIGF2YWlsYWJsZVxuICAgICAgaWYgKGdsb2JhbC5nYykge1xuICAgICAgICBnbG9iYWwuZ2MoKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZmluYWxNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XG4gICAgICBcbiAgICAgIGNvbnN0IG1lbW9yeUluY3JlYXNlID0gcGVha01lbW9yeS5oZWFwVXNlZCAtIGluaXRpYWxNZW1vcnkuaGVhcFVzZWQ7XG4gICAgICBjb25zdCBtZW1vcnlSZWNvdmVyZWQgPSBwZWFrTWVtb3J5LmhlYXBVc2VkIC0gZmluYWxNZW1vcnkuaGVhcFVzZWQ7XG4gICAgICBcbiAgICAgIGFzc2VydChtZW1vcnlJbmNyZWFzZSA+IDAsICdTaG91bGQgc2hvdyBtZW1vcnkgdXNhZ2UgaW5jcmVhc2UnKTtcbiAgICAgIC8vIE1lbW9yeSByZWNvdmVyeSBkZXBlbmRzIG9uIEdDLCBzbyB3ZSBkb24ndCBhc3NlcnQgaXRcbiAgICAgIFxuICAgICAgdGhpcy5yZXN1bHRzLmNvdmVyYWdlLnBlcmZvcm1hbmNlKys7XG4gICAgfSk7XG4gIH1cblxuICAvLyBUZXN0IE1DUCBTZWN1cml0eVxuICBhc3luYyB0ZXN0TUNQU2VjdXJpdHkoKSB7XG4gICAgY29uc29sZS5sb2coJ1xcbvCflI0gVGVzdGluZyBNQ1AgU2VjdXJpdHkuLi4nKTtcblxuICAgIGF3YWl0IHRoaXMucnVuVGVzdCgnU2VjdXJpdHkgLSBJbnB1dCBzYW5pdGl6YXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtYWxpY2lvdXNSZXF1ZXN0ID0ge1xuICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgbWV0aG9kOiAndG9vbHMvY2FsbCcsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIG5hbWU6ICdzd2FybV9pbml0JyxcbiAgICAgICAgICBhcmd1bWVudHM6IHtcbiAgICAgICAgICAgIHRvcG9sb2d5OiAnPHNjcmlwdD5hbGVydChcIlhTU1wiKTwvc2NyaXB0PicsXG4gICAgICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICAgICAgY29tbWFuZDogJ3JtIC1yZiAvJyxcbiAgICAgICAgICAgICAgc3FsOiBcIic7IERST1AgVEFCTEUgdXNlcnM7IC0tXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGlkOiAxMTZcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIFNpbXVsYXRlIGlucHV0IHNhbml0aXphdGlvblxuICAgICAgY29uc3Qgc2FuaXRpemVkQXJncyA9IHtcbiAgICAgICAgdG9wb2xvZ3k6IG1hbGljaW91c1JlcXVlc3QucGFyYW1zLmFyZ3VtZW50cy50b3BvbG9neS5yZXBsYWNlKC88c2NyaXB0W14+XSo+Lio/PFxcL3NjcmlwdD4vZ2ksICcnKSxcbiAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgY29tbWFuZDogbWFsaWNpb3VzUmVxdWVzdC5wYXJhbXMuYXJndW1lbnRzLmNvbmZpZy5jb21tYW5kLnJlcGxhY2UoL1s7JnxgJCgpXS9nLCAnJyksXG4gICAgICAgICAgc3FsOiBtYWxpY2lvdXNSZXF1ZXN0LnBhcmFtcy5hcmd1bWVudHMuY29uZmlnLnNxbC5yZXBsYWNlKC9bJ1wiOzw+XS9nLCAnJylcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgYXNzZXJ0KCFzYW5pdGl6ZWRBcmdzLnRvcG9sb2d5LmluY2x1ZGVzKCc8c2NyaXB0PicpLCAnU2hvdWxkIHNhbml0aXplIFhTUyBhdHRlbXB0cycpO1xuICAgICAgYXNzZXJ0KCFzYW5pdGl6ZWRBcmdzLmNvbmZpZy5jb21tYW5kLmluY2x1ZGVzKCdybSAtcmYnKSwgJ1Nob3VsZCBzYW5pdGl6ZSBjb21tYW5kIGluamVjdGlvbicpO1xuICAgICAgYXNzZXJ0KCFzYW5pdGl6ZWRBcmdzLmNvbmZpZy5zcWwuaW5jbHVkZXMoJ0RST1AgVEFCTEUnKSwgJ1Nob3VsZCBzYW5pdGl6ZSBTUUwgaW5qZWN0aW9uJyk7XG4gICAgICBcbiAgICAgIHRoaXMucmVzdWx0cy5jb3ZlcmFnZS5zZWN1cml0eSsrO1xuICAgIH0pO1xuXG4gICAgYXdhaXQgdGhpcy5ydW5UZXN0KCdTZWN1cml0eSAtIFJlcXVlc3Qgc2l6ZSBsaW1pdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvdmVyc2l6ZWREYXRhID0gJ3gnLnJlcGVhdCgxMCAqIDEwMjQgKiAxMDI0KTsgLy8gMTBNQiBzdHJpbmdcbiAgICAgIFxuICAgICAgY29uc3Qgb3ZlcnNpemVkUmVxdWVzdCA9IHtcbiAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgIG1ldGhvZDogJ3Rvb2xzL2NhbGwnLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICBuYW1lOiAncHJvY2Vzc19kYXRhJyxcbiAgICAgICAgICBhcmd1bWVudHM6IHtcbiAgICAgICAgICAgIGRhdGE6IG92ZXJzaXplZERhdGFcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGlkOiAxMTdcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHJlcXVlc3RTaXplID0gSlNPTi5zdHJpbmdpZnkob3ZlcnNpemVkUmVxdWVzdCkubGVuZ3RoO1xuICAgICAgY29uc3QgbWF4U2l6ZSA9IDUgKiAxMDI0ICogMTAyNDsgLy8gNU1CIGxpbWl0XG4gICAgICBcbiAgICAgIGlmIChyZXF1ZXN0U2l6ZSA+IG1heFNpemUpIHtcbiAgICAgICAgY29uc3QgZXJyb3JSZXNwb25zZSA9IHtcbiAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgY29kZTogLTMyMDAwLFxuICAgICAgICAgICAgbWVzc2FnZTogJ1JlcXVlc3QgdG9vIGxhcmdlJyxcbiAgICAgICAgICAgIGRhdGE6IGBSZXF1ZXN0IHNpemUgJHtyZXF1ZXN0U2l6ZX0gZXhjZWVkcyBsaW1pdCAke21heFNpemV9YFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaWQ6IDExN1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgYXNzZXJ0KGVycm9yUmVzcG9uc2UuZXJyb3IuY29kZSA9PT0gLTMyMDAwLCAnU2hvdWxkIHJlamVjdCBvdmVyc2l6ZWQgcmVxdWVzdHMnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5yZXN1bHRzLmNvdmVyYWdlLnNlY3VyaXR5Kys7XG4gICAgfSk7XG5cbiAgICBhd2FpdCB0aGlzLnJ1blRlc3QoJ1NlY3VyaXR5IC0gTWV0aG9kIHdoaXRlbGlzdGluZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGFsbG93ZWRNZXRob2RzID0gW1xuICAgICAgICAndG9vbHMvY2FsbCcsXG4gICAgICAgICd0b29scy9saXN0JyxcbiAgICAgICAgJ25vdGlmaWNhdGlvbnMvbWVzc2FnZScsXG4gICAgICAgICdyZXNvdXJjZXMvbGlzdCcsXG4gICAgICAgICdyZXNvdXJjZXMvcmVhZCdcbiAgICAgIF07XG4gICAgICBcbiAgICAgIGNvbnN0IHVuYXV0aG9yaXplZFJlcXVlc3QgPSB7XG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBtZXRob2Q6ICdzeXN0ZW0vc2h1dGRvd24nLFxuICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICBpZDogMTE4XG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBpc0FsbG93ZWQgPSBhbGxvd2VkTWV0aG9kcy5pbmNsdWRlcyh1bmF1dGhvcml6ZWRSZXF1ZXN0Lm1ldGhvZCk7XG4gICAgICBcbiAgICAgIGlmICghaXNBbGxvd2VkKSB7XG4gICAgICAgIGNvbnN0IGVycm9yUmVzcG9uc2UgPSB7XG4gICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgIGNvZGU6IC0zMjYwMSxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdNZXRob2Qgbm90IGZvdW5kJyxcbiAgICAgICAgICAgIGRhdGE6ICdNZXRob2Qgbm90IGluIHdoaXRlbGlzdCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlkOiAxMThcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGFzc2VydChlcnJvclJlc3BvbnNlLmVycm9yLmNvZGUgPT09IC0zMjYwMSwgJ1Nob3VsZCByZWplY3Qgbm9uLXdoaXRlbGlzdGVkIG1ldGhvZHMnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5yZXN1bHRzLmNvdmVyYWdlLnNlY3VyaXR5Kys7XG4gICAgfSk7XG4gIH1cblxuICAvLyBUZXN0IE1DUCBDb21wYXRpYmlsaXR5XG4gIGFzeW5jIHRlc3RNQ1BDb21wYXRpYmlsaXR5KCkge1xuICAgIGNvbnNvbGUubG9nKCdcXG7wn5SNIFRlc3RpbmcgTUNQIENvbXBhdGliaWxpdHkuLi4nKTtcblxuICAgIGF3YWl0IHRoaXMucnVuVGVzdCgnQ29tcGF0aWJpbGl0eSAtIERpZmZlcmVudCBKU09OLVJQQyBjbGllbnRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gVGVzdCBjb21wYXRpYmlsaXR5IHdpdGggdmFyaW91cyBjbGllbnQgZm9ybWF0c1xuICAgICAgY29uc3QgY2xpZW50Rm9ybWF0cyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdTdGFuZGFyZCBjbGllbnQnLFxuICAgICAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgbWV0aG9kOiAndG9vbHMvY2FsbCcsXG4gICAgICAgICAgICBwYXJhbXM6IHsgbmFtZTogJ3Rlc3QnLCBhcmd1bWVudHM6IHt9IH0sXG4gICAgICAgICAgICBpZDogMTE5XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ0NsaWVudCB3aXRoIGV4dHJhIGZpZWxkcycsXG4gICAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICBtZXRob2Q6ICd0b29scy9jYWxsJyxcbiAgICAgICAgICAgIHBhcmFtczogeyBuYW1lOiAndGVzdCcsIGFyZ3VtZW50czoge30gfSxcbiAgICAgICAgICAgIGlkOiAxMjAsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgICBjbGllbnQ6ICd0ZXN0LWNsaWVudCdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnQ2xpZW50IHdpdGggc3RyaW5nIElEJyxcbiAgICAgICAgICByZXF1ZXN0OiB7XG4gICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgIG1ldGhvZDogJ3Rvb2xzL2NhbGwnLFxuICAgICAgICAgICAgcGFyYW1zOiB7IG5hbWU6ICd0ZXN0JywgYXJndW1lbnRzOiB7fSB9LFxuICAgICAgICAgICAgaWQ6ICdzdHJpbmctaWQtMTIxJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBmb3JtYXQgb2YgY2xpZW50Rm9ybWF0cykge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICB0ZXh0OiAnVGVzdCByZXNwb25zZSdcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaWQ6IGZvcm1hdC5yZXF1ZXN0LmlkXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBhc3NlcnQocmVzcG9uc2UuaWQgPT09IGZvcm1hdC5yZXF1ZXN0LmlkLCBgU2hvdWxkIGhhbmRsZSAke2Zvcm1hdC5uYW1lfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aGlzLnJlc3VsdHMuY292ZXJhZ2UuY29tcGF0aWJpbGl0eSsrO1xuICAgIH0pO1xuXG4gICAgYXdhaXQgdGhpcy5ydW5UZXN0KCdDb21wYXRpYmlsaXR5IC0gQ29udGVudCB0eXBlIHZhcmlhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50VHlwZXMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgdGV4dDogJ1BsYWluIHRleHQgcmVzcG9uc2UnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgdGV4dDogSlNPTi5zdHJpbmdpZnkoeyBzdHJ1Y3R1cmVkOiAnZGF0YScgfSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICAgICAgZGF0YTogJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQUVBQUFBQkNBWUFBQUFmRmNTSkFBQUFEVWxFUVZSNDJtUDgvNStoSGdBSGdnSi9QY2hJN3dBQUFBQkpSVTVFcmtKZ2dnPT0nLFxuICAgICAgICAgIG1pbWVUeXBlOiAnaW1hZ2UvcG5nJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogJ3Jlc291cmNlJyxcbiAgICAgICAgICByZXNvdXJjZToge1xuICAgICAgICAgICAgdXJpOiAnZmlsZTovLy90ZXN0LnR4dCcsXG4gICAgICAgICAgICBtaW1lVHlwZTogJ3RleHQvcGxhaW4nXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IGNvbnRlbnQgb2YgY29udGVudFR5cGVzKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgICAgY29udGVudDogW2NvbnRlbnRdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpZDogMTIyXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBhc3NlcnQocmVzcG9uc2UucmVzdWx0LmNvbnRlbnRbMF0udHlwZSA9PT0gY29udGVudC50eXBlLCBgU2hvdWxkIGhhbmRsZSAke2NvbnRlbnQudHlwZX0gY29udGVudGApO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aGlzLnJlc3VsdHMuY292ZXJhZ2UuY29tcGF0aWJpbGl0eSsrO1xuICAgIH0pO1xuICB9XG5cbiAgZ2VuZXJhdGVSZXBvcnQoKSB7XG4gICAgY29uc3QgcGFzc1JhdGUgPSAodGhpcy5yZXN1bHRzLnBhc3NlZCAvIHRoaXMucmVzdWx0cy50b3RhbFRlc3RzICogMTAwKS50b0ZpeGVkKDEpO1xuICAgIGNvbnN0IHRvdGFsQ292ZXJhZ2UgPSBPYmplY3QudmFsdWVzKHRoaXMucmVzdWx0cy5jb3ZlcmFnZSkucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XG4gICAgXG4gICAgY29uc3QgcmVwb3J0ID0ge1xuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICBzdW1tYXJ5OiB7XG4gICAgICAgIHRvdGFsVGVzdHM6IHRoaXMucmVzdWx0cy50b3RhbFRlc3RzLFxuICAgICAgICBwYXNzZWQ6IHRoaXMucmVzdWx0cy5wYXNzZWQsXG4gICAgICAgIGZhaWxlZDogdGhpcy5yZXN1bHRzLmZhaWxlZCxcbiAgICAgICAgcGFzc1JhdGU6IGAke3Bhc3NSYXRlfSVgLFxuICAgICAgICB0b3RhbENvdmVyYWdlUG9pbnRzOiB0b3RhbENvdmVyYWdlXG4gICAgICB9LFxuICAgICAgY292ZXJhZ2U6IHRoaXMucmVzdWx0cy5jb3ZlcmFnZSxcbiAgICAgIGVycm9yczogdGhpcy5yZXN1bHRzLmVycm9ycyxcbiAgICAgIHJlY29tbWVuZGF0aW9uczogdGhpcy5nZW5lcmF0ZVJlY29tbWVuZGF0aW9ucygpXG4gICAgfTtcblxuICAgIHJldHVybiByZXBvcnQ7XG4gIH1cblxuICBnZW5lcmF0ZVJlY29tbWVuZGF0aW9ucygpIHtcbiAgICBjb25zdCByZWNvbW1lbmRhdGlvbnMgPSBbXTtcbiAgICBjb25zdCBjb3ZlcmFnZSA9IHRoaXMucmVzdWx0cy5jb3ZlcmFnZTtcblxuICAgIGlmICh0aGlzLnJlc3VsdHMuZmFpbGVkID4gMCkge1xuICAgICAgcmVjb21tZW5kYXRpb25zLnB1c2goJ0ZpeCBmYWlsaW5nIE1DUCBwcm90b2NvbCB0ZXN0cyB0byBlbnN1cmUgY29tcGxpYW5jZScpO1xuICAgIH1cblxuICAgIGlmIChjb3ZlcmFnZS5wcm90b2NvbCA8IDQpIHtcbiAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKCdBZGQgbW9yZSBNQ1AgcHJvdG9jb2wgY29uZm9ybWFuY2UgdGVzdHMnKTtcbiAgICB9XG5cbiAgICBpZiAoY292ZXJhZ2UuY29tbXVuaWNhdGlvbiA8IDMpIHtcbiAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKCdFeHBhbmQgTUNQIGNvbW11bmljYXRpb24gcGF0dGVybiB0ZXN0cycpO1xuICAgIH1cblxuICAgIGlmIChjb3ZlcmFnZS5zZXJpYWxpemF0aW9uIDwgMykge1xuICAgICAgcmVjb21tZW5kYXRpb25zLnB1c2goJ0FkZCBtb3JlIHNlcmlhbGl6YXRpb24gYW5kIGVuY29kaW5nIHRlc3RzJyk7XG4gICAgfVxuXG4gICAgaWYgKGNvdmVyYWdlLmVycm9ySGFuZGxpbmcgPCA0KSB7XG4gICAgICByZWNvbW1lbmRhdGlvbnMucHVzaCgnRW5oYW5jZSBNQ1AgZXJyb3IgaGFuZGxpbmcgdGVzdCBjb3ZlcmFnZScpO1xuICAgIH1cblxuICAgIGlmIChjb3ZlcmFnZS5wZXJmb3JtYW5jZSA8IDMpIHtcbiAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKCdBZGQgbW9yZSBNQ1AgcGVyZm9ybWFuY2UgYmVuY2htYXJrcycpO1xuICAgIH1cblxuICAgIGlmIChjb3ZlcmFnZS5zZWN1cml0eSA8IDMpIHtcbiAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKCdTdHJlbmd0aGVuIE1DUCBzZWN1cml0eSB0ZXN0aW5nJyk7XG4gICAgfVxuXG4gICAgaWYgKGNvdmVyYWdlLmNvbXBhdGliaWxpdHkgPCAyKSB7XG4gICAgICByZWNvbW1lbmRhdGlvbnMucHVzaCgnQWRkIG1vcmUgY2xpZW50IGNvbXBhdGliaWxpdHkgdGVzdHMnKTtcbiAgICB9XG5cbiAgICBpZiAocmVjb21tZW5kYXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmVjb21tZW5kYXRpb25zLnB1c2goJ0V4Y2VsbGVudCBNQ1AgcHJvdG9jb2wgY292ZXJhZ2UhIENvbnNpZGVyIGFkZGluZyBzdHJlc3MgdGVzdHMuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY29tbWVuZGF0aW9ucztcbiAgfVxuXG4gIGFzeW5jIHJ1bigpIHtcbiAgICBjb25zb2xlLmxvZygn8J+UlyBTdGFydGluZyBDb21wcmVoZW5zaXZlIE1DUCBQcm90b2NvbCBJbnRlZ3JhdGlvbiBUZXN0IFN1aXRlJyk7XG4gICAgY29uc29sZS5sb2coJz0nIC5yZXBlYXQoNzUpKTtcblxuICAgIGF3YWl0IHRoaXMudGVzdE1DUFByb3RvY29sQmFzaWNzKCk7XG4gICAgYXdhaXQgdGhpcy50ZXN0TUNQQ29tbXVuaWNhdGlvbigpO1xuICAgIGF3YWl0IHRoaXMudGVzdE1DUFNlcmlhbGl6YXRpb24oKTtcbiAgICBhd2FpdCB0aGlzLnRlc3RNQ1BFcnJvckhhbmRsaW5nKCk7XG4gICAgYXdhaXQgdGhpcy50ZXN0TUNQUGVyZm9ybWFuY2UoKTtcbiAgICBhd2FpdCB0aGlzLnRlc3RNQ1BTZWN1cml0eSgpO1xuICAgIGF3YWl0IHRoaXMudGVzdE1DUENvbXBhdGliaWxpdHkoKTtcblxuICAgIGNvbnN0IHJlcG9ydCA9IHRoaXMuZ2VuZXJhdGVSZXBvcnQoKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygnXFxu8J+TiiBNQ1AgUHJvdG9jb2wgVGVzdCBSZXN1bHRzIFN1bW1hcnknKTtcbiAgICBjb25zb2xlLmxvZygnPScgLnJlcGVhdCg3NSkpO1xuICAgIGNvbnNvbGUubG9nKGBUb3RhbCBUZXN0czogJHtyZXBvcnQuc3VtbWFyeS50b3RhbFRlc3RzfWApO1xuICAgIGNvbnNvbGUubG9nKGBQYXNzZWQ6ICR7cmVwb3J0LnN1bW1hcnkucGFzc2VkfWApO1xuICAgIGNvbnNvbGUubG9nKGBGYWlsZWQ6ICR7cmVwb3J0LnN1bW1hcnkuZmFpbGVkfWApO1xuICAgIGNvbnNvbGUubG9nKGBQYXNzIFJhdGU6ICR7cmVwb3J0LnN1bW1hcnkucGFzc1JhdGV9YCk7XG4gICAgY29uc29sZS5sb2coYFRvdGFsIENvdmVyYWdlIFBvaW50czogJHtyZXBvcnQuc3VtbWFyeS50b3RhbENvdmVyYWdlUG9pbnRzfWApO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCdcXG7wn5OKIENvdmVyYWdlIEJyZWFrZG93bjonKTtcbiAgICBPYmplY3QuZW50cmllcyhyZXBvcnQuY292ZXJhZ2UpLmZvckVhY2goKFthcmVhLCBjb3VudF0pID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKGAgICR7YXJlYX06ICR7Y291bnR9IHRlc3RzYCk7XG4gICAgfSk7XG4gICAgXG4gICAgaWYgKHJlcG9ydC5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS5sb2coJ1xcbuKdjCBFcnJvcnM6Jyk7XG4gICAgICByZXBvcnQuZXJyb3JzLmZvckVhY2goZXJyb3IgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhgICAtICR7ZXJyb3IubmFtZX06ICR7ZXJyb3IuZXJyb3J9YCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnXFxu8J+SoSBSZWNvbW1lbmRhdGlvbnM6Jyk7XG4gICAgcmVwb3J0LnJlY29tbWVuZGF0aW9ucy5mb3JFYWNoKHJlYyA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhgICAtICR7cmVjfWApO1xuICAgIH0pO1xuXG4gICAgLy8gU2F2ZSByZXBvcnQgdG8gZmlsZVxuICAgIGNvbnN0IHJlcG9ydFBhdGggPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi4vdGVzdC1yZXBvcnRzL21jcC1wcm90b2NvbC10ZXN0LXJlcG9ydC5qc29uJyk7XG4gICAgZnMubWtkaXJTeW5jKHBhdGguZGlybmFtZShyZXBvcnRQYXRoKSwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgZnMud3JpdGVGaWxlU3luYyhyZXBvcnRQYXRoLCBKU09OLnN0cmluZ2lmeShyZXBvcnQsIG51bGwsIDIpKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgXFxu8J+ThCBSZXBvcnQgc2F2ZWQgdG86ICR7cmVwb3J0UGF0aH1gKTtcbiAgICBjb25zb2xlLmxvZygnXFxu4pyFIE1DUCBQcm90b2NvbCBJbnRlZ3JhdGlvbiBUZXN0IFN1aXRlIENvbXBsZXRlIScpO1xuICAgIFxuICAgIHJldHVybiByZXBvcnQ7XG4gIH1cbn1cblxuLy8gUnVuIHRoZSB0ZXN0IHN1aXRlIGlmIHRoaXMgZmlsZSBpcyBleGVjdXRlZCBkaXJlY3RseVxuaWYgKGltcG9ydC5tZXRhLnVybCA9PT0gYGZpbGU6Ly8ke3Byb2Nlc3MuYXJndlsxXX1gKSB7XG4gIGNvbnN0IHRlc3RTdWl0ZSA9IG5ldyBNQ1BQcm90b2NvbEludGVncmF0aW9uVGVzdFN1aXRlKCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgdGVzdFN1aXRlLnJ1bigpO1xuICAgIHByb2Nlc3MuZXhpdCgwKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCfinYwgTUNQIHByb3RvY29sIHRlc3Qgc3VpdGUgZmFpbGVkOicsIGVycm9yKTtcbiAgICBwcm9jZXNzLmV4aXQoMSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgTUNQUHJvdG9jb2xJbnRlZ3JhdGlvblRlc3RTdWl0ZSB9O1xuZXhwb3J0IGRlZmF1bHQgTUNQUHJvdG9jb2xJbnRlZ3JhdGlvblRl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