ba6feb140c5f780bf0c9980131440230
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
/**
 * Neural Network Edge Cases
 * Tests numerical stability, gradient issues, and model training edge cases
 */

import { describe, it, expect, jest, beforeEach, afterEach } from '@jest/globals';
import { NeuralNetworkManager } from '../../src/neural-network-manager.js';
import { NeuralAgent } from '../../src/neural-agent.js';
describe('Neural Network Edge Cases', () => {
  let manager;
  beforeEach(() => {
    manager = new NeuralNetworkManager();
  });
  describe('Numerical Stability Edge Cases', () => {
    it('should handle NaN inputs gracefully', /*#__PURE__*/_asyncToGenerator(function* () {
      const config = {
        type: 'feedforward',
        layers: [4, 8, 4],
        activation: 'relu'
      };
      const network = yield manager.create(config);
      const invalidInputs = [[NaN, 1, 2, 3], [1, NaN, 2, 3], [1, 2, NaN, 3], [1, 2, 3, NaN], [NaN, NaN, NaN, NaN]];
      for (const input of invalidInputs) {
        const result = yield network.forward(input);

        // Network should handle NaN inputs without crashing
        expect(result).toBeDefined();
        expect(Array.isArray(result)).toBe(true);

        // Output should either be valid numbers or NaN (consistent behavior)
        result.forEach(value => {
          expect(typeof value).toBe('number');
        });
      }
    }));
    it('should handle Infinity inputs', /*#__PURE__*/_asyncToGenerator(function* () {
      const config = {
        type: 'feedforward',
        layers: [2, 4, 2],
        activation: 'tanh'
      };
      const network = yield manager.create(config);
      const infinityInputs = [[Infinity, 1], [1, Infinity], [-Infinity, 1], [1, -Infinity], [Infinity, -Infinity], [Infinity, Infinity], [-Infinity, -Infinity]];
      for (const input of infinityInputs) {
        const result = yield network.forward(input);
        expect(result).toBeDefined();
        expect(Array.isArray(result)).toBe(true);
        expect(result.length).toBe(2);

        // tanh should clamp infinite values to -1 or 1
        result.forEach(value => {
          expect(Math.abs(value)).toBeLessThanOrEqual(1);
        });
      }
    }));
    it('should handle very small numbers (underflow)', /*#__PURE__*/_asyncToGenerator(function* () {
      const config = {
        type: 'feedforward',
        layers: [3, 5, 3],
        activation: 'sigmoid'
      };
      const network = yield manager.create(config);
      const smallNumbers = [[Number.MIN_VALUE, 1e-100, 1e-308], [1e-323, 1e-324, 0],
      // Near machine epsilon
      [-Number.MIN_VALUE, -1e-100, -1e-308]];
      for (const input of smallNumbers) {
        const result = yield network.forward(input);
        expect(result).toBeDefined();
        expect(result.length).toBe(3);

        // Should handle underflow gracefully
        result.forEach(value => {
          expect(isFinite(value)).toBe(true);
          expect(value).toBeGreaterThanOrEqual(0);
          expect(value).toBeLessThanOrEqual(1);
        });
      }
    }));
    it('should handle very large numbers (overflow)', /*#__PURE__*/_asyncToGenerator(function* () {
      const config = {
        type: 'feedforward',
        layers: [2, 3, 2],
        activation: 'relu'
      };
      const network = yield manager.create(config);
      const largeNumbers = [[Number.MAX_VALUE, 1e100], [1e308, 1e307], [-Number.MAX_VALUE, -1e100]];
      for (const input of largeNumbers) {
        const result = yield network.forward(input);
        expect(result).toBeDefined();
        expect(result.length).toBe(2);

        // ReLU should pass through positive values or zero
        result.forEach(value => {
          expect(value).toBeGreaterThanOrEqual(0);
          expect(isFinite(value) || value === Infinity).toBe(true);
        });
      }
    }));
  });
  describe('Gradient Edge Cases', () => {
    it('should handle vanishing gradients', /*#__PURE__*/_asyncToGenerator(function* () {
      const config = {
        type: 'feedforward',
        layers: [2, 10, 10, 10, 10, 10, 2],
        // Deep network
        activation: 'sigmoid' // Prone to vanishing gradients
      };
      const network = yield manager.create(config);
      const trainingData = [];
      for (let i = 0; i < 100; i++) {
        trainingData.push({
          input: [Math.random(), Math.random()],
          target: [Math.random(), Math.random()]
        });
      }
      const initialWeights = network.getWeights();

      // Train for a few epochs
      for (let epoch = 0; epoch < 10; epoch++) {
        let totalLoss = 0;
        for (const sample of trainingData) {
          const output = yield network.forward(sample.input);
          const loss = yield network.backward(sample.target);
          totalLoss += loss;
        }
        const avgLoss = totalLoss / trainingData.length;
        expect(avgLoss).toBeGreaterThanOrEqual(0);
        expect(isFinite(avgLoss)).toBe(true);
      }
      const finalWeights = network.getWeights();

      // Check that some learning occurred (weights changed)
      let weightsChanged = false;
      for (let i = 0; i < initialWeights.length; i++) {
        if (Math.abs(initialWeights[i] - finalWeights[i]) > 1e-6) {
          weightsChanged = true;
          break;
        }
      }

      // Even with vanishing gradients, some change should occur
      expect(weightsChanged).toBe(true);
    }));
    it('should handle exploding gradients', /*#__PURE__*/_asyncToGenerator(function* () {
      const config = {
        type: 'feedforward',
        layers: [2, 5, 2],
        activation: 'linear',
        learningRate: 10.0 // High learning rate
      };
      const network = yield manager.create(config);

      // Initialize with large weights to cause exploding gradients
      const weights = network.getWeights();
      for (let i = 0; i < weights.length; i++) {
        weights[i] = (Math.random() - 0.5) * 10; // Large initial weights
      }
      network.setWeights(weights);
      const trainingData = {
        input: [1, 1],
        target: [0, 0]
      };
      let maxGradient = 0;
      const gradientHistory = [];
      for (let epoch = 0; epoch < 20; epoch++) {
        try {
          yield network.forward(trainingData.input);
          const loss = yield network.backward(trainingData.target);

          // Track gradient magnitude
          const currentWeights = network.getWeights();
          const gradientMagnitude = Math.sqrt(currentWeights.reduce((sum, w) => sum + w * w, 0));
          gradientHistory.push(gradientMagnitude);
          maxGradient = Math.max(maxGradient, gradientMagnitude);

          // Network should handle large gradients without crashing
          expect(isFinite(loss)).toBe(true);
          expect(isFinite(gradientMagnitude)).toBe(true);
        } catch (error) {
          // If training fails due to numerical issues, that's acceptable
          expect(error.message).toMatch(/numerical|overflow|gradient/i);
          break;
        }
      }

      // Should have detected large gradients
      expect(maxGradient).toBeGreaterThan(1);
    }));
  });
  describe('Model Architecture Edge Cases', () => {
    it('should handle single neuron networks', /*#__PURE__*/_asyncToGenerator(function* () {
      const config = {
        type: 'feedforward',
        layers: [1, 1],
        activation: 'sigmoid'
      };
      const network = yield manager.create(config);
      const result = yield network.forward([0.5]);
      expect(result).toHaveLength(1);
      expect(result[0]).toBeGreaterThan(0);
      expect(result[0]).toBeLessThan(1);
    }));
    it('should handle networks with skip connections', /*#__PURE__*/_asyncToGenerator(function* () {
      const config = {
        type: 'residual',
        layers: [4, 8, 8, 4],
        activation: 'relu',
        skipConnections: true
      };
      const network = yield manager.create(config);
      const input = [1, 2, 3, 4];
      const result = yield network.forward(input);
      expect(result).toHaveLength(4);
      result.forEach(value => {
        expect(isFinite(value)).toBe(true);
      });
    }));
    it('should handle extremely wide networks', /*#__PURE__*/_asyncToGenerator(function* () {
      const config = {
        type: 'feedforward',
        layers: [10, 1000, 10],
        // Very wide hidden layer
        activation: 'relu'
      };
      const network = yield manager.create(config);
      const input = new Array(10).fill(0).map(() => Math.random());
      const result = yield network.forward(input);
      expect(result).toHaveLength(10);
      result.forEach(value => {
        expect(isFinite(value)).toBe(true);
      });
    }));
    it('should handle extremely deep networks', /*#__PURE__*/_asyncToGenerator(function* () {
      const config = {
        type: 'feedforward',
        layers: [2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2],
        // Very deep
        activation: 'relu'
      };
      const network = yield manager.create(config);
      const input = [0.5, 0.5];
      const result = yield network.forward(input);
      expect(result).toHaveLength(2);
      result.forEach(value => {
        expect(isFinite(value)).toBe(true);
      });
    }));
  });
  describe('Training Data Edge Cases', () => {
    it('should handle empty training data', /*#__PURE__*/_asyncToGenerator(function* () {
      const config = {
        type: 'feedforward',
        layers: [2, 3, 2],
        activation: 'sigmoid'
      };
      const network = yield manager.create(config);
      yield expect(network.train([])).rejects.toThrow(/empty|no data/i);
    }));
    it('should handle inconsistent input dimensions', /*#__PURE__*/_asyncToGenerator(function* () {
      const config = {
        type: 'feedforward',
        layers: [2, 3, 2],
        activation: 'sigmoid'
      };
      const network = yield manager.create(config);
      const inconsistentData = [{
        input: [1, 2],
        target: [0, 1]
      }, {
        input: [1, 2, 3],
        target: [0, 1]
      },
      // Wrong input size
      {
        input: [1],
        target: [0, 1]
      } // Wrong input size
      ];
      yield expect(network.train(inconsistentData)).rejects.toThrow(/dimension|size/i);
    }));
    it('should handle inconsistent output dimensions', /*#__PURE__*/_asyncToGenerator(function* () {
      const config = {
        type: 'feedforward',
        layers: [2, 3, 2],
        activation: 'sigmoid'
      };
      const network = yield manager.create(config);
      const inconsistentData = [{
        input: [1, 2],
        target: [0, 1]
      }, {
        input: [1, 2],
        target: [0, 1, 2]
      },
      // Wrong target size
      {
        input: [1, 2],
        target: [0]
      } // Wrong target size
      ];
      yield expect(network.train(inconsistentData)).rejects.toThrow(/dimension|size/i);
    }));
    it('should handle duplicate training samples', /*#__PURE__*/_asyncToGenerator(function* () {
      const config = {
        type: 'feedforward',
        layers: [2, 3, 2],
        activation: 'sigmoid'
      };
      const network = yield manager.create(config);
      const duplicateData = [];
      for (let i = 0; i < 100; i++) {
        duplicateData.push({
          input: [1, 2],
          target: [0, 1]
        });
      }
      const result = yield network.train(duplicateData, {
        epochs: 10
      });

      // Should converge quickly on duplicate data
      expect(result.finalLoss).toBeLessThan(result.initialLoss);
    }));
  });
  describe('Activation Function Edge Cases', () => {
    it('should handle unknown activation functions', /*#__PURE__*/_asyncToGenerator(function* () {
      const config = {
        type: 'feedforward',
        layers: [2, 3, 2],
        activation: 'unknown_activation'
      };
      yield expect(manager.create(config)).rejects.toThrow(/activation|unknown/i);
    }));
    it('should handle custom activation functions', /*#__PURE__*/_asyncToGenerator(function* () {
      const config = {
        type: 'feedforward',
        layers: [2, 3, 2],
        activation: x => Math.max(0, Math.min(1, x)) // Custom clamp function
      };
      const network = yield manager.create(config);
      const result = yield network.forward([0.5, -0.5]);
      expect(result).toHaveLength(2);
      result.forEach(value => {
        expect(value).toBeGreaterThanOrEqual(0);
        expect(value).toBeLessThanOrEqual(1);
      });
    }));
    it('should handle activation functions with extreme outputs', /*#__PURE__*/_asyncToGenerator(function* () {
      const config = {
        type: 'feedforward',
        layers: [2, 3, 2],
        activation: x => x > 0 ? 1e10 : -1e10 // Extreme activation
      };
      const network = yield manager.create(config);
      const result = yield network.forward([1, -1]);
      expect(result).toHaveLength(2);
      result.forEach(value => {
        expect(Math.abs(value)).toBeGreaterThan(1000);
      });
    }));
  });
  describe('Batch Processing Edge Cases', () => {
    it('should handle single sample batches', /*#__PURE__*/_asyncToGenerator(function* () {
      const config = {
        type: 'feedforward',
        layers: [2, 3, 2],
        activation: 'relu'
      };
      const network = yield manager.create(config);
      const singleBatch = [{
        input: [1, 2],
        target: [0, 1]
      }];
      const result = yield network.trainBatch(singleBatch);
      expect(result.loss).toBeGreaterThanOrEqual(0);
      expect(isFinite(result.loss)).toBe(true);
    }));
    it('should handle very large batches', /*#__PURE__*/_asyncToGenerator(function* () {
      const config = {
        type: 'feedforward',
        layers: [2, 3, 2],
        activation: 'relu'
      };
      const network = yield manager.create(config);
      const largeBatch = [];
      for (let i = 0; i < 10000; i++) {
        largeBatch.push({
          input: [Math.random(), Math.random()],
          target: [Math.random(), Math.random()]
        });
      }
      const result = yield network.trainBatch(largeBatch);
      expect(result.loss).toBeGreaterThanOrEqual(0);
      expect(isFinite(result.loss)).toBe(true);
    }));
    it('should handle batches with mixed sample qualities', /*#__PURE__*/_asyncToGenerator(function* () {
      const config = {
        type: 'feedforward',
        layers: [2, 3, 2],
        activation: 'sigmoid'
      };
      const network = yield manager.create(config);
      const mixedBatch = [{
        input: [1, 2],
        target: [0, 1]
      },
      // Normal
      {
        input: [0, 0],
        target: [0, 0]
      },
      // Zero input
      {
        input: [1000, -1000],
        target: [1, 0]
      },
      // Extreme input
      {
        input: [0.1, 0.1],
        target: [0.9, 0.9]
      } // Small input, large target
      ];
      const result = yield network.trainBatch(mixedBatch);
      expect(result.loss).toBeGreaterThanOrEqual(0);
      expect(isFinite(result.loss)).toBe(true);
    }));
  });
  describe('Memory Management in Neural Networks', () => {
    it('should handle memory cleanup during training', /*#__PURE__*/_asyncToGenerator(function* () {
      const config = {
        type: 'feedforward',
        layers: [10, 100, 100, 10],
        activation: 'relu'
      };
      const network = yield manager.create(config);
      const trainingData = [];
      for (let i = 0; i < 1000; i++) {
        trainingData.push({
          input: new Array(10).fill(0).map(() => Math.random()),
          target: new Array(10).fill(0).map(() => Math.random())
        });
      }
      const initialMemory = process.memoryUsage();

      // Train for multiple epochs
      for (let epoch = 0; epoch < 50; epoch++) {
        yield network.train(trainingData, {
          epochs: 1
        });

        // Force garbage collection periodically
        if (epoch % 10 === 0 && global.gc) {
          global.gc();
        }
      }
      const finalMemory = process.memoryUsage();

      // Memory usage should not grow unboundedly
      const memoryGrowth = finalMemory.heapUsed - initialMemory.heapUsed;
      expect(memoryGrowth).toBeLessThan(100 * 1024 * 1024); // Less than 100MB growth
    }));
  });
});

// Run tests when executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  console.log('Running neural network edge case tests...');

  // Run all tests
  const {
    run
  } = await import('../test-runner.js');
  await run(__filename);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkZXNjcmliZSIsIml0IiwiZXhwZWN0IiwiamVzdCIsImJlZm9yZUVhY2giLCJhZnRlckVhY2giLCJOZXVyYWxOZXR3b3JrTWFuYWdlciIsIk5ldXJhbEFnZW50IiwibWFuYWdlciIsIl9hc3luY1RvR2VuZXJhdG9yIiwiY29uZmlnIiwidHlwZSIsImxheWVycyIsImFjdGl2YXRpb24iLCJuZXR3b3JrIiwiY3JlYXRlIiwiaW52YWxpZElucHV0cyIsIk5hTiIsImlucHV0IiwicmVzdWx0IiwiZm9yd2FyZCIsInRvQmVEZWZpbmVkIiwiQXJyYXkiLCJpc0FycmF5IiwidG9CZSIsImZvckVhY2giLCJ2YWx1ZSIsImluZmluaXR5SW5wdXRzIiwiSW5maW5pdHkiLCJsZW5ndGgiLCJNYXRoIiwiYWJzIiwidG9CZUxlc3NUaGFuT3JFcXVhbCIsInNtYWxsTnVtYmVycyIsIk51bWJlciIsIk1JTl9WQUxVRSIsImlzRmluaXRlIiwidG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCIsImxhcmdlTnVtYmVycyIsIk1BWF9WQUxVRSIsInRyYWluaW5nRGF0YSIsImkiLCJwdXNoIiwicmFuZG9tIiwidGFyZ2V0IiwiaW5pdGlhbFdlaWdodHMiLCJnZXRXZWlnaHRzIiwiZXBvY2giLCJ0b3RhbExvc3MiLCJzYW1wbGUiLCJvdXRwdXQiLCJsb3NzIiwiYmFja3dhcmQiLCJhdmdMb3NzIiwiZmluYWxXZWlnaHRzIiwid2VpZ2h0c0NoYW5nZWQiLCJsZWFybmluZ1JhdGUiLCJ3ZWlnaHRzIiwic2V0V2VpZ2h0cyIsIm1heEdyYWRpZW50IiwiZ3JhZGllbnRIaXN0b3J5IiwiY3VycmVudFdlaWdodHMiLCJncmFkaWVudE1hZ25pdHVkZSIsInNxcnQiLCJyZWR1Y2UiLCJzdW0iLCJ3IiwibWF4IiwiZXJyb3IiLCJtZXNzYWdlIiwidG9NYXRjaCIsInRvQmVHcmVhdGVyVGhhbiIsInRvSGF2ZUxlbmd0aCIsInRvQmVMZXNzVGhhbiIsInNraXBDb25uZWN0aW9ucyIsImZpbGwiLCJtYXAiLCJ0cmFpbiIsInJlamVjdHMiLCJ0b1Rocm93IiwiaW5jb25zaXN0ZW50RGF0YSIsImR1cGxpY2F0ZURhdGEiLCJlcG9jaHMiLCJmaW5hbExvc3MiLCJpbml0aWFsTG9zcyIsIngiLCJtaW4iLCJzaW5nbGVCYXRjaCIsInRyYWluQmF0Y2giLCJsYXJnZUJhdGNoIiwibWl4ZWRCYXRjaCIsImluaXRpYWxNZW1vcnkiLCJwcm9jZXNzIiwibWVtb3J5VXNhZ2UiLCJnbG9iYWwiLCJnYyIsImZpbmFsTWVtb3J5IiwibWVtb3J5R3Jvd3RoIiwiaGVhcFVzZWQiLCJpbXBvcnQiLCJtZXRhIiwidXJsIiwiYXJndiIsImNvbnNvbGUiLCJsb2ciLCJydW4iLCJfX2ZpbGVuYW1lIl0sInNvdXJjZXMiOlsibmV1cmFsLW5ldHdvcmstZWRnZS1jYXNlcy50ZXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTmV1cmFsIE5ldHdvcmsgRWRnZSBDYXNlc1xuICogVGVzdHMgbnVtZXJpY2FsIHN0YWJpbGl0eSwgZ3JhZGllbnQgaXNzdWVzLCBhbmQgbW9kZWwgdHJhaW5pbmcgZWRnZSBjYXNlc1xuICovXG5cbmltcG9ydCB7IGRlc2NyaWJlLCBpdCwgZXhwZWN0LCBqZXN0LCBiZWZvcmVFYWNoLCBhZnRlckVhY2ggfSBmcm9tICdAamVzdC9nbG9iYWxzJztcbmltcG9ydCB7IE5ldXJhbE5ldHdvcmtNYW5hZ2VyIH0gZnJvbSAnLi4vLi4vc3JjL25ldXJhbC1uZXR3b3JrLW1hbmFnZXIuanMnO1xuaW1wb3J0IHsgTmV1cmFsQWdlbnQgfSBmcm9tICcuLi8uLi9zcmMvbmV1cmFsLWFnZW50LmpzJztcblxuZGVzY3JpYmUoJ05ldXJhbCBOZXR3b3JrIEVkZ2UgQ2FzZXMnLCAoKSA9PiB7XG4gIGxldCBtYW5hZ2VyO1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIG1hbmFnZXIgPSBuZXcgTmV1cmFsTmV0d29ya01hbmFnZXIoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ051bWVyaWNhbCBTdGFiaWxpdHkgRWRnZSBDYXNlcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBOYU4gaW5wdXRzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgIHR5cGU6ICdmZWVkZm9yd2FyZCcsXG4gICAgICAgIGxheWVyczogWzQsIDgsIDRdLFxuICAgICAgICBhY3RpdmF0aW9uOiAncmVsdScsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgbWFuYWdlci5jcmVhdGUoY29uZmlnKTtcbiAgICAgIFxuICAgICAgY29uc3QgaW52YWxpZElucHV0cyA9IFtcbiAgICAgICAgW05hTiwgMSwgMiwgM10sXG4gICAgICAgIFsxLCBOYU4sIDIsIDNdLFxuICAgICAgICBbMSwgMiwgTmFOLCAzXSxcbiAgICAgICAgWzEsIDIsIDMsIE5hTl0sXG4gICAgICAgIFtOYU4sIE5hTiwgTmFOLCBOYU5dLFxuICAgICAgXTtcblxuICAgICAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnZhbGlkSW5wdXRzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG5ldHdvcmsuZm9yd2FyZChpbnB1dCk7XG4gICAgICAgIFxuICAgICAgICAvLyBOZXR3b3JrIHNob3VsZCBoYW5kbGUgTmFOIGlucHV0cyB3aXRob3V0IGNyYXNoaW5nXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgIGV4cGVjdChBcnJheS5pc0FycmF5KHJlc3VsdCkpLnRvQmUodHJ1ZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBPdXRwdXQgc2hvdWxkIGVpdGhlciBiZSB2YWxpZCBudW1iZXJzIG9yIE5hTiAoY29uc2lzdGVudCBiZWhhdmlvcilcbiAgICAgICAgcmVzdWx0LmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgIGV4cGVjdCh0eXBlb2YgdmFsdWUpLnRvQmUoJ251bWJlcicpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIEluZmluaXR5IGlucHV0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgdHlwZTogJ2ZlZWRmb3J3YXJkJyxcbiAgICAgICAgbGF5ZXJzOiBbMiwgNCwgMl0sXG4gICAgICAgIGFjdGl2YXRpb246ICd0YW5oJyxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCBtYW5hZ2VyLmNyZWF0ZShjb25maWcpO1xuICAgICAgXG4gICAgICBjb25zdCBpbmZpbml0eUlucHV0cyA9IFtcbiAgICAgICAgW0luZmluaXR5LCAxXSxcbiAgICAgICAgWzEsIEluZmluaXR5XSxcbiAgICAgICAgWy1JbmZpbml0eSwgMV0sXG4gICAgICAgIFsxLCAtSW5maW5pdHldLFxuICAgICAgICBbSW5maW5pdHksIC1JbmZpbml0eV0sXG4gICAgICAgIFtJbmZpbml0eSwgSW5maW5pdHldLFxuICAgICAgICBbLUluZmluaXR5LCAtSW5maW5pdHldLFxuICAgICAgXTtcblxuICAgICAgZm9yIChjb25zdCBpbnB1dCBvZiBpbmZpbml0eUlucHV0cykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBuZXR3b3JrLmZvcndhcmQoaW5wdXQpO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZURlZmluZWQoKTtcbiAgICAgICAgZXhwZWN0KEFycmF5LmlzQXJyYXkocmVzdWx0KSkudG9CZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5sZW5ndGgpLnRvQmUoMik7XG4gICAgICAgIFxuICAgICAgICAvLyB0YW5oIHNob3VsZCBjbGFtcCBpbmZpbml0ZSB2YWx1ZXMgdG8gLTEgb3IgMVxuICAgICAgICByZXN1bHQuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgZXhwZWN0KE1hdGguYWJzKHZhbHVlKSkudG9CZUxlc3NUaGFuT3JFcXVhbCgxKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSB2ZXJ5IHNtYWxsIG51bWJlcnMgKHVuZGVyZmxvdyknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgIHR5cGU6ICdmZWVkZm9yd2FyZCcsXG4gICAgICAgIGxheWVyczogWzMsIDUsIDNdLFxuICAgICAgICBhY3RpdmF0aW9uOiAnc2lnbW9pZCcsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgbWFuYWdlci5jcmVhdGUoY29uZmlnKTtcbiAgICAgIFxuICAgICAgY29uc3Qgc21hbGxOdW1iZXJzID0gW1xuICAgICAgICBbTnVtYmVyLk1JTl9WQUxVRSwgMWUtMTAwLCAxZS0zMDhdLFxuICAgICAgICBbMWUtMzIzLCAxZS0zMjQsIDBdLCAvLyBOZWFyIG1hY2hpbmUgZXBzaWxvblxuICAgICAgICBbLU51bWJlci5NSU5fVkFMVUUsIC0xZS0xMDAsIC0xZS0zMDhdLFxuICAgICAgXTtcblxuICAgICAgZm9yIChjb25zdCBpbnB1dCBvZiBzbWFsbE51bWJlcnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbmV0d29yay5mb3J3YXJkKGlucHV0KTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQubGVuZ3RoKS50b0JlKDMpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2hvdWxkIGhhbmRsZSB1bmRlcmZsb3cgZ3JhY2VmdWxseVxuICAgICAgICByZXN1bHQuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgZXhwZWN0KGlzRmluaXRlKHZhbHVlKSkudG9CZSh0cnVlKTtcbiAgICAgICAgICBleHBlY3QodmFsdWUpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMCk7XG4gICAgICAgICAgZXhwZWN0KHZhbHVlKS50b0JlTGVzc1RoYW5PckVxdWFsKDEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHZlcnkgbGFyZ2UgbnVtYmVycyAob3ZlcmZsb3cpJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICB0eXBlOiAnZmVlZGZvcndhcmQnLFxuICAgICAgICBsYXllcnM6IFsyLCAzLCAyXSxcbiAgICAgICAgYWN0aXZhdGlvbjogJ3JlbHUnLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IG1hbmFnZXIuY3JlYXRlKGNvbmZpZyk7XG4gICAgICBcbiAgICAgIGNvbnN0IGxhcmdlTnVtYmVycyA9IFtcbiAgICAgICAgW051bWJlci5NQVhfVkFMVUUsIDFlMTAwXSxcbiAgICAgICAgWzFlMzA4LCAxZTMwN10sXG4gICAgICAgIFstTnVtYmVyLk1BWF9WQUxVRSwgLTFlMTAwXSxcbiAgICAgIF07XG5cbiAgICAgIGZvciAoY29uc3QgaW5wdXQgb2YgbGFyZ2VOdW1iZXJzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG5ldHdvcmsuZm9yd2FyZChpbnB1dCk7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlRGVmaW5lZCgpO1xuICAgICAgICBleHBlY3QocmVzdWx0Lmxlbmd0aCkudG9CZSgyKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlTFUgc2hvdWxkIHBhc3MgdGhyb3VnaCBwb3NpdGl2ZSB2YWx1ZXMgb3IgemVyb1xuICAgICAgICByZXN1bHQuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgZXhwZWN0KHZhbHVlKS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDApO1xuICAgICAgICAgIGV4cGVjdChpc0Zpbml0ZSh2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KS50b0JlKHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0dyYWRpZW50IEVkZ2UgQ2FzZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgdmFuaXNoaW5nIGdyYWRpZW50cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgdHlwZTogJ2ZlZWRmb3J3YXJkJyxcbiAgICAgICAgbGF5ZXJzOiBbMiwgMTAsIDEwLCAxMCwgMTAsIDEwLCAyXSwgLy8gRGVlcCBuZXR3b3JrXG4gICAgICAgIGFjdGl2YXRpb246ICdzaWdtb2lkJywgLy8gUHJvbmUgdG8gdmFuaXNoaW5nIGdyYWRpZW50c1xuICAgICAgfTtcblxuICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IG1hbmFnZXIuY3JlYXRlKGNvbmZpZyk7XG4gICAgICBcbiAgICAgIGNvbnN0IHRyYWluaW5nRGF0YSA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDA7IGkrKykge1xuICAgICAgICB0cmFpbmluZ0RhdGEucHVzaCh7XG4gICAgICAgICAgaW5wdXQ6IFtNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpXSxcbiAgICAgICAgICB0YXJnZXQ6IFtNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpXSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGluaXRpYWxXZWlnaHRzID0gbmV0d29yay5nZXRXZWlnaHRzKCk7XG4gICAgICBcbiAgICAgIC8vIFRyYWluIGZvciBhIGZldyBlcG9jaHNcbiAgICAgIGZvciAobGV0IGVwb2NoID0gMDsgZXBvY2ggPCAxMDsgZXBvY2grKykge1xuICAgICAgICBsZXQgdG90YWxMb3NzID0gMDtcbiAgICAgICAgXG4gICAgICAgIGZvciAoY29uc3Qgc2FtcGxlIG9mIHRyYWluaW5nRGF0YSkge1xuICAgICAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IG5ldHdvcmsuZm9yd2FyZChzYW1wbGUuaW5wdXQpO1xuICAgICAgICAgIGNvbnN0IGxvc3MgPSBhd2FpdCBuZXR3b3JrLmJhY2t3YXJkKHNhbXBsZS50YXJnZXQpO1xuICAgICAgICAgIHRvdGFsTG9zcyArPSBsb3NzO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCBhdmdMb3NzID0gdG90YWxMb3NzIC8gdHJhaW5pbmdEYXRhLmxlbmd0aDtcbiAgICAgICAgZXhwZWN0KGF2Z0xvc3MpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMCk7XG4gICAgICAgIGV4cGVjdChpc0Zpbml0ZShhdmdMb3NzKSkudG9CZSh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmluYWxXZWlnaHRzID0gbmV0d29yay5nZXRXZWlnaHRzKCk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIHRoYXQgc29tZSBsZWFybmluZyBvY2N1cnJlZCAod2VpZ2h0cyBjaGFuZ2VkKVxuICAgICAgbGV0IHdlaWdodHNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluaXRpYWxXZWlnaHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhpbml0aWFsV2VpZ2h0c1tpXSAtIGZpbmFsV2VpZ2h0c1tpXSkgPiAxZS02KSB7XG4gICAgICAgICAgd2VpZ2h0c0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEV2ZW4gd2l0aCB2YW5pc2hpbmcgZ3JhZGllbnRzLCBzb21lIGNoYW5nZSBzaG91bGQgb2NjdXJcbiAgICAgIGV4cGVjdCh3ZWlnaHRzQ2hhbmdlZCkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGV4cGxvZGluZyBncmFkaWVudHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgIHR5cGU6ICdmZWVkZm9yd2FyZCcsXG4gICAgICAgIGxheWVyczogWzIsIDUsIDJdLFxuICAgICAgICBhY3RpdmF0aW9uOiAnbGluZWFyJyxcbiAgICAgICAgbGVhcm5pbmdSYXRlOiAxMC4wLCAvLyBIaWdoIGxlYXJuaW5nIHJhdGVcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCBtYW5hZ2VyLmNyZWF0ZShjb25maWcpO1xuICAgICAgXG4gICAgICAvLyBJbml0aWFsaXplIHdpdGggbGFyZ2Ugd2VpZ2h0cyB0byBjYXVzZSBleHBsb2RpbmcgZ3JhZGllbnRzXG4gICAgICBjb25zdCB3ZWlnaHRzID0gbmV0d29yay5nZXRXZWlnaHRzKCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdlaWdodHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd2VpZ2h0c1tpXSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDEwOyAvLyBMYXJnZSBpbml0aWFsIHdlaWdodHNcbiAgICAgIH1cbiAgICAgIG5ldHdvcmsuc2V0V2VpZ2h0cyh3ZWlnaHRzKTtcblxuICAgICAgY29uc3QgdHJhaW5pbmdEYXRhID0ge1xuICAgICAgICBpbnB1dDogWzEsIDFdLFxuICAgICAgICB0YXJnZXQ6IFswLCAwXSxcbiAgICAgIH07XG5cbiAgICAgIGxldCBtYXhHcmFkaWVudCA9IDA7XG4gICAgICBjb25zdCBncmFkaWVudEhpc3RvcnkgPSBbXTtcblxuICAgICAgZm9yIChsZXQgZXBvY2ggPSAwOyBlcG9jaCA8IDIwOyBlcG9jaCsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgbmV0d29yay5mb3J3YXJkKHRyYWluaW5nRGF0YS5pbnB1dCk7XG4gICAgICAgICAgY29uc3QgbG9zcyA9IGF3YWl0IG5ldHdvcmsuYmFja3dhcmQodHJhaW5pbmdEYXRhLnRhcmdldCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJhY2sgZ3JhZGllbnQgbWFnbml0dWRlXG4gICAgICAgICAgY29uc3QgY3VycmVudFdlaWdodHMgPSBuZXR3b3JrLmdldFdlaWdodHMoKTtcbiAgICAgICAgICBjb25zdCBncmFkaWVudE1hZ25pdHVkZSA9IE1hdGguc3FydChcbiAgICAgICAgICAgIGN1cnJlbnRXZWlnaHRzLnJlZHVjZSgoc3VtLCB3KSA9PiBzdW0gKyB3ICogdywgMClcbiAgICAgICAgICApO1xuICAgICAgICAgIFxuICAgICAgICAgIGdyYWRpZW50SGlzdG9yeS5wdXNoKGdyYWRpZW50TWFnbml0dWRlKTtcbiAgICAgICAgICBtYXhHcmFkaWVudCA9IE1hdGgubWF4KG1heEdyYWRpZW50LCBncmFkaWVudE1hZ25pdHVkZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTmV0d29yayBzaG91bGQgaGFuZGxlIGxhcmdlIGdyYWRpZW50cyB3aXRob3V0IGNyYXNoaW5nXG4gICAgICAgICAgZXhwZWN0KGlzRmluaXRlKGxvc3MpKS50b0JlKHRydWUpO1xuICAgICAgICAgIGV4cGVjdChpc0Zpbml0ZShncmFkaWVudE1hZ25pdHVkZSkpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgdHJhaW5pbmcgZmFpbHMgZHVlIHRvIG51bWVyaWNhbCBpc3N1ZXMsIHRoYXQncyBhY2NlcHRhYmxlXG4gICAgICAgICAgZXhwZWN0KGVycm9yLm1lc3NhZ2UpLnRvTWF0Y2goL251bWVyaWNhbHxvdmVyZmxvd3xncmFkaWVudC9pKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTaG91bGQgaGF2ZSBkZXRlY3RlZCBsYXJnZSBncmFkaWVudHNcbiAgICAgIGV4cGVjdChtYXhHcmFkaWVudCkudG9CZUdyZWF0ZXJUaGFuKDEpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnTW9kZWwgQXJjaGl0ZWN0dXJlIEVkZ2UgQ2FzZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgc2luZ2xlIG5ldXJvbiBuZXR3b3JrcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgdHlwZTogJ2ZlZWRmb3J3YXJkJyxcbiAgICAgICAgbGF5ZXJzOiBbMSwgMV0sXG4gICAgICAgIGFjdGl2YXRpb246ICdzaWdtb2lkJyxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCBtYW5hZ2VyLmNyZWF0ZShjb25maWcpO1xuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBuZXR3b3JrLmZvcndhcmQoWzAuNV0pO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KHJlc3VsdFswXSkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgZXhwZWN0KHJlc3VsdFswXSkudG9CZUxlc3NUaGFuKDEpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbmV0d29ya3Mgd2l0aCBza2lwIGNvbm5lY3Rpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICB0eXBlOiAncmVzaWR1YWwnLFxuICAgICAgICBsYXllcnM6IFs0LCA4LCA4LCA0XSxcbiAgICAgICAgYWN0aXZhdGlvbjogJ3JlbHUnLFxuICAgICAgICBza2lwQ29ubmVjdGlvbnM6IHRydWUsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgbWFuYWdlci5jcmVhdGUoY29uZmlnKTtcbiAgICAgIFxuICAgICAgY29uc3QgaW5wdXQgPSBbMSwgMiwgMywgNF07XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBuZXR3b3JrLmZvcndhcmQoaW5wdXQpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0KS50b0hhdmVMZW5ndGgoNCk7XG4gICAgICByZXN1bHQuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgIGV4cGVjdChpc0Zpbml0ZSh2YWx1ZSkpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGV4dHJlbWVseSB3aWRlIG5ldHdvcmtzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICB0eXBlOiAnZmVlZGZvcndhcmQnLFxuICAgICAgICBsYXllcnM6IFsxMCwgMTAwMCwgMTBdLCAvLyBWZXJ5IHdpZGUgaGlkZGVuIGxheWVyXG4gICAgICAgIGFjdGl2YXRpb246ICdyZWx1JyxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCBtYW5hZ2VyLmNyZWF0ZShjb25maWcpO1xuICAgICAgXG4gICAgICBjb25zdCBpbnB1dCA9IG5ldyBBcnJheSgxMCkuZmlsbCgwKS5tYXAoKCkgPT4gTWF0aC5yYW5kb20oKSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBuZXR3b3JrLmZvcndhcmQoaW5wdXQpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0KS50b0hhdmVMZW5ndGgoMTApO1xuICAgICAgcmVzdWx0LmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICBleHBlY3QoaXNGaW5pdGUodmFsdWUpKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBleHRyZW1lbHkgZGVlcCBuZXR3b3JrcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgdHlwZTogJ2ZlZWRmb3J3YXJkJyxcbiAgICAgICAgbGF5ZXJzOiBbMiwgMywgMywgMywgMywgMywgMywgMywgMywgMywgMl0sIC8vIFZlcnkgZGVlcFxuICAgICAgICBhY3RpdmF0aW9uOiAncmVsdScsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgbWFuYWdlci5jcmVhdGUoY29uZmlnKTtcbiAgICAgIFxuICAgICAgY29uc3QgaW5wdXQgPSBbMC41LCAwLjVdO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbmV0d29yay5mb3J3YXJkKGlucHV0KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgcmVzdWx0LmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICBleHBlY3QoaXNGaW5pdGUodmFsdWUpKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdUcmFpbmluZyBEYXRhIEVkZ2UgQ2FzZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZW1wdHkgdHJhaW5pbmcgZGF0YScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgdHlwZTogJ2ZlZWRmb3J3YXJkJyxcbiAgICAgICAgbGF5ZXJzOiBbMiwgMywgMl0sXG4gICAgICAgIGFjdGl2YXRpb246ICdzaWdtb2lkJyxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCBtYW5hZ2VyLmNyZWF0ZShjb25maWcpO1xuICAgICAgXG4gICAgICBhd2FpdCBleHBlY3QobmV0d29yay50cmFpbihbXSkpLnJlamVjdHMudG9UaHJvdygvZW1wdHl8bm8gZGF0YS9pKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGluY29uc2lzdGVudCBpbnB1dCBkaW1lbnNpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICB0eXBlOiAnZmVlZGZvcndhcmQnLFxuICAgICAgICBsYXllcnM6IFsyLCAzLCAyXSxcbiAgICAgICAgYWN0aXZhdGlvbjogJ3NpZ21vaWQnLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IG1hbmFnZXIuY3JlYXRlKGNvbmZpZyk7XG4gICAgICBcbiAgICAgIGNvbnN0IGluY29uc2lzdGVudERhdGEgPSBbXG4gICAgICAgIHsgaW5wdXQ6IFsxLCAyXSwgdGFyZ2V0OiBbMCwgMV0gfSxcbiAgICAgICAgeyBpbnB1dDogWzEsIDIsIDNdLCB0YXJnZXQ6IFswLCAxXSB9LCAvLyBXcm9uZyBpbnB1dCBzaXplXG4gICAgICAgIHsgaW5wdXQ6IFsxXSwgdGFyZ2V0OiBbMCwgMV0gfSwgLy8gV3JvbmcgaW5wdXQgc2l6ZVxuICAgICAgXTtcblxuICAgICAgYXdhaXQgZXhwZWN0KG5ldHdvcmsudHJhaW4oaW5jb25zaXN0ZW50RGF0YSkpLnJlamVjdHMudG9UaHJvdygvZGltZW5zaW9ufHNpemUvaSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBpbmNvbnNpc3RlbnQgb3V0cHV0IGRpbWVuc2lvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgIHR5cGU6ICdmZWVkZm9yd2FyZCcsXG4gICAgICAgIGxheWVyczogWzIsIDMsIDJdLFxuICAgICAgICBhY3RpdmF0aW9uOiAnc2lnbW9pZCcsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgbWFuYWdlci5jcmVhdGUoY29uZmlnKTtcbiAgICAgIFxuICAgICAgY29uc3QgaW5jb25zaXN0ZW50RGF0YSA9IFtcbiAgICAgICAgeyBpbnB1dDogWzEsIDJdLCB0YXJnZXQ6IFswLCAxXSB9LFxuICAgICAgICB7IGlucHV0OiBbMSwgMl0sIHRhcmdldDogWzAsIDEsIDJdIH0sIC8vIFdyb25nIHRhcmdldCBzaXplXG4gICAgICAgIHsgaW5wdXQ6IFsxLCAyXSwgdGFyZ2V0OiBbMF0gfSwgLy8gV3JvbmcgdGFyZ2V0IHNpemVcbiAgICAgIF07XG5cbiAgICAgIGF3YWl0IGV4cGVjdChuZXR3b3JrLnRyYWluKGluY29uc2lzdGVudERhdGEpKS5yZWplY3RzLnRvVGhyb3coL2RpbWVuc2lvbnxzaXplL2kpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZHVwbGljYXRlIHRyYWluaW5nIHNhbXBsZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgIHR5cGU6ICdmZWVkZm9yd2FyZCcsXG4gICAgICAgIGxheWVyczogWzIsIDMsIDJdLFxuICAgICAgICBhY3RpdmF0aW9uOiAnc2lnbW9pZCcsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgbWFuYWdlci5jcmVhdGUoY29uZmlnKTtcbiAgICAgIFxuICAgICAgY29uc3QgZHVwbGljYXRlRGF0YSA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDA7IGkrKykge1xuICAgICAgICBkdXBsaWNhdGVEYXRhLnB1c2goeyBpbnB1dDogWzEsIDJdLCB0YXJnZXQ6IFswLCAxXSB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbmV0d29yay50cmFpbihkdXBsaWNhdGVEYXRhLCB7IGVwb2NoczogMTAgfSk7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBjb252ZXJnZSBxdWlja2x5IG9uIGR1cGxpY2F0ZSBkYXRhXG4gICAgICBleHBlY3QocmVzdWx0LmZpbmFsTG9zcykudG9CZUxlc3NUaGFuKHJlc3VsdC5pbml0aWFsTG9zcyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdBY3RpdmF0aW9uIEZ1bmN0aW9uIEVkZ2UgQ2FzZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgdW5rbm93biBhY3RpdmF0aW9uIGZ1bmN0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgdHlwZTogJ2ZlZWRmb3J3YXJkJyxcbiAgICAgICAgbGF5ZXJzOiBbMiwgMywgMl0sXG4gICAgICAgIGFjdGl2YXRpb246ICd1bmtub3duX2FjdGl2YXRpb24nLFxuICAgICAgfTtcblxuICAgICAgYXdhaXQgZXhwZWN0KG1hbmFnZXIuY3JlYXRlKGNvbmZpZykpLnJlamVjdHMudG9UaHJvdygvYWN0aXZhdGlvbnx1bmtub3duL2kpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY3VzdG9tIGFjdGl2YXRpb24gZnVuY3Rpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICB0eXBlOiAnZmVlZGZvcndhcmQnLFxuICAgICAgICBsYXllcnM6IFsyLCAzLCAyXSxcbiAgICAgICAgYWN0aXZhdGlvbjogKHgpID0+IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHgpKSwgLy8gQ3VzdG9tIGNsYW1wIGZ1bmN0aW9uXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgbWFuYWdlci5jcmVhdGUoY29uZmlnKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbmV0d29yay5mb3J3YXJkKFswLjUsIC0wLjVdKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgcmVzdWx0LmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICBleHBlY3QodmFsdWUpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMCk7XG4gICAgICAgIGV4cGVjdCh2YWx1ZSkudG9CZUxlc3NUaGFuT3JFcXVhbCgxKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgYWN0aXZhdGlvbiBmdW5jdGlvbnMgd2l0aCBleHRyZW1lIG91dHB1dHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgIHR5cGU6ICdmZWVkZm9yd2FyZCcsXG4gICAgICAgIGxheWVyczogWzIsIDMsIDJdLFxuICAgICAgICBhY3RpdmF0aW9uOiAoeCkgPT4geCA+IDAgPyAxZTEwIDogLTFlMTAsIC8vIEV4dHJlbWUgYWN0aXZhdGlvblxuICAgICAgfTtcblxuICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IG1hbmFnZXIuY3JlYXRlKGNvbmZpZyk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG5ldHdvcmsuZm9yd2FyZChbMSwgLTFdKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgcmVzdWx0LmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICBleHBlY3QoTWF0aC5hYnModmFsdWUpKS50b0JlR3JlYXRlclRoYW4oMTAwMCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0JhdGNoIFByb2Nlc3NpbmcgRWRnZSBDYXNlcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBzaW5nbGUgc2FtcGxlIGJhdGNoZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgIHR5cGU6ICdmZWVkZm9yd2FyZCcsXG4gICAgICAgIGxheWVyczogWzIsIDMsIDJdLFxuICAgICAgICBhY3RpdmF0aW9uOiAncmVsdScsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgbWFuYWdlci5jcmVhdGUoY29uZmlnKTtcbiAgICAgIFxuICAgICAgY29uc3Qgc2luZ2xlQmF0Y2ggPSBbeyBpbnB1dDogWzEsIDJdLCB0YXJnZXQ6IFswLCAxXSB9XTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG5ldHdvcmsudHJhaW5CYXRjaChzaW5nbGVCYXRjaCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQubG9zcykudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKTtcbiAgICAgIGV4cGVjdChpc0Zpbml0ZShyZXN1bHQubG9zcykpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSB2ZXJ5IGxhcmdlIGJhdGNoZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgIHR5cGU6ICdmZWVkZm9yd2FyZCcsXG4gICAgICAgIGxheWVyczogWzIsIDMsIDJdLFxuICAgICAgICBhY3RpdmF0aW9uOiAncmVsdScsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgbWFuYWdlci5jcmVhdGUoY29uZmlnKTtcbiAgICAgIFxuICAgICAgY29uc3QgbGFyZ2VCYXRjaCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDAwMDsgaSsrKSB7XG4gICAgICAgIGxhcmdlQmF0Y2gucHVzaCh7XG4gICAgICAgICAgaW5wdXQ6IFtNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpXSxcbiAgICAgICAgICB0YXJnZXQ6IFtNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpXSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG5ldHdvcmsudHJhaW5CYXRjaChsYXJnZUJhdGNoKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC5sb3NzKS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDApO1xuICAgICAgZXhwZWN0KGlzRmluaXRlKHJlc3VsdC5sb3NzKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGJhdGNoZXMgd2l0aCBtaXhlZCBzYW1wbGUgcXVhbGl0aWVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICB0eXBlOiAnZmVlZGZvcndhcmQnLFxuICAgICAgICBsYXllcnM6IFsyLCAzLCAyXSxcbiAgICAgICAgYWN0aXZhdGlvbjogJ3NpZ21vaWQnLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IG1hbmFnZXIuY3JlYXRlKGNvbmZpZyk7XG4gICAgICBcbiAgICAgIGNvbnN0IG1peGVkQmF0Y2ggPSBbXG4gICAgICAgIHsgaW5wdXQ6IFsxLCAyXSwgdGFyZ2V0OiBbMCwgMV0gfSwgLy8gTm9ybWFsXG4gICAgICAgIHsgaW5wdXQ6IFswLCAwXSwgdGFyZ2V0OiBbMCwgMF0gfSwgLy8gWmVybyBpbnB1dFxuICAgICAgICB7IGlucHV0OiBbMTAwMCwgLTEwMDBdLCB0YXJnZXQ6IFsxLCAwXSB9LCAvLyBFeHRyZW1lIGlucHV0XG4gICAgICAgIHsgaW5wdXQ6IFswLjEsIDAuMV0sIHRhcmdldDogWzAuOSwgMC45XSB9LCAvLyBTbWFsbCBpbnB1dCwgbGFyZ2UgdGFyZ2V0XG4gICAgICBdO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBuZXR3b3JrLnRyYWluQmF0Y2gobWl4ZWRCYXRjaCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQubG9zcykudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKTtcbiAgICAgIGV4cGVjdChpc0Zpbml0ZShyZXN1bHQubG9zcykpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdNZW1vcnkgTWFuYWdlbWVudCBpbiBOZXVyYWwgTmV0d29ya3MnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbWVtb3J5IGNsZWFudXAgZHVyaW5nIHRyYWluaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICB0eXBlOiAnZmVlZGZvcndhcmQnLFxuICAgICAgICBsYXllcnM6IFsxMCwgMTAwLCAxMDAsIDEwXSxcbiAgICAgICAgYWN0aXZhdGlvbjogJ3JlbHUnLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IG1hbmFnZXIuY3JlYXRlKGNvbmZpZyk7XG4gICAgICBcbiAgICAgIGNvbnN0IHRyYWluaW5nRGF0YSA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDAwOyBpKyspIHtcbiAgICAgICAgdHJhaW5pbmdEYXRhLnB1c2goe1xuICAgICAgICAgIGlucHV0OiBuZXcgQXJyYXkoMTApLmZpbGwoMCkubWFwKCgpID0+IE1hdGgucmFuZG9tKCkpLFxuICAgICAgICAgIHRhcmdldDogbmV3IEFycmF5KDEwKS5maWxsKDApLm1hcCgoKSA9PiBNYXRoLnJhbmRvbSgpKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGluaXRpYWxNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XG4gICAgICBcbiAgICAgIC8vIFRyYWluIGZvciBtdWx0aXBsZSBlcG9jaHNcbiAgICAgIGZvciAobGV0IGVwb2NoID0gMDsgZXBvY2ggPCA1MDsgZXBvY2grKykge1xuICAgICAgICBhd2FpdCBuZXR3b3JrLnRyYWluKHRyYWluaW5nRGF0YSwgeyBlcG9jaHM6IDEgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBGb3JjZSBnYXJiYWdlIGNvbGxlY3Rpb24gcGVyaW9kaWNhbGx5XG4gICAgICAgIGlmIChlcG9jaCAlIDEwID09PSAwICYmIGdsb2JhbC5nYykge1xuICAgICAgICAgIGdsb2JhbC5nYygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZpbmFsTWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpO1xuICAgICAgXG4gICAgICAvLyBNZW1vcnkgdXNhZ2Ugc2hvdWxkIG5vdCBncm93IHVuYm91bmRlZGx5XG4gICAgICBjb25zdCBtZW1vcnlHcm93dGggPSBmaW5hbE1lbW9yeS5oZWFwVXNlZCAtIGluaXRpYWxNZW1vcnkuaGVhcFVzZWQ7XG4gICAgICBleHBlY3QobWVtb3J5R3Jvd3RoKS50b0JlTGVzc1RoYW4oMTAwICogMTAyNCAqIDEwMjQpOyAvLyBMZXNzIHRoYW4gMTAwTUIgZ3Jvd3RoXG4gICAgfSk7XG4gIH0pO1xufSk7XG5cbi8vIFJ1biB0ZXN0cyB3aGVuIGV4ZWN1dGVkIGRpcmVjdGx5XG5pZiAoaW1wb3J0Lm1ldGEudXJsID09PSBgZmlsZTovLyR7cHJvY2Vzcy5hcmd2WzFdfWApIHtcbiAgY29uc29sZS5sb2coJ1J1bm5pbmcgbmV1cmFsIG5ldHdvcmsgZWRnZSBjYXNlIHRlc3RzLi4uJyk7XG4gIFxuICAvLyBSdW4gYWxsIHRlc3RzXG4gIGNvbnN0IHsgcnVuIH0gPSBhd2FpdCBpbXBvcnQoJy4uL3Rlc3QtcnVubmVyLmpzJyk7XG4gIGF3YWl0IHJ1bihfX2ZpbGVuYW1lKTtcbn0iXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBU0EsUUFBUSxFQUFFQyxFQUFFLEVBQUVDLE1BQU0sRUFBRUMsSUFBSSxF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