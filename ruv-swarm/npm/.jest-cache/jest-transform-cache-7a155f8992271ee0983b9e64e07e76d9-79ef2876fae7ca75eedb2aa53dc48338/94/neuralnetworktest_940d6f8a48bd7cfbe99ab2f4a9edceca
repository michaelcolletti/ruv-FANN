060019d4fbab5d9edd31301b8dae8091
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
// neural-network.test.js - Tests for neural network WASM integration

import { jest } from '@jest/globals';
import { createNeuralNetwork, createTrainer, createAgentNeuralManager, ActivationFunctions, initializeNeuralWasm, ACTIVATION_FUNCTIONS, TRAINING_ALGORITHMS, COGNITIVE_PATTERNS } from '../src/neural-network.js';
describe('Neural Network WASM Integration', () => {
  let wasm;
  beforeAll(/*#__PURE__*/_asyncToGenerator(function* () {
    wasm = yield initializeNeuralWasm();
  }));
  describe('Basic Neural Network', () => {
    test('should create a neural network', /*#__PURE__*/_asyncToGenerator(function* () {
      const network = yield createNeuralNetwork({
        inputSize: 2,
        hiddenLayers: [{
          size: 3,
          activation: ACTIVATION_FUNCTIONS.SIGMOID
        }],
        outputSize: 1,
        outputActivation: ACTIVATION_FUNCTIONS.SIGMOID
      });
      expect(network).toBeDefined();
      const info = network.getInfo();
      expect(info.numInputs).toBe(2);
      expect(info.numOutputs).toBe(1);
      expect(info.numLayers).toBeGreaterThanOrEqual(3); // input, hidden, output
    }));
    test('should run inference', /*#__PURE__*/_asyncToGenerator(function* () {
      const network = yield createNeuralNetwork({
        inputSize: 2,
        hiddenLayers: [{
          size: 3,
          activation: ACTIVATION_FUNCTIONS.RELU
        }],
        outputSize: 1,
        outputActivation: ACTIVATION_FUNCTIONS.SIGMOID
      });
      const output = yield network.run([0.5, 0.5]);
      expect(output).toHaveLength(1);
      expect(output[0]).toBeGreaterThanOrEqual(0);
      expect(output[0]).toBeLessThanOrEqual(1);
    }));
    test('should get and set weights', /*#__PURE__*/_asyncToGenerator(function* () {
      const network = yield createNeuralNetwork({
        inputSize: 2,
        hiddenLayers: [{
          size: 2,
          activation: ACTIVATION_FUNCTIONS.SIGMOID
        }],
        outputSize: 1,
        outputActivation: ACTIVATION_FUNCTIONS.SIGMOID
      });
      const weights = network.getWeights();
      expect(weights).toBeInstanceOf(Float32Array);
      expect(weights.length).toBeGreaterThan(0);

      // Modify weights
      const newWeights = new Float32Array(weights.length);
      for (let i = 0; i < weights.length; i++) {
        newWeights[i] = Math.random() * 2 - 1;
      }
      network.setWeights(newWeights);
      const retrievedWeights = network.getWeights();
      expect(retrievedWeights).toEqual(newWeights);
    }));
  });
  describe('Training Algorithms', () => {
    test.each([TRAINING_ALGORITHMS.INCREMENTAL_BACKPROP, TRAINING_ALGORITHMS.BATCH_BACKPROP, TRAINING_ALGORITHMS.RPROP, TRAINING_ALGORITHMS.QUICKPROP, TRAINING_ALGORITHMS.SARPROP])('should create trainer with %s algorithm', /*#__PURE__*/function () {
      var _ref5 = _asyncToGenerator(function* (algorithm) {
        const trainer = yield createTrainer({
          algorithm,
          maxEpochs: 100,
          targetError: 0.01
        });
        expect(trainer).toBeDefined();
        const info = trainer.getAlgorithmInfo();
        expect(info.name).toBeDefined();
        expect(info.type).toBeDefined();
      });
      return function (_x) {
        return _ref5.apply(this, arguments);
      };
    }());
    test('should train XOR problem', /*#__PURE__*/_asyncToGenerator(function* () {
      const network = yield createNeuralNetwork({
        inputSize: 2,
        hiddenLayers: [{
          size: 4,
          activation: ACTIVATION_FUNCTIONS.SIGMOID
        }, {
          size: 3,
          activation: ACTIVATION_FUNCTIONS.SIGMOID
        }],
        outputSize: 1,
        outputActivation: ACTIVATION_FUNCTIONS.SIGMOID
      });
      const trainer = yield createTrainer({
        algorithm: TRAINING_ALGORITHMS.RPROP,
        maxEpochs: 500,
        targetError: 0.01
      });
      const trainingData = {
        inputs: [[0, 0], [0, 1], [1, 0], [1, 1]],
        outputs: [[0], [1], [1], [0]]
      };
      const result = yield trainer.trainUntilTarget(network, trainingData, 0.01, 500);
      expect(result.converged).toBe(true);
      expect(result.finalError).toBeLessThan(0.01);

      // Test predictions
      const predictions = yield Promise.all(trainingData.inputs.map(input => network.run(input)));

      // Check XOR logic
      expect(predictions[0][0]).toBeLessThan(0.5); // [0,0] => 0
      expect(predictions[1][0]).toBeGreaterThan(0.5); // [0,1] => 1
      expect(predictions[2][0]).toBeGreaterThan(0.5); // [1,0] => 1
      expect(predictions[3][0]).toBeLessThan(0.5); // [1,1] => 0
    }));
  });
  describe('Activation Functions', () => {
    test('should list all 18 activation functions', /*#__PURE__*/_asyncToGenerator(function* () {
      const functions = yield ActivationFunctions.getAll(wasm);
      expect(functions).toHaveLength(18);
      const functionNames = functions.map(([name]) => name);
      expect(functionNames).toContain('sigmoid');
      expect(functionNames).toContain('relu');
      expect(functionNames).toContain('tanh');
      expect(functionNames).toContain('gaussian');
    }));
    test('should test activation functions', /*#__PURE__*/_asyncToGenerator(function* () {
      const sigmoid = yield ActivationFunctions.test(wasm, 'sigmoid', 0);
      expect(sigmoid).toBeCloseTo(0.5, 5);
      const relu = yield ActivationFunctions.test(wasm, 'relu', -1);
      expect(relu).toBe(0);
      const relu2 = yield ActivationFunctions.test(wasm, 'relu', 1);
      expect(relu2).toBe(1);
    }));
    test('should compare activation functions', /*#__PURE__*/_asyncToGenerator(function* () {
      const comparison = yield ActivationFunctions.compare(wasm, 0);
      expect(comparison).toBeDefined();
      expect(comparison.sigmoid).toBeCloseTo(0.5, 5);
      expect(comparison.tanh).toBeCloseTo(0, 5);
      expect(comparison.relu).toBe(0);
    }));
    test('should get activation function properties', /*#__PURE__*/_asyncToGenerator(function* () {
      const props = yield ActivationFunctions.getProperties(wasm, 'sigmoid');
      expect(props.name).toBe('Sigmoid');
      expect(props.trainable).toBe(true);
      expect(props.output_range.min).toBe('0');
      expect(props.output_range.max).toBe('1');
    }));
  });
  describe('Agent Neural Networks', () => {
    let manager;
    beforeEach(/*#__PURE__*/_asyncToGenerator(function* () {
      manager = yield createAgentNeuralManager();
    }));
    test('should create agent networks with cognitive patterns', /*#__PURE__*/_asyncToGenerator(function* () {
      const agentConfig = {
        agentId: 'test-agent-001',
        agentType: 'researcher',
        cognitivePattern: COGNITIVE_PATTERNS.DIVERGENT,
        inputSize: 10,
        outputSize: 5,
        taskSpecialization: ['pattern_recognition']
      };
      const agentId = yield manager.createAgentNetwork(agentConfig);
      expect(agentId).toBe('test-agent-001');
      const state = yield manager.getAgentCognitiveState(agentId);
      expect(state.agentId).toBe('test-agent-001');
      expect(state.cognitivePattern.pattern_type).toBe('divergent');
      expect(state.neuralArchitecture.layers).toBeGreaterThan(0);
    }));
    test('should support multiple agents with different patterns', /*#__PURE__*/_asyncToGenerator(function* () {
      const patterns = Object.values(COGNITIVE_PATTERNS);
      const agentIds = [];
      for (const pattern of patterns) {
        const agentId = `agent-${pattern}`;
        yield manager.createAgentNetwork({
          agentId,
          agentType: 'test',
          cognitivePattern: pattern,
          inputSize: 5,
          outputSize: 3
        });
        agentIds.push(agentId);
      }

      // Verify each agent has correct pattern
      for (let i = 0; i < patterns.length; i++) {
        const state = yield manager.getAgentCognitiveState(agentIds[i]);
        expect(state.cognitivePattern.pattern_type).toBe(patterns[i]);
      }
    }));
    test('should perform inference for agents', /*#__PURE__*/_asyncToGenerator(function* () {
      const agentId = yield manager.createAgentNetwork({
        agentId: 'inference-test',
        agentType: 'analyst',
        cognitivePattern: COGNITIVE_PATTERNS.CRITICAL,
        inputSize: 4,
        outputSize: 2
      });
      const input = [0.1, 0.2, 0.3, 0.4];
      const output = yield manager.getAgentInference(agentId, input);
      expect(output).toHaveLength(2);
      expect(output[0]).toBeGreaterThanOrEqual(0);
      expect(output[1]).toBeGreaterThanOrEqual(0);
    }));
    test('should train agent networks', /*#__PURE__*/_asyncToGenerator(function* () {
      const agentId = yield manager.createAgentNetwork({
        agentId: 'training-test',
        agentType: 'coder',
        cognitivePattern: COGNITIVE_PATTERNS.CONVERGENT,
        inputSize: 3,
        outputSize: 2
      });
      const trainingData = {
        inputs: Array(10).fill(null).map(() => [Math.random(), Math.random(), Math.random()]),
        outputs: Array(10).fill(null).map(() => [Math.random() > 0.5 ? 1 : 0, Math.random() > 0.5 ? 1 : 0])
      };
      const result = yield manager.trainAgentNetwork(agentId, trainingData);
      expect(result).toBeDefined();
      expect(result.epochs).toBeGreaterThan(0);
      expect(result.final_loss).toBeDefined();
    }));
    test('should support online adaptation', /*#__PURE__*/_asyncToGenerator(function* () {
      const agentId = yield manager.createAgentNetwork({
        agentId: 'adaptation-test',
        agentType: 'optimizer',
        cognitivePattern: COGNITIVE_PATTERNS.LATERAL,
        inputSize: 5,
        outputSize: 3
      });
      const experienceData = {
        inputs: [[0.1, 0.2, 0.3, 0.4, 0.5]],
        expected_outputs: [[1, 0, 1]],
        actual_outputs: [[0.8, 0.2, 0.9]],
        rewards: [0.85],
        context: {
          task: 'optimization'
        }
      };
      const result = yield manager.fineTuneDuringExecution(agentId, experienceData);
      expect(result).toBeDefined();
      expect(result.adapted).toBe(true);
    }));
  });
  describe('Performance and Memory', () => {
    test('should handle 100+ simultaneous agent networks', /*#__PURE__*/_asyncToGenerator(function* () {
      const manager = yield createAgentNeuralManager();
      const agentIds = [];

      // Create 100 agents
      for (let i = 0; i < 100; i++) {
        const patterns = Object.values(COGNITIVE_PATTERNS);
        const pattern = patterns[i % patterns.length];
        const agentId = yield manager.createAgentNetwork({
          agentId: `perf-agent-${i}`,
          agentType: 'test',
          cognitivePattern: pattern,
          inputSize: 10,
          outputSize: 5
        });
        agentIds.push(agentId);
      }
      expect(agentIds).toHaveLength(100);

      // Test inference on all agents
      const testInput = Array(10).fill(0.5);
      const inferencePromises = agentIds.map(id => manager.getAgentInference(id, testInput));
      const results = yield Promise.all(inferencePromises);
      expect(results).toHaveLength(100);
      results.forEach(output => {
        expect(output).toHaveLength(5);
      });
    }));
    test('should measure inference performance', /*#__PURE__*/_asyncToGenerator(function* () {
      const network = yield createNeuralNetwork({
        inputSize: 100,
        hiddenLayers: [{
          size: 50,
          activation: ACTIVATION_FUNCTIONS.RELU
        }, {
          size: 25,
          activation: ACTIVATION_FUNCTIONS.RELU
        }],
        outputSize: 10,
        outputActivation: ACTIVATION_FUNCTIONS.SOFTMAX
      });
      const input = Array(100).fill(0).map(() => Math.random());
      const startTime = performance.now();
      const iterations = 1000;
      for (let i = 0; i < iterations; i++) {
        yield network.run(input);
      }
      const endTime = performance.now();
      const avgTime = (endTime - startTime) / iterations;
      console.log(`Average inference time: ${avgTime.toFixed(3)}ms`);
      expect(avgTime).toBeLessThan(10); // Should be fast
    }));
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJqZXN0IiwiY3JlYXRlTmV1cmFsTmV0d29yayIsImNyZWF0ZVRyYWluZXIiLCJjcmVhdGVBZ2VudE5ldXJhbE1hbmFnZXIiLCJBY3RpdmF0aW9uRnVuY3Rpb25zIiwiaW5pdGlhbGl6ZU5ldXJhbFdhc20iLCJBQ1RJVkFUSU9OX0ZVTkNUSU9OUyIsIlRSQUlOSU5HX0FMR09SSVRITVMiLCJDT0dOSVRJVkVfUEFUVEVSTlMiLCJkZXNjcmliZSIsIndhc20iLCJiZWZvcmVBbGwiLCJfYXN5bmNUb0dlbmVyYXRvciIsInRlc3QiLCJuZXR3b3JrIiwiaW5wdXRTaXplIiwiaGlkZGVuTGF5ZXJzIiwic2l6ZSIsImFjdGl2YXRpb24iLCJTSUdNT0lEIiwib3V0cHV0U2l6ZSIsIm91dHB1dEFjdGl2YXRpb24iLCJleHBlY3QiLCJ0b0JlRGVmaW5lZCIsImluZm8iLCJnZXRJbmZvIiwibnVtSW5wdXRzIiwidG9CZSIsIm51bU91dHB1dHMiLCJudW1MYXllcnMiLCJ0b0JlR3JlYXRlclRoYW5PckVxdWFsIiwiUkVMVSIsIm91dHB1dCIsInJ1biIsInRvSGF2ZUxlbmd0aCIsInRvQmVMZXNzVGhhbk9yRXF1YWwiLCJ3ZWlnaHRzIiwiZ2V0V2VpZ2h0cyIsInRvQmVJbnN0YW5jZU9mIiwiRmxvYXQzMkFycmF5IiwibGVuZ3RoIiwidG9CZUdyZWF0ZXJUaGFuIiwibmV3V2VpZ2h0cyIsImkiLCJNYXRoIiwicmFuZG9tIiwic2V0V2VpZ2h0cyIsInJldHJpZXZlZFdlaWdodHMiLCJ0b0VxdWFsIiwiZWFjaCIsIklOQ1JFTUVOVEFMX0JBQ0tQUk9QIiwiQkFUQ0hfQkFDS1BST1AiLCJSUFJPUCIsIlFVSUNLUFJPUCIsIlNBUlBST1AiLCJfcmVmNSIsImFsZ29yaXRobSIsInRyYWluZXIiLCJtYXhFcG9jaHMiLCJ0YXJnZXRFcnJvciIsImdldEFsZ29yaXRobUluZm8iLCJuYW1lIiwidHlwZSIsIl94IiwiYXBwbHkiLCJhcmd1bWVudHMiLCJ0cmFpbmluZ0RhdGEiLCJpbnB1dHMiLCJvdXRwdXRzIiwicmVzdWx0IiwidHJhaW5VbnRpbFRhcmdldCIsImNvbnZlcmdlZCIsImZpbmFsRXJyb3IiLCJ0b0JlTGVzc1RoYW4iLCJwcmVkaWN0aW9ucyIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJpbnB1dCIsImZ1bmN0aW9ucyIsImdldEFsbCIsImZ1bmN0aW9uTmFtZXMiLCJ0b0NvbnRhaW4iLCJzaWdtb2lkIiwidG9CZUNsb3NlVG8iLCJyZWx1IiwicmVsdTIiLCJjb21wYXJpc29uIiwiY29tcGFyZSIsInRhbmgiLCJwcm9wcyIsImdldFByb3BlcnRpZXMiLCJ0cmFpbmFibGUiLCJvdXRwdXRfcmFuZ2UiLCJtaW4iLCJtYXgiLCJtYW5hZ2VyIiwiYmVmb3JlRWFjaCIsImFnZW50Q29uZmlnIiwiYWdlbnRJZCIsImFnZW50VHlwZSIsImNvZ25pdGl2ZVBhdHRlcm4iLCJESVZFUkdFTlQiLCJ0YXNrU3BlY2lhbGl6YXRpb24iLCJjcmVhdGVBZ2VudE5ldHdvcmsiLCJzdGF0ZSIsImdldEFnZW50Q29nbml0aXZlU3RhdGUiLCJwYXR0ZXJuX3R5cGUiLCJuZXVyYWxBcmNoaXRlY3R1cmUiLCJsYXllcnMiLCJwYXR0ZXJucyIsIk9iamVjdCIsInZhbHVlcyIsImFnZW50SWRzIiwicGF0dGVybiIsInB1c2giLCJDUklUSUNBTCIsImdldEFnZW50SW5mZXJlbmNlIiwiQ09OVkVSR0VOVCIsIkFycmF5IiwiZmlsbCIsInRyYWluQWdlbnROZXR3b3JrIiwiZXBvY2hzIiwiZmluYWxfbG9zcyIsIkxBVEVSQUwiLCJleHBlcmllbmNlRGF0YSIsImV4cGVjdGVkX291dHB1dHMiLCJhY3R1YWxfb3V0cHV0cyIsInJld2FyZHMiLCJjb250ZXh0IiwidGFzayIsImZpbmVUdW5lRHVyaW5nRXhlY3V0aW9uIiwiYWRhcHRlZCIsInRlc3RJbnB1dCIsImluZmVyZW5jZVByb21pc2VzIiwiaWQiLCJyZXN1bHRzIiwiZm9yRWFjaCIsIlNPRlRNQVgiLCJzdGFydFRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsIml0ZXJhdGlvbnMiLCJlbmRUaW1lIiwiYXZnVGltZSIsImNvbnNvbGUiLCJsb2ciLCJ0b0ZpeGVkIl0sInNvdXJjZXMiOlsibmV1cmFsLW5ldHdvcmsudGVzdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBuZXVyYWwtbmV0d29yay50ZXN0LmpzIC0gVGVzdHMgZm9yIG5ldXJhbCBuZXR3b3JrIFdBU00gaW50ZWdyYXRpb25cblxuaW1wb3J0IHsgamVzdCB9IGZyb20gJ0BqZXN0L2dsb2JhbHMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlTmV1cmFsTmV0d29yayxcbiAgY3JlYXRlVHJhaW5lcixcbiAgY3JlYXRlQWdlbnROZXVyYWxNYW5hZ2VyLFxuICBBY3RpdmF0aW9uRnVuY3Rpb25zLFxuICBpbml0aWFsaXplTmV1cmFsV2FzbSxcbiAgQUNUSVZBVElPTl9GVU5DVElPTlMsXG4gIFRSQUlOSU5HX0FMR09SSVRITVMsXG4gIENPR05JVElWRV9QQVRURVJOUyxcbn0gZnJvbSAnLi4vc3JjL25ldXJhbC1uZXR3b3JrLmpzJztcblxuZGVzY3JpYmUoJ05ldXJhbCBOZXR3b3JrIFdBU00gSW50ZWdyYXRpb24nLCAoKSA9PiB7XG4gIGxldCB3YXNtO1xuXG4gIGJlZm9yZUFsbChhc3luYygpID0+IHtcbiAgICB3YXNtID0gYXdhaXQgaW5pdGlhbGl6ZU5ldXJhbFdhc20oKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Jhc2ljIE5ldXJhbCBOZXR3b3JrJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBjcmVhdGUgYSBuZXVyYWwgbmV0d29yaycsIGFzeW5jKCkgPT4ge1xuICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IGNyZWF0ZU5ldXJhbE5ldHdvcmsoe1xuICAgICAgICBpbnB1dFNpemU6IDIsXG4gICAgICAgIGhpZGRlbkxheWVyczogW1xuICAgICAgICAgIHsgc2l6ZTogMywgYWN0aXZhdGlvbjogQUNUSVZBVElPTl9GVU5DVElPTlMuU0lHTU9JRCB9LFxuICAgICAgICBdLFxuICAgICAgICBvdXRwdXRTaXplOiAxLFxuICAgICAgICBvdXRwdXRBY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5TSUdNT0lELFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChuZXR3b3JrKS50b0JlRGVmaW5lZCgpO1xuXG4gICAgICBjb25zdCBpbmZvID0gbmV0d29yay5nZXRJbmZvKCk7XG4gICAgICBleHBlY3QoaW5mby5udW1JbnB1dHMpLnRvQmUoMik7XG4gICAgICBleHBlY3QoaW5mby5udW1PdXRwdXRzKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KGluZm8ubnVtTGF5ZXJzKS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDMpOyAvLyBpbnB1dCwgaGlkZGVuLCBvdXRwdXRcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBydW4gaW5mZXJlbmNlJywgYXN5bmMoKSA9PiB7XG4gICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgY3JlYXRlTmV1cmFsTmV0d29yayh7XG4gICAgICAgIGlucHV0U2l6ZTogMixcbiAgICAgICAgaGlkZGVuTGF5ZXJzOiBbeyBzaXplOiAzLCBhY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5SRUxVIH1dLFxuICAgICAgICBvdXRwdXRTaXplOiAxLFxuICAgICAgICBvdXRwdXRBY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5TSUdNT0lELFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IG5ldHdvcmsucnVuKFswLjUsIDAuNV0pO1xuICAgICAgZXhwZWN0KG91dHB1dCkudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KG91dHB1dFswXSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKTtcbiAgICAgIGV4cGVjdChvdXRwdXRbMF0pLnRvQmVMZXNzVGhhbk9yRXF1YWwoMSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgZ2V0IGFuZCBzZXQgd2VpZ2h0cycsIGFzeW5jKCkgPT4ge1xuICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IGNyZWF0ZU5ldXJhbE5ldHdvcmsoe1xuICAgICAgICBpbnB1dFNpemU6IDIsXG4gICAgICAgIGhpZGRlbkxheWVyczogW3sgc2l6ZTogMiwgYWN0aXZhdGlvbjogQUNUSVZBVElPTl9GVU5DVElPTlMuU0lHTU9JRCB9XSxcbiAgICAgICAgb3V0cHV0U2l6ZTogMSxcbiAgICAgICAgb3V0cHV0QWN0aXZhdGlvbjogQUNUSVZBVElPTl9GVU5DVElPTlMuU0lHTU9JRCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB3ZWlnaHRzID0gbmV0d29yay5nZXRXZWlnaHRzKCk7XG4gICAgICBleHBlY3Qod2VpZ2h0cykudG9CZUluc3RhbmNlT2YoRmxvYXQzMkFycmF5KTtcbiAgICAgIGV4cGVjdCh3ZWlnaHRzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuXG4gICAgICAvLyBNb2RpZnkgd2VpZ2h0c1xuICAgICAgY29uc3QgbmV3V2VpZ2h0cyA9IG5ldyBGbG9hdDMyQXJyYXkod2VpZ2h0cy5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3ZWlnaHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ld1dlaWdodHNbaV0gPSBNYXRoLnJhbmRvbSgpICogMiAtIDE7XG4gICAgICB9XG5cbiAgICAgIG5ldHdvcmsuc2V0V2VpZ2h0cyhuZXdXZWlnaHRzKTtcbiAgICAgIGNvbnN0IHJldHJpZXZlZFdlaWdodHMgPSBuZXR3b3JrLmdldFdlaWdodHMoKTtcbiAgICAgIGV4cGVjdChyZXRyaWV2ZWRXZWlnaHRzKS50b0VxdWFsKG5ld1dlaWdodHMpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnVHJhaW5pbmcgQWxnb3JpdGhtcycsICgpID0+IHtcbiAgICB0ZXN0LmVhY2goW1xuICAgICAgVFJBSU5JTkdfQUxHT1JJVEhNUy5JTkNSRU1FTlRBTF9CQUNLUFJPUCxcbiAgICAgIFRSQUlOSU5HX0FMR09SSVRITVMuQkFUQ0hfQkFDS1BST1AsXG4gICAgICBUUkFJTklOR19BTEdPUklUSE1TLlJQUk9QLFxuICAgICAgVFJBSU5JTkdfQUxHT1JJVEhNUy5RVUlDS1BST1AsXG4gICAgICBUUkFJTklOR19BTEdPUklUSE1TLlNBUlBST1AsXG4gICAgXSkoJ3Nob3VsZCBjcmVhdGUgdHJhaW5lciB3aXRoICVzIGFsZ29yaXRobScsIGFzeW5jKGFsZ29yaXRobSkgPT4ge1xuICAgICAgY29uc3QgdHJhaW5lciA9IGF3YWl0IGNyZWF0ZVRyYWluZXIoe1xuICAgICAgICBhbGdvcml0aG0sXG4gICAgICAgIG1heEVwb2NoczogMTAwLFxuICAgICAgICB0YXJnZXRFcnJvcjogMC4wMSxcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QodHJhaW5lcikudG9CZURlZmluZWQoKTtcbiAgICAgIGNvbnN0IGluZm8gPSB0cmFpbmVyLmdldEFsZ29yaXRobUluZm8oKTtcbiAgICAgIGV4cGVjdChpbmZvLm5hbWUpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoaW5mby50eXBlKS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHRyYWluIFhPUiBwcm9ibGVtJywgYXN5bmMoKSA9PiB7XG4gICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgY3JlYXRlTmV1cmFsTmV0d29yayh7XG4gICAgICAgIGlucHV0U2l6ZTogMixcbiAgICAgICAgaGlkZGVuTGF5ZXJzOiBbXG4gICAgICAgICAgeyBzaXplOiA0LCBhY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5TSUdNT0lEIH0sXG4gICAgICAgICAgeyBzaXplOiAzLCBhY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5TSUdNT0lEIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG91dHB1dFNpemU6IDEsXG4gICAgICAgIG91dHB1dEFjdGl2YXRpb246IEFDVElWQVRJT05fRlVOQ1RJT05TLlNJR01PSUQsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdHJhaW5lciA9IGF3YWl0IGNyZWF0ZVRyYWluZXIoe1xuICAgICAgICBhbGdvcml0aG06IFRSQUlOSU5HX0FMR09SSVRITVMuUlBST1AsXG4gICAgICAgIG1heEVwb2NoczogNTAwLFxuICAgICAgICB0YXJnZXRFcnJvcjogMC4wMSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB0cmFpbmluZ0RhdGEgPSB7XG4gICAgICAgIGlucHV0czogW1swLCAwXSwgWzAsIDFdLCBbMSwgMF0sIFsxLCAxXV0sXG4gICAgICAgIG91dHB1dHM6IFtbMF0sIFsxXSwgWzFdLCBbMF1dLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdHJhaW5lci50cmFpblVudGlsVGFyZ2V0KG5ldHdvcmssIHRyYWluaW5nRGF0YSwgMC4wMSwgNTAwKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY29udmVyZ2VkKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5maW5hbEVycm9yKS50b0JlTGVzc1RoYW4oMC4wMSk7XG5cbiAgICAgIC8vIFRlc3QgcHJlZGljdGlvbnNcbiAgICAgIGNvbnN0IHByZWRpY3Rpb25zID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIHRyYWluaW5nRGF0YS5pbnB1dHMubWFwKGlucHV0ID0+IG5ldHdvcmsucnVuKGlucHV0KSksXG4gICAgICApO1xuXG4gICAgICAvLyBDaGVjayBYT1IgbG9naWNcbiAgICAgIGV4cGVjdChwcmVkaWN0aW9uc1swXVswXSkudG9CZUxlc3NUaGFuKDAuNSk7IC8vIFswLDBdID0+IDBcbiAgICAgIGV4cGVjdChwcmVkaWN0aW9uc1sxXVswXSkudG9CZUdyZWF0ZXJUaGFuKDAuNSk7IC8vIFswLDFdID0+IDFcbiAgICAgIGV4cGVjdChwcmVkaWN0aW9uc1syXVswXSkudG9CZUdyZWF0ZXJUaGFuKDAuNSk7IC8vIFsxLDBdID0+IDFcbiAgICAgIGV4cGVjdChwcmVkaWN0aW9uc1szXVswXSkudG9CZUxlc3NUaGFuKDAuNSk7IC8vIFsxLDFdID0+IDBcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0FjdGl2YXRpb24gRnVuY3Rpb25zJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBsaXN0IGFsbCAxOCBhY3RpdmF0aW9uIGZ1bmN0aW9ucycsIGFzeW5jKCkgPT4ge1xuICAgICAgY29uc3QgZnVuY3Rpb25zID0gYXdhaXQgQWN0aXZhdGlvbkZ1bmN0aW9ucy5nZXRBbGwod2FzbSk7XG4gICAgICBleHBlY3QoZnVuY3Rpb25zKS50b0hhdmVMZW5ndGgoMTgpO1xuXG4gICAgICBjb25zdCBmdW5jdGlvbk5hbWVzID0gZnVuY3Rpb25zLm1hcCgoW25hbWVdKSA9PiBuYW1lKTtcbiAgICAgIGV4cGVjdChmdW5jdGlvbk5hbWVzKS50b0NvbnRhaW4oJ3NpZ21vaWQnKTtcbiAgICAgIGV4cGVjdChmdW5jdGlvbk5hbWVzKS50b0NvbnRhaW4oJ3JlbHUnKTtcbiAgICAgIGV4cGVjdChmdW5jdGlvbk5hbWVzKS50b0NvbnRhaW4oJ3RhbmgnKTtcbiAgICAgIGV4cGVjdChmdW5jdGlvbk5hbWVzKS50b0NvbnRhaW4oJ2dhdXNzaWFuJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgdGVzdCBhY3RpdmF0aW9uIGZ1bmN0aW9ucycsIGFzeW5jKCkgPT4ge1xuICAgICAgY29uc3Qgc2lnbW9pZCA9IGF3YWl0IEFjdGl2YXRpb25GdW5jdGlvbnMudGVzdCh3YXNtLCAnc2lnbW9pZCcsIDApO1xuICAgICAgZXhwZWN0KHNpZ21vaWQpLnRvQmVDbG9zZVRvKDAuNSwgNSk7XG5cbiAgICAgIGNvbnN0IHJlbHUgPSBhd2FpdCBBY3RpdmF0aW9uRnVuY3Rpb25zLnRlc3Qod2FzbSwgJ3JlbHUnLCAtMSk7XG4gICAgICBleHBlY3QocmVsdSkudG9CZSgwKTtcblxuICAgICAgY29uc3QgcmVsdTIgPSBhd2FpdCBBY3RpdmF0aW9uRnVuY3Rpb25zLnRlc3Qod2FzbSwgJ3JlbHUnLCAxKTtcbiAgICAgIGV4cGVjdChyZWx1MikudG9CZSgxKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBjb21wYXJlIGFjdGl2YXRpb24gZnVuY3Rpb25zJywgYXN5bmMoKSA9PiB7XG4gICAgICBjb25zdCBjb21wYXJpc29uID0gYXdhaXQgQWN0aXZhdGlvbkZ1bmN0aW9ucy5jb21wYXJlKHdhc20sIDApO1xuICAgICAgZXhwZWN0KGNvbXBhcmlzb24pLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoY29tcGFyaXNvbi5zaWdtb2lkKS50b0JlQ2xvc2VUbygwLjUsIDUpO1xuICAgICAgZXhwZWN0KGNvbXBhcmlzb24udGFuaCkudG9CZUNsb3NlVG8oMCwgNSk7XG4gICAgICBleHBlY3QoY29tcGFyaXNvbi5yZWx1KS50b0JlKDApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGdldCBhY3RpdmF0aW9uIGZ1bmN0aW9uIHByb3BlcnRpZXMnLCBhc3luYygpID0+IHtcbiAgICAgIGNvbnN0IHByb3BzID0gYXdhaXQgQWN0aXZhdGlvbkZ1bmN0aW9ucy5nZXRQcm9wZXJ0aWVzKHdhc20sICdzaWdtb2lkJyk7XG4gICAgICBleHBlY3QocHJvcHMubmFtZSkudG9CZSgnU2lnbW9pZCcpO1xuICAgICAgZXhwZWN0KHByb3BzLnRyYWluYWJsZSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChwcm9wcy5vdXRwdXRfcmFuZ2UubWluKS50b0JlKCcwJyk7XG4gICAgICBleHBlY3QocHJvcHMub3V0cHV0X3JhbmdlLm1heCkudG9CZSgnMScpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQWdlbnQgTmV1cmFsIE5ldHdvcmtzJywgKCkgPT4ge1xuICAgIGxldCBtYW5hZ2VyO1xuXG4gICAgYmVmb3JlRWFjaChhc3luYygpID0+IHtcbiAgICAgIG1hbmFnZXIgPSBhd2FpdCBjcmVhdGVBZ2VudE5ldXJhbE1hbmFnZXIoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBjcmVhdGUgYWdlbnQgbmV0d29ya3Mgd2l0aCBjb2duaXRpdmUgcGF0dGVybnMnLCBhc3luYygpID0+IHtcbiAgICAgIGNvbnN0IGFnZW50Q29uZmlnID0ge1xuICAgICAgICBhZ2VudElkOiAndGVzdC1hZ2VudC0wMDEnLFxuICAgICAgICBhZ2VudFR5cGU6ICdyZXNlYXJjaGVyJyxcbiAgICAgICAgY29nbml0aXZlUGF0dGVybjogQ09HTklUSVZFX1BBVFRFUk5TLkRJVkVSR0VOVCxcbiAgICAgICAgaW5wdXRTaXplOiAxMCxcbiAgICAgICAgb3V0cHV0U2l6ZTogNSxcbiAgICAgICAgdGFza1NwZWNpYWxpemF0aW9uOiBbJ3BhdHRlcm5fcmVjb2duaXRpb24nXSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGFnZW50SWQgPSBhd2FpdCBtYW5hZ2VyLmNyZWF0ZUFnZW50TmV0d29yayhhZ2VudENvbmZpZyk7XG4gICAgICBleHBlY3QoYWdlbnRJZCkudG9CZSgndGVzdC1hZ2VudC0wMDEnKTtcblxuICAgICAgY29uc3Qgc3RhdGUgPSBhd2FpdCBtYW5hZ2VyLmdldEFnZW50Q29nbml0aXZlU3RhdGUoYWdlbnRJZCk7XG4gICAgICBleHBlY3Qoc3RhdGUuYWdlbnRJZCkudG9CZSgndGVzdC1hZ2VudC0wMDEnKTtcbiAgICAgIGV4cGVjdChzdGF0ZS5jb2duaXRpdmVQYXR0ZXJuLnBhdHRlcm5fdHlwZSkudG9CZSgnZGl2ZXJnZW50Jyk7XG4gICAgICBleHBlY3Qoc3RhdGUubmV1cmFsQXJjaGl0ZWN0dXJlLmxheWVycykudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHN1cHBvcnQgbXVsdGlwbGUgYWdlbnRzIHdpdGggZGlmZmVyZW50IHBhdHRlcm5zJywgYXN5bmMoKSA9PiB7XG4gICAgICBjb25zdCBwYXR0ZXJucyA9IE9iamVjdC52YWx1ZXMoQ09HTklUSVZFX1BBVFRFUk5TKTtcbiAgICAgIGNvbnN0IGFnZW50SWRzID0gW107XG5cbiAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBwYXR0ZXJucykge1xuICAgICAgICBjb25zdCBhZ2VudElkID0gYGFnZW50LSR7cGF0dGVybn1gO1xuICAgICAgICBhd2FpdCBtYW5hZ2VyLmNyZWF0ZUFnZW50TmV0d29yayh7XG4gICAgICAgICAgYWdlbnRJZCxcbiAgICAgICAgICBhZ2VudFR5cGU6ICd0ZXN0JyxcbiAgICAgICAgICBjb2duaXRpdmVQYXR0ZXJuOiBwYXR0ZXJuLFxuICAgICAgICAgIGlucHV0U2l6ZTogNSxcbiAgICAgICAgICBvdXRwdXRTaXplOiAzLFxuICAgICAgICB9KTtcbiAgICAgICAgYWdlbnRJZHMucHVzaChhZ2VudElkKTtcbiAgICAgIH1cblxuICAgICAgLy8gVmVyaWZ5IGVhY2ggYWdlbnQgaGFzIGNvcnJlY3QgcGF0dGVyblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGF3YWl0IG1hbmFnZXIuZ2V0QWdlbnRDb2duaXRpdmVTdGF0ZShhZ2VudElkc1tpXSk7XG4gICAgICAgIGV4cGVjdChzdGF0ZS5jb2duaXRpdmVQYXR0ZXJuLnBhdHRlcm5fdHlwZSkudG9CZShwYXR0ZXJuc1tpXSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcGVyZm9ybSBpbmZlcmVuY2UgZm9yIGFnZW50cycsIGFzeW5jKCkgPT4ge1xuICAgICAgY29uc3QgYWdlbnRJZCA9IGF3YWl0IG1hbmFnZXIuY3JlYXRlQWdlbnROZXR3b3JrKHtcbiAgICAgICAgYWdlbnRJZDogJ2luZmVyZW5jZS10ZXN0JyxcbiAgICAgICAgYWdlbnRUeXBlOiAnYW5hbHlzdCcsXG4gICAgICAgIGNvZ25pdGl2ZVBhdHRlcm46IENPR05JVElWRV9QQVRURVJOUy5DUklUSUNBTCxcbiAgICAgICAgaW5wdXRTaXplOiA0LFxuICAgICAgICBvdXRwdXRTaXplOiAyLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGlucHV0ID0gWzAuMSwgMC4yLCAwLjMsIDAuNF07XG4gICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCBtYW5hZ2VyLmdldEFnZW50SW5mZXJlbmNlKGFnZW50SWQsIGlucHV0KTtcblxuICAgICAgZXhwZWN0KG91dHB1dCkudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgZXhwZWN0KG91dHB1dFswXSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKTtcbiAgICAgIGV4cGVjdChvdXRwdXRbMV0pLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgdHJhaW4gYWdlbnQgbmV0d29ya3MnLCBhc3luYygpID0+IHtcbiAgICAgIGNvbnN0IGFnZW50SWQgPSBhd2FpdCBtYW5hZ2VyLmNyZWF0ZUFnZW50TmV0d29yayh7XG4gICAgICAgIGFnZW50SWQ6ICd0cmFpbmluZy10ZXN0JyxcbiAgICAgICAgYWdlbnRUeXBlOiAnY29kZXInLFxuICAgICAgICBjb2duaXRpdmVQYXR0ZXJuOiBDT0dOSVRJVkVfUEFUVEVSTlMuQ09OVkVSR0VOVCxcbiAgICAgICAgaW5wdXRTaXplOiAzLFxuICAgICAgICBvdXRwdXRTaXplOiAyLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHRyYWluaW5nRGF0YSA9IHtcbiAgICAgICAgaW5wdXRzOiBBcnJheSgxMCkuZmlsbChudWxsKS5tYXAoKCkgPT4gW01hdGgucmFuZG9tKCksIE1hdGgucmFuZG9tKCksIE1hdGgucmFuZG9tKCldKSxcbiAgICAgICAgb3V0cHV0czogQXJyYXkoMTApLmZpbGwobnVsbCkubWFwKCgpID0+IFtNYXRoLnJhbmRvbSgpID4gMC41ID8gMSA6IDAsIE1hdGgucmFuZG9tKCkgPiAwLjUgPyAxIDogMF0pLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbWFuYWdlci50cmFpbkFnZW50TmV0d29yayhhZ2VudElkLCB0cmFpbmluZ0RhdGEpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXBvY2hzKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBleHBlY3QocmVzdWx0LmZpbmFsX2xvc3MpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgc3VwcG9ydCBvbmxpbmUgYWRhcHRhdGlvbicsIGFzeW5jKCkgPT4ge1xuICAgICAgY29uc3QgYWdlbnRJZCA9IGF3YWl0IG1hbmFnZXIuY3JlYXRlQWdlbnROZXR3b3JrKHtcbiAgICAgICAgYWdlbnRJZDogJ2FkYXB0YXRpb24tdGVzdCcsXG4gICAgICAgIGFnZW50VHlwZTogJ29wdGltaXplcicsXG4gICAgICAgIGNvZ25pdGl2ZVBhdHRlcm46IENPR05JVElWRV9QQVRURVJOUy5MQVRFUkFMLFxuICAgICAgICBpbnB1dFNpemU6IDUsXG4gICAgICAgIG91dHB1dFNpemU6IDMsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZXhwZXJpZW5jZURhdGEgPSB7XG4gICAgICAgIGlucHV0czogW1swLjEsIDAuMiwgMC4zLCAwLjQsIDAuNV1dLFxuICAgICAgICBleHBlY3RlZF9vdXRwdXRzOiBbWzEsIDAsIDFdXSxcbiAgICAgICAgYWN0dWFsX291dHB1dHM6IFtbMC44LCAwLjIsIDAuOV1dLFxuICAgICAgICByZXdhcmRzOiBbMC44NV0sXG4gICAgICAgIGNvbnRleHQ6IHsgdGFzazogJ29wdGltaXphdGlvbicgfSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1hbmFnZXIuZmluZVR1bmVEdXJpbmdFeGVjdXRpb24oYWdlbnRJZCwgZXhwZXJpZW5jZURhdGEpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuYWRhcHRlZCkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1BlcmZvcm1hbmNlIGFuZCBNZW1vcnknLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSAxMDArIHNpbXVsdGFuZW91cyBhZ2VudCBuZXR3b3JrcycsIGFzeW5jKCkgPT4ge1xuICAgICAgY29uc3QgbWFuYWdlciA9IGF3YWl0IGNyZWF0ZUFnZW50TmV1cmFsTWFuYWdlcigpO1xuICAgICAgY29uc3QgYWdlbnRJZHMgPSBbXTtcblxuICAgICAgLy8gQ3JlYXRlIDEwMCBhZ2VudHNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGF0dGVybnMgPSBPYmplY3QudmFsdWVzKENPR05JVElWRV9QQVRURVJOUyk7XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSBwYXR0ZXJuc1tpICUgcGF0dGVybnMubGVuZ3RoXTtcblxuICAgICAgICBjb25zdCBhZ2VudElkID0gYXdhaXQgbWFuYWdlci5jcmVhdGVBZ2VudE5ldHdvcmsoe1xuICAgICAgICAgIGFnZW50SWQ6IGBwZXJmLWFnZW50LSR7aX1gLFxuICAgICAgICAgIGFnZW50VHlwZTogJ3Rlc3QnLFxuICAgICAgICAgIGNvZ25pdGl2ZVBhdHRlcm46IHBhdHRlcm4sXG4gICAgICAgICAgaW5wdXRTaXplOiAxMCxcbiAgICAgICAgICBvdXRwdXRTaXplOiA1LFxuICAgICAgICB9KTtcblxuICAgICAgICBhZ2VudElkcy5wdXNoKGFnZW50SWQpO1xuICAgICAgfVxuXG4gICAgICBleHBlY3QoYWdlbnRJZHMpLnRvSGF2ZUxlbmd0aCgxMDApO1xuXG4gICAgICAvLyBUZXN0IGluZmVyZW5jZSBvbiBhbGwgYWdlbnRzXG4gICAgICBjb25zdCB0ZXN0SW5wdXQgPSBBcnJheSgxMCkuZmlsbCgwLjUpO1xuICAgICAgY29uc3QgaW5mZXJlbmNlUHJvbWlzZXMgPSBhZ2VudElkcy5tYXAoaWQgPT5cbiAgICAgICAgbWFuYWdlci5nZXRBZ2VudEluZmVyZW5jZShpZCwgdGVzdElucHV0KSxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChpbmZlcmVuY2VQcm9taXNlcyk7XG4gICAgICBleHBlY3QocmVzdWx0cykudG9IYXZlTGVuZ3RoKDEwMCk7XG4gICAgICByZXN1bHRzLmZvckVhY2gob3V0cHV0ID0+IHtcbiAgICAgICAgZXhwZWN0KG91dHB1dCkudG9IYXZlTGVuZ3RoKDUpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgbWVhc3VyZSBpbmZlcmVuY2UgcGVyZm9ybWFuY2UnLCBhc3luYygpID0+IHtcbiAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCBjcmVhdGVOZXVyYWxOZXR3b3JrKHtcbiAgICAgICAgaW5wdXRTaXplOiAxMDAsXG4gICAgICAgIGhpZGRlbkxheWVyczogW1xuICAgICAgICAgIHsgc2l6ZTogNTAsIGFjdGl2YXRpb246IEFDVElWQVRJT05fRlVOQ1RJT05TLlJFTFUgfSxcbiAgICAgICAgICB7IHNpemU6IDI1LCBhY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5SRUxVIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG91dHB1dFNpemU6IDEwLFxuICAgICAgICBvdXRwdXRBY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5TT0ZUTUFYLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGlucHV0ID0gQXJyYXkoMTAwKS5maWxsKDApLm1hcCgoKSA9PiBNYXRoLnJhbmRvbSgpKTtcblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBpdGVyYXRpb25zID0gMTAwMDtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgYXdhaXQgbmV0d29yay5ydW4oaW5wdXQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBhdmdUaW1lID0gKGVuZFRpbWUgLSBzdGFydFRpbWUpIC8gaXRlcmF0aW9ucztcblxuICAgICAgY29uc29sZS5sb2coYEF2ZXJhZ2UgaW5mZXJlbmNlIHRpbWU6ICR7YXZnVGltZS50b0ZpeGVkKDMpfW1zYCk7XG4gICAgICBleHBlY3QoYXZnVGltZSkudG9CZUxlc3NUaGFuKDEwKTsgLy8gU2hvdWxkIGJlIGZhc3RcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwibWFwcGluZ3MiOiI7O0FBQUE7O0FBRUEsU0FBU0EsSUFBSSxRQUFRLGVBQWU7QUFDcEMsU0FDRUMsbUJBQW1CLEVBQ25CQyxhQUFhLEVBQ2JDLHdCQUF3QixFQUN4QkMsbUJBQW1CLEVBQ25CQyxvQkFBb0IsRUFDcEJDLG9CQUFvQixFQUNwQkMsbUJBQW1CLEVBQ25CQyxrQkFBa0IsUUFDYiwwQkFBMEI7QUFFakNDLFFBQVEsQ0FBQyxpQ0FBaUMsRUFBRSxNQUFNO0VBQ2hELElBQUlDLElBQUk7RUFFUkMsU0FBUyxjQUFBQyxpQkFBQSxDQUFDLGFBQVc7SUFDbkJGLElBQUksU0FBU0wsb0JBQW9CLENBQUMsQ0FBQztFQUNyQyxDQUFDLEVBQUM7RUFFRkksUUFBUSxDQUFDLHNCQUFzQixFQUFFLE1BQU07SUFDckNJLElBQUksQ0FBQyxnQ0FBZ0MsZUFBQUQsaUJBQUEsQ0FBRSxhQUFXO01BQ2hELE1BQU1FLE9BQU8sU0FBU2IsbUJBQW1CLENBQUM7UUFDeENjLFNBQVMsRUFBRSxDQUFDO1FBQ1pDLFlBQVksRUFBRSxDQUNaO1VBQUVDLElBQUksRUFBRSxDQUFDO1VBQUVDLFVBQVUsRUFBRVosb0JBQW9CLENBQUNhO1FBQVEsQ0FBQyxDQUN0RDtRQUNEQyxVQUFVLEVBQUUsQ0FBQztRQUNiQyxnQkFBZ0IsRUFBRWYsb0JBQW9CLENBQUNhO01BQ3pDLENBQUMsQ0FBQztNQUVGRyxNQUFNLENBQUNSLE9BQU8sQ0FBQyxDQUFDUyxXQUFXLENBQUMsQ0FBQztNQUU3QixNQUFNQyxJQUFJLEdBQUdWLE9BQU8sQ0FBQ1csT0FBTyxDQUFDLENBQUM7TUFDOUJILE1BQU0sQ0FBQ0UsSUFBSSxDQUFDRSxTQUFTLENBQUMsQ0FBQ0MsSUFBSSxDQUFDLENBQUMsQ0FBQztNQUM5QkwsTUFBTSxDQUFDRSxJQUFJLENBQUNJLFVBQVUsQ0FBQyxD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