a715983a39dfb228532e490a187db933
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
/**
 * End-to-End Workflow Tests
 * Tests complete user scenarios from initialization to results
 */

import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { RuvSwarm } from '../../src/index-enhanced.js';
import { EnhancedMCPTools } from '../../src/mcp-tools-enhanced.js';
import fs from 'fs/promises';
import path from 'path';
describe('E2E Workflow Scenarios', () => {
  let ruvSwarm;
  let mcpTools;
  let testDir;
  beforeAll(/*#__PURE__*/_asyncToGenerator(function* () {
    // Create test directory for outputs
    testDir = path.join(process.cwd(), 'test-outputs', `e2e-${Date.now()}`);
    yield fs.mkdir(testDir, {
      recursive: true
    });

    // Initialize system
    ruvSwarm = yield RuvSwarm.initialize({
      loadingStrategy: 'full',
      enablePersistence: true,
      enableNeuralNetworks: true,
      enableForecasting: true,
      useSIMD: true,
      persistencePath: path.join(testDir, 'persistence.db')
    });
    mcpTools = new EnhancedMCPTools();
    yield mcpTools.initialize();
  }));
  afterAll(/*#__PURE__*/_asyncToGenerator(function* () {
    if (ruvSwarm) {
      yield ruvSwarm.cleanup();
    }
    // Clean up test directory
    yield fs.rm(testDir, {
      recursive: true,
      force: true
    });
  }));
  describe('Machine Learning Pipeline Workflow', () => {
    it('should complete full ML pipeline from data to predictions', /*#__PURE__*/_asyncToGenerator(function* () {
      console.log('\n🔬 Starting ML Pipeline Workflow...');

      // Step 1: Create swarm for ML tasks
      const mlSwarm = yield ruvSwarm.createSwarm({
        name: 'ml-pipeline-swarm',
        topology: 'hierarchical',
        maxAgents: 8
      });

      // Step 2: Spawn specialized agents
      const agents = {
        dataPrep: yield mlSwarm.spawn({
          type: 'researcher',
          capabilities: ['data-preprocessing', 'feature-engineering']
        }),
        modelBuilder: yield mlSwarm.spawn({
          type: 'coder',
          capabilities: ['neural-network-design', 'optimization']
        }),
        trainer: yield mlSwarm.spawn({
          type: 'analyst',
          capabilities: ['training', 'hyperparameter-tuning']
        }),
        evaluator: yield mlSwarm.spawn({
          type: 'tester',
          capabilities: ['model-evaluation', 'metrics-analysis']
        })
      };

      // Step 3: Generate synthetic dataset
      console.log('📊 Generating dataset...');
      const dataset = yield agents.dataPrep.execute({
        task: 'generate-dataset',
        config: {
          samples: 1000,
          features: 20,
          targetType: 'classification',
          classes: 5,
          noise: 0.1
        }
      });
      expect(dataset.inputs).toHaveLength(1000);
      expect(dataset.targets).toHaveLength(1000);
      expect(dataset.inputs[0]).toHaveLength(20);

      // Step 4: Build neural network
      console.log('🏗️ Building neural network...');
      const modelConfig = yield agents.modelBuilder.execute({
        task: 'design-network',
        requirements: {
          inputSize: dataset.features,
          outputSize: dataset.classes,
          taskType: 'classification',
          complexity: 'medium'
        }
      });
      const network = yield ruvSwarm.neuralManager.createNetwork(modelConfig);
      expect(network.id).toBeDefined();

      // Step 5: Train the model
      console.log('🎯 Training model...');
      const trainingResult = yield agents.trainer.execute({
        task: 'train-model',
        networkId: network.id,
        dataset: dataset,
        config: {
          epochs: 50,
          batchSize: 32,
          learningRate: 0.001,
          validationSplit: 0.2,
          earlyStoppingPatience: 5
        }
      });
      expect(trainingResult.finalLoss).toBeLessThan(trainingResult.initialLoss);
      expect(trainingResult.validationAccuracy).toBeGreaterThan(0.7);

      // Step 6: Evaluate model
      console.log('📈 Evaluating model...');
      const evaluation = yield agents.evaluator.execute({
        task: 'evaluate-model',
        networkId: network.id,
        testData: dataset.test,
        metrics: ['accuracy', 'precision', 'recall', 'f1-score', 'confusion-matrix']
      });
      expect(evaluation.accuracy).toBeGreaterThan(0.75);
      expect(evaluation.confusionMatrix).toHaveLength(5);

      // Step 7: Make predictions
      console.log('🔮 Making predictions...');
      const testSamples = Array(10).fill(null).map(() => new Float32Array(20).map(() => Math.random()));
      const predictions = yield network.predict(testSamples);
      expect(predictions).toHaveLength(10);
      expect(predictions[0]).toHaveLength(5);

      // Step 8: Save model
      const modelPath = path.join(testDir, 'ml-model.ruv');
      yield network.save(modelPath);
      const stats = yield fs.stat(modelPath);
      expect(stats.size).toBeGreaterThan(0);
      console.log('✅ ML Pipeline completed successfully!');
    }));
  });
  describe('Time Series Forecasting Workflow', () => {
    it('should forecast time series data using specialized models', /*#__PURE__*/_asyncToGenerator(function* () {
      console.log('\n📈 Starting Time Series Forecasting Workflow...');

      // Step 1: Create forecasting swarm
      const forecastSwarm = yield ruvSwarm.createSwarm({
        name: 'forecast-swarm',
        topology: 'mesh',
        maxAgents: 6
      });

      // Step 2: Generate time series data
      const timeSeriesData = [];
      const periods = 500;
      for (let i = 0; i < periods; i++) {
        timeSeriesData.push({
          timestamp: new Date(Date.now() - (periods - i) * 3600000),
          value: 100 + 50 * Math.sin(i * 0.1) + 20 * Math.random(),
          features: {
            dayOfWeek: i % 7,
            hour: i % 24,
            trend: i / periods
          }
        });
      }

      // Step 3: Create forecasting pipeline
      const pipeline = yield mcpTools.tools.orchestrateForecasting({
        swarmId: forecastSwarm.id,
        data: timeSeriesData,
        config: {
          models: ['lstm', 'transformer', 'nbeats'],
          horizon: 24,
          validationSplit: 0.2,
          ensembleMethod: 'weighted-average'
        }
      });

      // Step 4: Train models
      console.log('🧠 Training forecasting models...');
      const trainingResults = yield pipeline.train({
        epochs: 30,
        patience: 5,
        onProgress: (model, epoch, metrics) => {
          console.log(`  ${model}: Epoch ${epoch}, Loss: ${metrics.loss.toFixed(4)}`);
        }
      });
      expect(trainingResults.lstm.finalMetrics.mae).toBeLessThan(10);
      expect(trainingResults.transformer.finalMetrics.mae).toBeLessThan(10);
      expect(trainingResults.nbeats.finalMetrics.mae).toBeLessThan(10);

      // Step 5: Generate forecasts
      console.log('🔮 Generating forecasts...');
      const forecasts = yield pipeline.forecast({
        steps: 24,
        returnConfidenceIntervals: true,
        confidenceLevel: 0.95
      });
      expect(forecasts.predictions).toHaveLength(24);
      expect(forecasts.lowerBound).toHaveLength(24);
      expect(forecasts.upperBound).toHaveLength(24);

      // Step 6: Evaluate forecast accuracy
      const evaluation = yield pipeline.evaluate({
        actualValues: timeSeriesData.slice(-24).map(d => d.value),
        metrics: ['mae', 'rmse', 'mape', 'smape']
      });
      expect(evaluation.mae).toBeLessThan(15);
      expect(evaluation.mape).toBeLessThan(0.15); // Less than 15% error

      console.log('✅ Forecasting workflow completed!');
    }));
  });
  describe('Distributed Task Processing Workflow', () => {
    it('should process complex tasks across multiple agents', /*#__PURE__*/_asyncToGenerator(function* () {
      console.log('\n🚀 Starting Distributed Task Processing...');

      // Step 1: Create processing swarm
      const processingSwarm = yield ruvSwarm.createSwarm({
        name: 'distributed-processing',
        topology: 'star',
        maxAgents: 10
      });

      // Step 2: Define complex task
      const complexTask = {
        id: 'data-analysis-pipeline',
        stages: [{
          name: 'data-collection',
          subtasks: Array(50).fill(null).map((_, i) => ({
            id: `collect-${i}`,
            type: 'fetch',
            source: `dataset-${i}`,
            size: Math.floor(Math.random() * 1000000)
          }))
        }, {
          name: 'data-processing',
          subtasks: Array(50).fill(null).map((_, i) => ({
            id: `process-${i}`,
            type: 'transform',
            operations: ['normalize', 'feature-extract', 'aggregate'],
            dependsOn: [`collect-${i}`]
          }))
        }, {
          name: 'analysis',
          subtasks: Array(10).fill(null).map((_, i) => ({
            id: `analyze-${i}`,
            type: 'analyze',
            algorithms: ['statistical', 'ml-based'],
            dependsOn: Array(5).fill(null).map((_, j) => `process-${i * 5 + j}`)
          }))
        }, {
          name: 'reporting',
          subtasks: [{
            id: 'final-report',
            type: 'aggregate',
            dependsOn: Array(10).fill(null).map((_, i) => `analyze-${i}`)
          }]
        }]
      };

      // Step 3: Spawn agents dynamically based on workload
      console.log('🤖 Spawning agents...');
      const agentPool = [];
      for (let i = 0; i < 8; i++) {
        const agent = yield processingSwarm.spawn({
          type: ['researcher', 'analyst', 'coder'][i % 3],
          capabilities: ['data-processing', 'parallel-execution']
        });
        agentPool.push(agent);
      }

      // Step 4: Execute distributed processing
      console.log('⚡ Processing tasks...');
      const startTime = performance.now();
      const orchestrationResult = yield processingSwarm.orchestrate({
        task: complexTask,
        strategy: 'parallel',
        monitoring: {
          interval: 100,
          onProgress: progress => {
            console.log(`  Progress: ${progress.completed}/${progress.total} tasks (${progress.percentage.toFixed(1)}%)`);
          }
        }
      });
      const duration = performance.now() - startTime;
      expect(orchestrationResult.completed).toBe(true);
      expect(orchestrationResult.tasksCompleted).toBe(111); // Total subtasks
      expect(orchestrationResult.duration).toBeLessThan(duration);

      // Step 5: Verify parallel execution efficiency
      const efficiency = orchestrationResult.parallelEfficiency;
      expect(efficiency).toBeGreaterThan(0.7); // At least 70% parallel efficiency

      // Step 6: Check agent utilization
      const utilization = yield processingSwarm.getAgentUtilization();
      const avgUtilization = utilization.reduce((sum, u) => sum + u.utilization, 0) / utilization.length;
      expect(avgUtilization).toBeGreaterThan(0.6); // At least 60% average utilization

      console.log(`✅ Distributed processing completed in ${(duration / 1000).toFixed(2)}s`);
    }));
  });
  describe('Real-time Collaboration Workflow', () => {
    it('should handle real-time collaborative editing scenario', /*#__PURE__*/_asyncToGenerator(function* () {
      console.log('\n👥 Starting Real-time Collaboration Workflow...');

      // Step 1: Create collaboration swarm
      const collabSwarm = yield ruvSwarm.createSwarm({
        name: 'collab-swarm',
        topology: 'mesh',
        maxAgents: 5,
        enableRealtime: true
      });

      // Step 2: Create shared document
      const document = {
        id: 'shared-doc-001',
        content: 'Initial document content\n',
        version: 0,
        operations: []
      };

      // Step 3: Spawn collaborative agents
      const editors = yield Promise.all([collabSwarm.spawn({
        type: 'coder',
        role: 'editor-1'
      }), collabSwarm.spawn({
        type: 'coder',
        role: 'editor-2'
      }), collabSwarm.spawn({
        type: 'researcher',
        role: 'reviewer'
      })]);

      // Step 4: Simulate concurrent edits
      console.log('📝 Simulating concurrent edits...');
      const edits = [];
      const editPromises = [];

      // Editor 1 adds content
      editPromises.push(editors[0].execute({
        task: 'edit-document',
        operation: {
          type: 'insert',
          position: document.content.length,
          text: 'Section 1: Introduction\n'
        },
        documentId: document.id
      }));

      // Editor 2 adds content concurrently
      editPromises.push(editors[1].execute({
        task: 'edit-document',
        operation: {
          type: 'insert',
          position: document.content.length,
          text: 'Section 2: Methods\n'
        },
        documentId: document.id
      }));

      // Reviewer adds comments
      editPromises.push(editors[2].execute({
        task: 'add-comment',
        comment: {
          position: 0,
          text: 'Needs more detail in introduction'
        },
        documentId: document.id
      }));
      const results = yield Promise.all(editPromises);

      // Step 5: Verify conflict resolution
      expect(results.every(r => r.success)).toBe(true);
      expect(results.some(r => r.conflictResolved)).toBe(true);

      // Step 6: Check final document state
      const finalDoc = yield collabSwarm.getSharedState(document.id);
      expect(finalDoc.content).toContain('Introduction');
      expect(finalDoc.content).toContain('Methods');
      expect(finalDoc.comments).toHaveLength(1);
      expect(finalDoc.version).toBeGreaterThan(0);
      console.log('✅ Collaboration workflow completed!');
    }));
  });
  describe('Adaptive Learning Workflow', () => {
    it('should adapt agent behavior based on performance', /*#__PURE__*/_asyncToGenerator(function* () {
      console.log('\n🧬 Starting Adaptive Learning Workflow...');

      // Step 1: Create adaptive swarm
      const adaptiveSwarm = yield ruvSwarm.createSwarm({
        name: 'adaptive-swarm',
        topology: 'hierarchical',
        maxAgents: 6,
        enableAdaptiveLearning: true
      });

      // Step 2: Define performance metrics
      const performanceTracker = {
        agents: new Map(),
        taskTypes: ['optimization', 'search', 'analysis', 'synthesis']
      };

      // Step 3: Run initial tasks and measure performance
      console.log('📊 Running baseline tasks...');
      const baselineResults = [];
      for (const taskType of performanceTracker.taskTypes) {
        const agent = yield adaptiveSwarm.spawn({
          type: 'analyst',
          learningEnabled: true
        });
        const result = yield agent.execute({
          task: taskType,
          complexity: 'medium',
          measurePerformance: true
        });
        baselineResults.push({
          agentId: agent.id,
          taskType,
          performance: result.performance
        });
        performanceTracker.agents.set(agent.id, {
          agent,
          taskType,
          performances: [result.performance]
        });
      }

      // Step 4: Train agents through repeated tasks
      console.log('🎯 Training agents...');
      const trainingRounds = 10;
      for (let round = 0; round < trainingRounds; round++) {
        for (const [agentId, data] of performanceTracker.agents) {
          const result = yield data.agent.execute({
            task: data.taskType,
            complexity: 'medium',
            learningEnabled: true,
            feedback: {
              previousPerformance: data.performances[data.performances.length - 1],
              targetImprovement: 0.05
            }
          });
          data.performances.push(result.performance);
        }
      }

      // Step 5: Verify performance improvement
      console.log('📈 Analyzing improvements...');
      for (const [agentId, data] of performanceTracker.agents) {
        const initialPerf = data.performances[0];
        const finalPerf = data.performances[data.performances.length - 1];
        const improvement = (finalPerf.score - initialPerf.score) / initialPerf.score;
        expect(improvement).toBeGreaterThan(0.1); // At least 10% improvement
        console.log(`  Agent ${agentId}: ${(improvement * 100).toFixed(1)}% improvement`);
      }

      // Step 6: Test generalization
      console.log('🔄 Testing generalization...');
      const newTaskResults = [];
      for (const [agentId, data] of performanceTracker.agents) {
        // Test on a different task type
        const newTaskType = performanceTracker.taskTypes.find(t => t !== data.taskType);
        const result = yield data.agent.execute({
          task: newTaskType,
          complexity: 'medium'
        });
        newTaskResults.push({
          agentId,
          trainedOn: data.taskType,
          testedOn: newTaskType,
          performance: result.performance.score
        });
      }

      // Verify some knowledge transfer
      const avgNewTaskPerf = newTaskResults.reduce((sum, r) => sum + r.performance, 0) / newTaskResults.length;
      expect(avgNewTaskPerf).toBeGreaterThan(0.6); // Reasonable performance on new tasks

      console.log('✅ Adaptive learning workflow completed!');
    }));
  });
  describe('Fault Tolerance Workflow', () => {
    it('should handle agent failures and recover gracefully', /*#__PURE__*/_asyncToGenerator(function* () {
      console.log('\n🛡️ Starting Fault Tolerance Workflow...');

      // Step 1: Create resilient swarm
      const resilientSwarm = yield ruvSwarm.createSwarm({
        name: 'resilient-swarm',
        topology: 'mesh',
        maxAgents: 8,
        faultTolerance: {
          enabled: true,
          redundancy: 2,
          checkpointInterval: 1000
        }
      });

      // Step 2: Create critical task with checkpoints
      const criticalTask = {
        id: 'critical-computation',
        steps: Array(20).fill(null).map((_, i) => ({
          id: `step-${i}`,
          computation: 'heavy',
          checkpointable: true
        }))
      };

      // Step 3: Start task execution
      console.log('⚡ Starting critical task...');
      const agents = yield Promise.all(Array(4).fill(null).map(() => resilientSwarm.spawn({
        type: 'analyst'
      })));
      let completedSteps = 0;
      const taskPromise = resilientSwarm.orchestrate({
        task: criticalTask,
        onStepComplete: stepId => {
          completedSteps++;
          console.log(`  Step ${stepId} completed (${completedSteps}/20)`);
        }
      });

      // Step 4: Simulate agent failures
      setTimeout(/*#__PURE__*/_asyncToGenerator(function* () {
        console.log('💥 Simulating agent failure...');
        yield agents[0].simulateFailure();
      }), 2000);
      setTimeout(/*#__PURE__*/_asyncToGenerator(function* () {
        console.log('💥 Simulating another agent failure...');
        yield agents[1].simulateFailure();
      }), 4000);

      // Step 5: Wait for task completion
      const result = yield taskPromise;

      // Step 6: Verify task completed despite failures
      expect(result.completed).toBe(true);
      expect(result.stepsCompleted).toBe(20);
      expect(result.agentFailures).toBe(2);
      expect(result.recoveries).toBe(2);

      // Step 7: Check checkpoint usage
      const checkpointStats = yield resilientSwarm.getCheckpointStats();
      expect(checkpointStats.checkpointsSaved).toBeGreaterThan(0);
      expect(checkpointStats.checkpointsRestored).toBeGreaterThan(0);
      console.log('✅ Fault tolerance workflow completed successfully!');
    }));
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkZXNjcmliZSIsIml0IiwiZXhwZWN0IiwiYmVmb3JlQWxsIiwiYWZ0ZXJBbGwiLCJSdXZTd2FybSIsIkVuaGFuY2VkTUNQVG9vbHMiLCJmcyIsInBhdGgiLCJydXZTd2FybSIsIm1jcFRvb2xzIiwidGVzdERpciIsIl9hc3luY1RvR2VuZXJhdG9yIiwiam9pbiIsInByb2Nlc3MiLCJjd2QiLCJEYXRlIiwibm93IiwibWtkaXIiLCJyZWN1cnNpdmUiLCJpbml0aWFsaXplIiwibG9hZGluZ1N0cmF0ZWd5IiwiZW5hYmxlUGVyc2lzdGVuY2UiLCJlbmFibGVOZXVyYWxOZXR3b3JrcyIsImVuYWJsZUZvcmVjYXN0aW5nIiwidXNlU0lNRCIsInBlcnNpc3RlbmNlUGF0aCIsImNsZWFudXAiLCJybSIsImZvcmNlIiwiY29uc29sZSIsImxvZyIsIm1sU3dhcm0iLCJjcmVhdGVTd2FybSIsIm5hbWUiLCJ0b3BvbG9neSIsIm1heEFnZW50cyIsImFnZW50cyIsImRhdGFQcmVwIiwic3Bhd24iLCJ0eXBlIiwiY2FwYWJpbGl0aWVzIiwibW9kZWxCdWlsZGVyIiwidHJhaW5lciIsImV2YWx1YXRvciIsImRhdGFzZXQiLCJleGVjdXRlIiwidGFzayIsImNvbmZpZyIsInNhbXBsZXMiLCJmZWF0dXJlcyIsInRhcmdldFR5cGUiLCJjbGFzc2VzIiwibm9pc2UiLCJpbnB1dHMiLCJ0b0hhdmVMZW5ndGgiLCJ0YXJnZXRzIiwibW9kZWxDb25maWciLCJyZXF1aXJlbWVudHMiLCJpbnB1dFNpemUiLCJvdXRwdXRTaXplIiwidGFza1R5cGUiLCJjb21wbGV4aXR5IiwibmV0d29yayIsIm5ldXJhbE1hbmFnZXIiLCJjcmVhdGVOZXR3b3JrIiwiaWQiLCJ0b0JlRGVmaW5lZCIsInRyYWluaW5nUmVzdWx0IiwibmV0d29ya0lkIiwiZXBvY2hzIiwiYmF0Y2hTaXplIiwibGVhcm5pbmdSYXRlIiwidmFsaWRhdGlvblNwbGl0IiwiZWFybHlTdG9wcGluZ1BhdGllbmNlIiwiZmluYWxMb3NzIiwidG9CZUxlc3NUaGFuIiwiaW5pdGlhbExvc3MiLCJ2YWxpZGF0aW9uQWNjdXJhY3kiLCJ0b0JlR3JlYXRlclRoYW4iLCJldmFsdWF0aW9uIiwidGVzdERhdGEiLCJ0ZXN0IiwibWV0cmljcyIsImFjY3VyYWN5IiwiY29uZnVzaW9uTWF0cml4IiwidGVzdFNhbXBsZXMiLCJBcnJheSIsImZpbGwiLCJtYXAiLCJGbG9hdDMyQXJyYXkiLCJNYXRoIiwicmFuZG9tIiwicHJlZGljdGlvbnMiLCJwcmVkaWN0IiwibW9kZWxQYXRoIiwic2F2ZSIsInN0YXRzIiwic3RhdCIsInNpemUiLCJmb3JlY2FzdFN3YXJtIiwidGltZVNlcmllc0RhdGEiLCJwZXJpb2RzIiwiaSIsInB1c2giLCJ0aW1lc3RhbXAiLCJ2YWx1ZSIsInNpbiIsImRheU9mV2VlayIsImhvdXIiLCJ0cmVuZCIsInBpcGVsaW5lIiwidG9vbHMiLCJvcmNoZXN0cmF0ZUZvcmVjYXN0aW5nIiwic3dhcm1JZCIsImRhdGEiLCJtb2RlbHMiLCJob3Jpem9uIiwiZW5zZW1ibGVNZXRob2QiLCJ0cmFpbmluZ1Jlc3VsdHMiLCJ0cmFpbiIsInBhdGllbmNlIiwib25Qcm9ncmVzcyIsIm1vZGVsIiwiZXBvY2giLCJsb3NzIiwidG9GaXhlZCIsImxzdG0iLCJmaW5hbE1ldHJpY3MiLCJtYWUiLCJ0cmFuc2Zvcm1lciIsIm5iZWF0cyIsImZvcmVjYXN0cyIsImZvcmVjYXN0Iiwic3RlcHMiLCJyZXR1cm5Db25maWRlbmNlSW50ZXJ2YWxzIiwiY29uZmlkZW5jZUxldmVsIiwibG93ZXJCb3VuZCIsInVwcGVyQm91bmQiLCJldmFsdWF0ZSIsImFjdHVhbFZhbHVlcyIsInNsaWNlIiwiZCIsIm1hcGUiLCJwcm9jZXNzaW5nU3dhcm0iLCJjb21wbGV4VGFzayIsInN0YWdlcyIsInN1YnRhc2tzIiwiXyIsInNvdXJjZSIsImZsb29yIiwib3BlcmF0aW9ucyIsImRlcGVuZHNPbiIsImFsZ29yaXRobXMiLCJqIiwiYWdlbnRQb29sIiwiYWdlbnQiLCJzdGFydFRpbWUiLCJwZXJmb3JtYW5jZSIsIm9yY2hlc3RyYXRpb25SZXN1bHQiLCJvcmNoZXN0cmF0ZSIsInN0cmF0ZWd5IiwibW9uaXRvcmluZyIsImludGVydmFsIiwicHJvZ3Jlc3MiLCJjb21wbGV0ZWQiLCJ0b3RhbCIsInBlcmNlbnRhZ2UiLCJkdXJhdGlvbiIsInRvQmUiLCJ0YXNrc0NvbXBsZXRlZCIsImVmZmljaWVuY3kiLCJwYXJhbGxlbEVmZmljaWVuY3kiLCJ1dGlsaXphdGlvbiIsImdldEFnZW50VXRpbGl6YXRpb24iLCJhdmdVdGlsaXphdGlvbiIsInJlZHVjZSIsInN1bSIsInUiLCJsZW5ndGgiLCJjb2xsYWJTd2FybSIsImVuYWJsZVJlYWx0aW1lIiwiZG9jdW1lbnQiLCJjb250ZW50IiwidmVyc2lvbiIsImVkaXRvcnMiLCJQcm9taXNlIiwiYWxsIiwicm9sZSIsImVkaXRzIiwiZWRpdFByb21pc2VzIiwib3BlcmF0aW9uIiwicG9zaXRpb24iLCJ0ZXh0IiwiZG9jdW1lbnRJZCIsImNvbW1lbnQiLCJyZXN1bHRzIiwiZXZlcnkiLCJyIiwic3VjY2VzcyIsInNvbWUiLCJjb25mbGljdFJlc29sdmVkIiwiZmluYWxEb2MiLCJnZXRTaGFyZWRTdGF0ZSIsInRvQ29udGFpbiIsImNvbW1lbnRzIiwiYWRhcHRpdmVTd2FybSIsImVuYWJsZUFkYXB0aXZlTGVhcm5pbmciLCJwZXJmb3JtYW5jZVRyYWNrZXIiLCJNYXAiLCJ0YXNrVHlwZXMiLCJiYXNlbGluZVJlc3VsdHMiLCJsZWFybmluZ0VuYWJsZWQiLCJyZXN1bHQiLCJtZWFzdXJlUGVyZm9ybWFuY2UiLCJhZ2VudElkIiwic2V0IiwicGVyZm9ybWFuY2VzIiwidHJhaW5pbmdSb3VuZHMiLCJyb3VuZCIsImZlZWRiYWNrIiwicHJldmlvdXNQZXJmb3JtYW5jZSIsInRhcmdldEltcHJvdmVtZW50IiwiaW5pdGlhbFBlcmYiLCJmaW5hbFBlcmYiLCJpbXByb3ZlbWVudCIsInNjb3JlIiwibmV3VGFza1Jlc3VsdHMiLCJuZXdUYXNrVHlwZSIsImZpbmQiLCJ0IiwidHJhaW5lZE9uIiwidGVzdGVkT24iLCJhdmdOZXdUYXNrUGVyZiIsInJlc2lsaWVudFN3YXJtIiwiZmF1bHRUb2xlcmFuY2UiLCJlbmFibGVkIiwicmVkdW5kYW5jeSIsImNoZWNrcG9pbnRJbnRlcnZhbCIsImNyaXRpY2FsVGFzayIsImNvbXB1dGF0aW9uIiwiY2hlY2twb2ludGFibGUiLCJjb21wbGV0ZWRTdGVwcyIsInRhc2tQcm9taXNlIiwib25TdGVwQ29tcGxldGUiLCJzdGVwSWQiLCJzZXRUaW1lb3V0Iiwic2ltdWxhdGVGYWlsdXJlIiwic3RlcHNDb21wbGV0ZWQiLCJhZ2VudEZhaWx1cmVzIiwicmVjb3ZlcmllcyIsImNoZWNrcG9pbnRTdGF0cyIsImdldENoZWNrcG9pbnRTdGF0cyIsImNoZWNrcG9pbnRzU2F2ZWQiLCJjaGVja3BvaW50c1Jlc3RvcmVkIl0sInNvdXJjZXMiOlsid29ya2Zsb3ctc2NlbmFyaW9zLnRlc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFbmQtdG8tRW5kIFdvcmtmbG93IFRlc3RzXG4gKiBUZXN0cyBjb21wbGV0ZSB1c2VyIHNjZW5hcmlvcyBmcm9tIGluaXRpYWxpemF0aW9uIHRvIHJlc3VsdHNcbiAqL1xuXG5pbXBvcnQgeyBkZXNjcmliZSwgaXQsIGV4cGVjdCwgYmVmb3JlQWxsLCBhZnRlckFsbCB9IGZyb20gJ3ZpdGVzdCc7XG5pbXBvcnQgeyBSdXZTd2FybSB9IGZyb20gJy4uLy4uL3NyYy9pbmRleC1lbmhhbmNlZC5qcyc7XG5pbXBvcnQgeyBFbmhhbmNlZE1DUFRvb2xzIH0gZnJvbSAnLi4vLi4vc3JjL21jcC10b29scy1lbmhhbmNlZC5qcyc7XG5pbXBvcnQgZnMgZnJvbSAnZnMvcHJvbWlzZXMnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5cbmRlc2NyaWJlKCdFMkUgV29ya2Zsb3cgU2NlbmFyaW9zJywgKCkgPT4ge1xuICBsZXQgcnV2U3dhcm07XG4gIGxldCBtY3BUb29scztcbiAgbGV0IHRlc3REaXI7XG5cbiAgYmVmb3JlQWxsKGFzeW5jICgpID0+IHtcbiAgICAvLyBDcmVhdGUgdGVzdCBkaXJlY3RvcnkgZm9yIG91dHB1dHNcbiAgICB0ZXN0RGlyID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICd0ZXN0LW91dHB1dHMnLCBgZTJlLSR7RGF0ZS5ub3coKX1gKTtcbiAgICBhd2FpdCBmcy5ta2Rpcih0ZXN0RGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcblxuICAgIC8vIEluaXRpYWxpemUgc3lzdGVtXG4gICAgcnV2U3dhcm0gPSBhd2FpdCBSdXZTd2FybS5pbml0aWFsaXplKHtcbiAgICAgIGxvYWRpbmdTdHJhdGVneTogJ2Z1bGwnLFxuICAgICAgZW5hYmxlUGVyc2lzdGVuY2U6IHRydWUsXG4gICAgICBlbmFibGVOZXVyYWxOZXR3b3JrczogdHJ1ZSxcbiAgICAgIGVuYWJsZUZvcmVjYXN0aW5nOiB0cnVlLFxuICAgICAgdXNlU0lNRDogdHJ1ZSxcbiAgICAgIHBlcnNpc3RlbmNlUGF0aDogcGF0aC5qb2luKHRlc3REaXIsICdwZXJzaXN0ZW5jZS5kYicpXG4gICAgfSk7XG5cbiAgICBtY3BUb29scyA9IG5ldyBFbmhhbmNlZE1DUFRvb2xzKCk7XG4gICAgYXdhaXQgbWNwVG9vbHMuaW5pdGlhbGl6ZSgpO1xuICB9KTtcblxuICBhZnRlckFsbChhc3luYyAoKSA9PiB7XG4gICAgaWYgKHJ1dlN3YXJtKSB7XG4gICAgICBhd2FpdCBydXZTd2FybS5jbGVhbnVwKCk7XG4gICAgfVxuICAgIC8vIENsZWFuIHVwIHRlc3QgZGlyZWN0b3J5XG4gICAgYXdhaXQgZnMucm0odGVzdERpciwgeyByZWN1cnNpdmU6IHRydWUsIGZvcmNlOiB0cnVlIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnTWFjaGluZSBMZWFybmluZyBQaXBlbGluZSBXb3JrZmxvdycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNvbXBsZXRlIGZ1bGwgTUwgcGlwZWxpbmUgZnJvbSBkYXRhIHRvIHByZWRpY3Rpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ1xcbvCflKwgU3RhcnRpbmcgTUwgUGlwZWxpbmUgV29ya2Zsb3cuLi4nKTtcblxuICAgICAgLy8gU3RlcCAxOiBDcmVhdGUgc3dhcm0gZm9yIE1MIHRhc2tzXG4gICAgICBjb25zdCBtbFN3YXJtID0gYXdhaXQgcnV2U3dhcm0uY3JlYXRlU3dhcm0oe1xuICAgICAgICBuYW1lOiAnbWwtcGlwZWxpbmUtc3dhcm0nLFxuICAgICAgICB0b3BvbG9neTogJ2hpZXJhcmNoaWNhbCcsXG4gICAgICAgIG1heEFnZW50czogOFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFN0ZXAgMjogU3Bhd24gc3BlY2lhbGl6ZWQgYWdlbnRzXG4gICAgICBjb25zdCBhZ2VudHMgPSB7XG4gICAgICAgIGRhdGFQcmVwOiBhd2FpdCBtbFN3YXJtLnNwYXduKHsgXG4gICAgICAgICAgdHlwZTogJ3Jlc2VhcmNoZXInLCBcbiAgICAgICAgICBjYXBhYmlsaXRpZXM6IFsnZGF0YS1wcmVwcm9jZXNzaW5nJywgJ2ZlYXR1cmUtZW5naW5lZXJpbmcnXSBcbiAgICAgICAgfSksXG4gICAgICAgIG1vZGVsQnVpbGRlcjogYXdhaXQgbWxTd2FybS5zcGF3bih7IFxuICAgICAgICAgIHR5cGU6ICdjb2RlcicsIFxuICAgICAgICAgIGNhcGFiaWxpdGllczogWyduZXVyYWwtbmV0d29yay1kZXNpZ24nLCAnb3B0aW1pemF0aW9uJ10gXG4gICAgICAgIH0pLFxuICAgICAgICB0cmFpbmVyOiBhd2FpdCBtbFN3YXJtLnNwYXduKHsgXG4gICAgICAgICAgdHlwZTogJ2FuYWx5c3QnLCBcbiAgICAgICAgICBjYXBhYmlsaXRpZXM6IFsndHJhaW5pbmcnLCAnaHlwZXJwYXJhbWV0ZXItdHVuaW5nJ10gXG4gICAgICAgIH0pLFxuICAgICAgICBldmFsdWF0b3I6IGF3YWl0IG1sU3dhcm0uc3Bhd24oeyBcbiAgICAgICAgICB0eXBlOiAndGVzdGVyJywgXG4gICAgICAgICAgY2FwYWJpbGl0aWVzOiBbJ21vZGVsLWV2YWx1YXRpb24nLCAnbWV0cmljcy1hbmFseXNpcyddIFxuICAgICAgICB9KVxuICAgICAgfTtcblxuICAgICAgLy8gU3RlcCAzOiBHZW5lcmF0ZSBzeW50aGV0aWMgZGF0YXNldFxuICAgICAgY29uc29sZS5sb2coJ/Cfk4ogR2VuZXJhdGluZyBkYXRhc2V0Li4uJyk7XG4gICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgYWdlbnRzLmRhdGFQcmVwLmV4ZWN1dGUoe1xuICAgICAgICB0YXNrOiAnZ2VuZXJhdGUtZGF0YXNldCcsXG4gICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgIHNhbXBsZXM6IDEwMDAsXG4gICAgICAgICAgZmVhdHVyZXM6IDIwLFxuICAgICAgICAgIHRhcmdldFR5cGU6ICdjbGFzc2lmaWNhdGlvbicsXG4gICAgICAgICAgY2xhc3NlczogNSxcbiAgICAgICAgICBub2lzZTogMC4xXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoZGF0YXNldC5pbnB1dHMpLnRvSGF2ZUxlbmd0aCgxMDAwKTtcbiAgICAgIGV4cGVjdChkYXRhc2V0LnRhcmdldHMpLnRvSGF2ZUxlbmd0aCgxMDAwKTtcbiAgICAgIGV4cGVjdChkYXRhc2V0LmlucHV0c1swXSkudG9IYXZlTGVuZ3RoKDIwKTtcblxuICAgICAgLy8gU3RlcCA0OiBCdWlsZCBuZXVyYWwgbmV0d29ya1xuICAgICAgY29uc29sZS5sb2coJ/Cfj5fvuI8gQnVpbGRpbmcgbmV1cmFsIG5ldHdvcmsuLi4nKTtcbiAgICAgIGNvbnN0IG1vZGVsQ29uZmlnID0gYXdhaXQgYWdlbnRzLm1vZGVsQnVpbGRlci5leGVjdXRlKHtcbiAgICAgICAgdGFzazogJ2Rlc2lnbi1uZXR3b3JrJyxcbiAgICAgICAgcmVxdWlyZW1lbnRzOiB7XG4gICAgICAgICAgaW5wdXRTaXplOiBkYXRhc2V0LmZlYXR1cmVzLFxuICAgICAgICAgIG91dHB1dFNpemU6IGRhdGFzZXQuY2xhc3NlcyxcbiAgICAgICAgICB0YXNrVHlwZTogJ2NsYXNzaWZpY2F0aW9uJyxcbiAgICAgICAgICBjb21wbGV4aXR5OiAnbWVkaXVtJ1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IHJ1dlN3YXJtLm5ldXJhbE1hbmFnZXIuY3JlYXRlTmV0d29yayhtb2RlbENvbmZpZyk7XG4gICAgICBleHBlY3QobmV0d29yay5pZCkudG9CZURlZmluZWQoKTtcblxuICAgICAgLy8gU3RlcCA1OiBUcmFpbiB0aGUgbW9kZWxcbiAgICAgIGNvbnNvbGUubG9nKCfwn46vIFRyYWluaW5nIG1vZGVsLi4uJyk7XG4gICAgICBjb25zdCB0cmFpbmluZ1Jlc3VsdCA9IGF3YWl0IGFnZW50cy50cmFpbmVyLmV4ZWN1dGUoe1xuICAgICAgICB0YXNrOiAndHJhaW4tbW9kZWwnLFxuICAgICAgICBuZXR3b3JrSWQ6IG5ldHdvcmsuaWQsXG4gICAgICAgIGRhdGFzZXQ6IGRhdGFzZXQsXG4gICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgIGVwb2NoczogNTAsXG4gICAgICAgICAgYmF0Y2hTaXplOiAzMixcbiAgICAgICAgICBsZWFybmluZ1JhdGU6IDAuMDAxLFxuICAgICAgICAgIHZhbGlkYXRpb25TcGxpdDogMC4yLFxuICAgICAgICAgIGVhcmx5U3RvcHBpbmdQYXRpZW5jZTogNVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHRyYWluaW5nUmVzdWx0LmZpbmFsTG9zcykudG9CZUxlc3NUaGFuKHRyYWluaW5nUmVzdWx0LmluaXRpYWxMb3NzKTtcbiAgICAgIGV4cGVjdCh0cmFpbmluZ1Jlc3VsdC52YWxpZGF0aW9uQWNjdXJhY3kpLnRvQmVHcmVhdGVyVGhhbigwLjcpO1xuXG4gICAgICAvLyBTdGVwIDY6IEV2YWx1YXRlIG1vZGVsXG4gICAgICBjb25zb2xlLmxvZygn8J+TiCBFdmFsdWF0aW5nIG1vZGVsLi4uJyk7XG4gICAgICBjb25zdCBldmFsdWF0aW9uID0gYXdhaXQgYWdlbnRzLmV2YWx1YXRvci5leGVjdXRlKHtcbiAgICAgICAgdGFzazogJ2V2YWx1YXRlLW1vZGVsJyxcbiAgICAgICAgbmV0d29ya0lkOiBuZXR3b3JrLmlkLFxuICAgICAgICB0ZXN0RGF0YTogZGF0YXNldC50ZXN0LFxuICAgICAgICBtZXRyaWNzOiBbJ2FjY3VyYWN5JywgJ3ByZWNpc2lvbicsICdyZWNhbGwnLCAnZjEtc2NvcmUnLCAnY29uZnVzaW9uLW1hdHJpeCddXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KGV2YWx1YXRpb24uYWNjdXJhY3kpLnRvQmVHcmVhdGVyVGhhbigwLjc1KTtcbiAgICAgIGV4cGVjdChldmFsdWF0aW9uLmNvbmZ1c2lvbk1hdHJpeCkudG9IYXZlTGVuZ3RoKDUpO1xuXG4gICAgICAvLyBTdGVwIDc6IE1ha2UgcHJlZGljdGlvbnNcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SuIE1ha2luZyBwcmVkaWN0aW9ucy4uLicpO1xuICAgICAgY29uc3QgdGVzdFNhbXBsZXMgPSBBcnJheSgxMCkuZmlsbChudWxsKS5tYXAoKCkgPT4gXG4gICAgICAgIG5ldyBGbG9hdDMyQXJyYXkoMjApLm1hcCgoKSA9PiBNYXRoLnJhbmRvbSgpKVxuICAgICAgKTtcblxuICAgICAgY29uc3QgcHJlZGljdGlvbnMgPSBhd2FpdCBuZXR3b3JrLnByZWRpY3QodGVzdFNhbXBsZXMpO1xuICAgICAgZXhwZWN0KHByZWRpY3Rpb25zKS50b0hhdmVMZW5ndGgoMTApO1xuICAgICAgZXhwZWN0KHByZWRpY3Rpb25zWzBdKS50b0hhdmVMZW5ndGgoNSk7XG5cbiAgICAgIC8vIFN0ZXAgODogU2F2ZSBtb2RlbFxuICAgICAgY29uc3QgbW9kZWxQYXRoID0gcGF0aC5qb2luKHRlc3REaXIsICdtbC1tb2RlbC5ydXYnKTtcbiAgICAgIGF3YWl0IG5ldHdvcmsuc2F2ZShtb2RlbFBhdGgpO1xuICAgICAgXG4gICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IGZzLnN0YXQobW9kZWxQYXRoKTtcbiAgICAgIGV4cGVjdChzdGF0cy5zaXplKS50b0JlR3JlYXRlclRoYW4oMCk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCfinIUgTUwgUGlwZWxpbmUgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSEnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1RpbWUgU2VyaWVzIEZvcmVjYXN0aW5nIFdvcmtmbG93JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZm9yZWNhc3QgdGltZSBzZXJpZXMgZGF0YSB1c2luZyBzcGVjaWFsaXplZCBtb2RlbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnXFxu8J+TiCBTdGFydGluZyBUaW1lIFNlcmllcyBGb3JlY2FzdGluZyBXb3JrZmxvdy4uLicpO1xuXG4gICAgICAvLyBTdGVwIDE6IENyZWF0ZSBmb3JlY2FzdGluZyBzd2FybVxuICAgICAgY29uc3QgZm9yZWNhc3RTd2FybSA9IGF3YWl0IHJ1dlN3YXJtLmNyZWF0ZVN3YXJtKHtcbiAgICAgICAgbmFtZTogJ2ZvcmVjYXN0LXN3YXJtJyxcbiAgICAgICAgdG9wb2xvZ3k6ICdtZXNoJyxcbiAgICAgICAgbWF4QWdlbnRzOiA2XG4gICAgICB9KTtcblxuICAgICAgLy8gU3RlcCAyOiBHZW5lcmF0ZSB0aW1lIHNlcmllcyBkYXRhXG4gICAgICBjb25zdCB0aW1lU2VyaWVzRGF0YSA9IFtdO1xuICAgICAgY29uc3QgcGVyaW9kcyA9IDUwMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGVyaW9kczsgaSsrKSB7XG4gICAgICAgIHRpbWVTZXJpZXNEYXRhLnB1c2goe1xuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoRGF0ZS5ub3coKSAtIChwZXJpb2RzIC0gaSkgKiAzNjAwMDAwKSxcbiAgICAgICAgICB2YWx1ZTogMTAwICsgNTAgKiBNYXRoLnNpbihpICogMC4xKSArIDIwICogTWF0aC5yYW5kb20oKSxcbiAgICAgICAgICBmZWF0dXJlczoge1xuICAgICAgICAgICAgZGF5T2ZXZWVrOiBpICUgNyxcbiAgICAgICAgICAgIGhvdXI6IGkgJSAyNCxcbiAgICAgICAgICAgIHRyZW5kOiBpIC8gcGVyaW9kc1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0ZXAgMzogQ3JlYXRlIGZvcmVjYXN0aW5nIHBpcGVsaW5lXG4gICAgICBjb25zdCBwaXBlbGluZSA9IGF3YWl0IG1jcFRvb2xzLnRvb2xzLm9yY2hlc3RyYXRlRm9yZWNhc3Rpbmcoe1xuICAgICAgICBzd2FybUlkOiBmb3JlY2FzdFN3YXJtLmlkLFxuICAgICAgICBkYXRhOiB0aW1lU2VyaWVzRGF0YSxcbiAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgbW9kZWxzOiBbJ2xzdG0nLCAndHJhbnNmb3JtZXInLCAnbmJlYXRzJ10sXG4gICAgICAgICAgaG9yaXpvbjogMjQsXG4gICAgICAgICAgdmFsaWRhdGlvblNwbGl0OiAwLjIsXG4gICAgICAgICAgZW5zZW1ibGVNZXRob2Q6ICd3ZWlnaHRlZC1hdmVyYWdlJ1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gU3RlcCA0OiBUcmFpbiBtb2RlbHNcbiAgICAgIGNvbnNvbGUubG9nKCfwn6egIFRyYWluaW5nIGZvcmVjYXN0aW5nIG1vZGVscy4uLicpO1xuICAgICAgY29uc3QgdHJhaW5pbmdSZXN1bHRzID0gYXdhaXQgcGlwZWxpbmUudHJhaW4oe1xuICAgICAgICBlcG9jaHM6IDMwLFxuICAgICAgICBwYXRpZW5jZTogNSxcbiAgICAgICAgb25Qcm9ncmVzczogKG1vZGVsLCBlcG9jaCwgbWV0cmljcykgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGAgICR7bW9kZWx9OiBFcG9jaCAke2Vwb2NofSwgTG9zczogJHttZXRyaWNzLmxvc3MudG9GaXhlZCg0KX1gKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdCh0cmFpbmluZ1Jlc3VsdHMubHN0bS5maW5hbE1ldHJpY3MubWFlKS50b0JlTGVzc1RoYW4oMTApO1xuICAgICAgZXhwZWN0KHRyYWluaW5nUmVzdWx0cy50cmFuc2Zvcm1lci5maW5hbE1ldHJpY3MubWFlKS50b0JlTGVzc1RoYW4oMTApO1xuICAgICAgZXhwZWN0KHRyYWluaW5nUmVzdWx0cy5uYmVhdHMuZmluYWxNZXRyaWNzLm1hZSkudG9CZUxlc3NUaGFuKDEwKTtcblxuICAgICAgLy8gU3RlcCA1OiBHZW5lcmF0ZSBmb3JlY2FzdHNcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SuIEdlbmVyYXRpbmcgZm9yZWNhc3RzLi4uJyk7XG4gICAgICBjb25zdCBmb3JlY2FzdHMgPSBhd2FpdCBwaXBlbGluZS5mb3JlY2FzdCh7XG4gICAgICAgIHN0ZXBzOiAyNCxcbiAgICAgICAgcmV0dXJuQ29uZmlkZW5jZUludGVydmFsczogdHJ1ZSxcbiAgICAgICAgY29uZmlkZW5jZUxldmVsOiAwLjk1XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KGZvcmVjYXN0cy5wcmVkaWN0aW9ucykudG9IYXZlTGVuZ3RoKDI0KTtcbiAgICAgIGV4cGVjdChmb3JlY2FzdHMubG93ZXJCb3VuZCkudG9IYXZlTGVuZ3RoKDI0KTtcbiAgICAgIGV4cGVjdChmb3JlY2FzdHMudXBwZXJCb3VuZCkudG9IYXZlTGVuZ3RoKDI0KTtcblxuICAgICAgLy8gU3RlcCA2OiBFdmFsdWF0ZSBmb3JlY2FzdCBhY2N1cmFjeVxuICAgICAgY29uc3QgZXZhbHVhdGlvbiA9IGF3YWl0IHBpcGVsaW5lLmV2YWx1YXRlKHtcbiAgICAgICAgYWN0dWFsVmFsdWVzOiB0aW1lU2VyaWVzRGF0YS5zbGljZSgtMjQpLm1hcChkID0+IGQudmFsdWUpLFxuICAgICAgICBtZXRyaWNzOiBbJ21hZScsICdybXNlJywgJ21hcGUnLCAnc21hcGUnXVxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChldmFsdWF0aW9uLm1hZSkudG9CZUxlc3NUaGFuKDE1KTtcbiAgICAgIGV4cGVjdChldmFsdWF0aW9uLm1hcGUpLnRvQmVMZXNzVGhhbigwLjE1KTsgLy8gTGVzcyB0aGFuIDE1JSBlcnJvclxuXG4gICAgICBjb25zb2xlLmxvZygn4pyFIEZvcmVjYXN0aW5nIHdvcmtmbG93IGNvbXBsZXRlZCEnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Rpc3RyaWJ1dGVkIFRhc2sgUHJvY2Vzc2luZyBXb3JrZmxvdycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHByb2Nlc3MgY29tcGxleCB0YXNrcyBhY3Jvc3MgbXVsdGlwbGUgYWdlbnRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ1xcbvCfmoAgU3RhcnRpbmcgRGlzdHJpYnV0ZWQgVGFzayBQcm9jZXNzaW5nLi4uJyk7XG5cbiAgICAgIC8vIFN0ZXAgMTogQ3JlYXRlIHByb2Nlc3Npbmcgc3dhcm1cbiAgICAgIGNvbnN0IHByb2Nlc3NpbmdTd2FybSA9IGF3YWl0IHJ1dlN3YXJtLmNyZWF0ZVN3YXJtKHtcbiAgICAgICAgbmFtZTogJ2Rpc3RyaWJ1dGVkLXByb2Nlc3NpbmcnLFxuICAgICAgICB0b3BvbG9neTogJ3N0YXInLFxuICAgICAgICBtYXhBZ2VudHM6IDEwXG4gICAgICB9KTtcblxuICAgICAgLy8gU3RlcCAyOiBEZWZpbmUgY29tcGxleCB0YXNrXG4gICAgICBjb25zdCBjb21wbGV4VGFzayA9IHtcbiAgICAgICAgaWQ6ICdkYXRhLWFuYWx5c2lzLXBpcGVsaW5lJyxcbiAgICAgICAgc3RhZ2VzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ2RhdGEtY29sbGVjdGlvbicsXG4gICAgICAgICAgICBzdWJ0YXNrczogQXJyYXkoNTApLmZpbGwobnVsbCkubWFwKChfLCBpKSA9PiAoe1xuICAgICAgICAgICAgICBpZDogYGNvbGxlY3QtJHtpfWAsXG4gICAgICAgICAgICAgIHR5cGU6ICdmZXRjaCcsXG4gICAgICAgICAgICAgIHNvdXJjZTogYGRhdGFzZXQtJHtpfWAsXG4gICAgICAgICAgICAgIHNpemU6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDApXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdkYXRhLXByb2Nlc3NpbmcnLFxuICAgICAgICAgICAgc3VidGFza3M6IEFycmF5KDUwKS5maWxsKG51bGwpLm1hcCgoXywgaSkgPT4gKHtcbiAgICAgICAgICAgICAgaWQ6IGBwcm9jZXNzLSR7aX1gLFxuICAgICAgICAgICAgICB0eXBlOiAndHJhbnNmb3JtJyxcbiAgICAgICAgICAgICAgb3BlcmF0aW9uczogWydub3JtYWxpemUnLCAnZmVhdHVyZS1leHRyYWN0JywgJ2FnZ3JlZ2F0ZSddLFxuICAgICAgICAgICAgICBkZXBlbmRzT246IFtgY29sbGVjdC0ke2l9YF1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ2FuYWx5c2lzJyxcbiAgICAgICAgICAgIHN1YnRhc2tzOiBBcnJheSgxMCkuZmlsbChudWxsKS5tYXAoKF8sIGkpID0+ICh7XG4gICAgICAgICAgICAgIGlkOiBgYW5hbHl6ZS0ke2l9YCxcbiAgICAgICAgICAgICAgdHlwZTogJ2FuYWx5emUnLFxuICAgICAgICAgICAgICBhbGdvcml0aG1zOiBbJ3N0YXRpc3RpY2FsJywgJ21sLWJhc2VkJ10sXG4gICAgICAgICAgICAgIGRlcGVuZHNPbjogQXJyYXkoNSkuZmlsbChudWxsKS5tYXAoKF8sIGopID0+IGBwcm9jZXNzLSR7aSAqIDUgKyBqfWApXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdyZXBvcnRpbmcnLFxuICAgICAgICAgICAgc3VidGFza3M6IFt7XG4gICAgICAgICAgICAgIGlkOiAnZmluYWwtcmVwb3J0JyxcbiAgICAgICAgICAgICAgdHlwZTogJ2FnZ3JlZ2F0ZScsXG4gICAgICAgICAgICAgIGRlcGVuZHNPbjogQXJyYXkoMTApLmZpbGwobnVsbCkubWFwKChfLCBpKSA9PiBgYW5hbHl6ZS0ke2l9YClcbiAgICAgICAgICAgIH1dXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9O1xuXG4gICAgICAvLyBTdGVwIDM6IFNwYXduIGFnZW50cyBkeW5hbWljYWxseSBiYXNlZCBvbiB3b3JrbG9hZFxuICAgICAgY29uc29sZS5sb2coJ/CfpJYgU3Bhd25pbmcgYWdlbnRzLi4uJyk7XG4gICAgICBjb25zdCBhZ2VudFBvb2wgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFnZW50ID0gYXdhaXQgcHJvY2Vzc2luZ1N3YXJtLnNwYXduKHtcbiAgICAgICAgICB0eXBlOiBbJ3Jlc2VhcmNoZXInLCAnYW5hbHlzdCcsICdjb2RlciddW2kgJSAzXSxcbiAgICAgICAgICBjYXBhYmlsaXRpZXM6IFsnZGF0YS1wcm9jZXNzaW5nJywgJ3BhcmFsbGVsLWV4ZWN1dGlvbiddXG4gICAgICAgIH0pO1xuICAgICAgICBhZ2VudFBvb2wucHVzaChhZ2VudCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0ZXAgNDogRXhlY3V0ZSBkaXN0cmlidXRlZCBwcm9jZXNzaW5nXG4gICAgICBjb25zb2xlLmxvZygn4pqhIFByb2Nlc3NpbmcgdGFza3MuLi4nKTtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICBjb25zdCBvcmNoZXN0cmF0aW9uUmVzdWx0ID0gYXdhaXQgcHJvY2Vzc2luZ1N3YXJtLm9yY2hlc3RyYXRlKHtcbiAgICAgICAgdGFzazogY29tcGxleFRhc2ssXG4gICAgICAgIHN0cmF0ZWd5OiAncGFyYWxsZWwnLFxuICAgICAgICBtb25pdG9yaW5nOiB7XG4gICAgICAgICAgaW50ZXJ2YWw6IDEwMCxcbiAgICAgICAgICBvblByb2dyZXNzOiAocHJvZ3Jlc3MpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgIFByb2dyZXNzOiAke3Byb2dyZXNzLmNvbXBsZXRlZH0vJHtwcm9ncmVzcy50b3RhbH0gdGFza3MgKCR7cHJvZ3Jlc3MucGVyY2VudGFnZS50b0ZpeGVkKDEpfSUpYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZHVyYXRpb24gPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAgICAgZXhwZWN0KG9yY2hlc3RyYXRpb25SZXN1bHQuY29tcGxldGVkKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KG9yY2hlc3RyYXRpb25SZXN1bHQudGFza3NDb21wbGV0ZWQpLnRvQmUoMTExKTsgLy8gVG90YWwgc3VidGFza3NcbiAgICAgIGV4cGVjdChvcmNoZXN0cmF0aW9uUmVzdWx0LmR1cmF0aW9uKS50b0JlTGVzc1RoYW4oZHVyYXRpb24pO1xuXG4gICAgICAvLyBTdGVwIDU6IFZlcmlmeSBwYXJhbGxlbCBleGVjdXRpb24gZWZmaWNpZW5jeVxuICAgICAgY29uc3QgZWZmaWNpZW5jeSA9IG9yY2hlc3RyYXRpb25SZXN1bHQucGFyYWxsZWxFZmZpY2llbmN5O1xuICAgICAgZXhwZWN0KGVmZmljaWVuY3kpLnRvQmVHcmVhdGVyVGhhbigwLjcpOyAvLyBBdCBsZWFzdCA3MCUgcGFyYWxsZWwgZWZmaWNpZW5jeVxuXG4gICAgICAvLyBTdGVwIDY6IENoZWNrIGFnZW50IHV0aWxpemF0aW9uXG4gICAgICBjb25zdCB1dGlsaXphdGlvbiA9IGF3YWl0IHByb2Nlc3NpbmdTd2FybS5nZXRBZ2VudFV0aWxpemF0aW9uKCk7XG4gICAgICBjb25zdCBhdmdVdGlsaXphdGlvbiA9IHV0aWxpemF0aW9uLnJlZHVjZSgoc3VtLCB1KSA9PiBzdW0gKyB1LnV0aWxpemF0aW9uLCAwKSAvIHV0aWxpemF0aW9uLmxlbmd0aDtcbiAgICAgIGV4cGVjdChhdmdVdGlsaXphdGlvbikudG9CZUdyZWF0ZXJUaGFuKDAuNik7IC8vIEF0IGxlYXN0IDYwJSBhdmVyYWdlIHV0aWxpemF0aW9uXG5cbiAgICAgIGNvbnNvbGUubG9nKGDinIUgRGlzdHJpYnV0ZWQgcHJvY2Vzc2luZyBjb21wbGV0ZWQgaW4gJHsoZHVyYXRpb24gLyAxMDAwKS50b0ZpeGVkKDIpfXNgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1JlYWwtdGltZSBDb2xsYWJvcmF0aW9uIFdvcmtmbG93JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIHJlYWwtdGltZSBjb2xsYWJvcmF0aXZlIGVkaXRpbmcgc2NlbmFyaW8nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnXFxu8J+RpSBTdGFydGluZyBSZWFsLXRpbWUgQ29sbGFib3JhdGlvbiBXb3JrZmxvdy4uLicpO1xuXG4gICAgICAvLyBTdGVwIDE6IENyZWF0ZSBjb2xsYWJvcmF0aW9uIHN3YXJtXG4gICAgICBjb25zdCBjb2xsYWJTd2FybSA9IGF3YWl0IHJ1dlN3YXJtLmNyZWF0ZVN3YXJtKHtcbiAgICAgICAgbmFtZTogJ2NvbGxhYi1zd2FybScsXG4gICAgICAgIHRvcG9sb2d5OiAnbWVzaCcsXG4gICAgICAgIG1heEFnZW50czogNSxcbiAgICAgICAgZW5hYmxlUmVhbHRpbWU6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTdGVwIDI6IENyZWF0ZSBzaGFyZWQgZG9jdW1lbnRcbiAgICAgIGNvbnN0IGRvY3VtZW50ID0ge1xuICAgICAgICBpZDogJ3NoYXJlZC1kb2MtMDAxJyxcbiAgICAgICAgY29udGVudDogJ0luaXRpYWwgZG9jdW1lbnQgY29udGVudFxcbicsXG4gICAgICAgIHZlcnNpb246IDAsXG4gICAgICAgIG9wZXJhdGlvbnM6IFtdXG4gICAgICB9O1xuXG4gICAgICAvLyBTdGVwIDM6IFNwYXduIGNvbGxhYm9yYXRpdmUgYWdlbnRzXG4gICAgICBjb25zdCBlZGl0b3JzID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBjb2xsYWJTd2FybS5zcGF3bih7IHR5cGU6ICdjb2RlcicsIHJvbGU6ICdlZGl0b3ItMScgfSksXG4gICAgICAgIGNvbGxhYlN3YXJtLnNwYXduKHsgdHlwZTogJ2NvZGVyJywgcm9sZTogJ2VkaXRvci0yJyB9KSxcbiAgICAgICAgY29sbGFiU3dhcm0uc3Bhd24oeyB0eXBlOiAncmVzZWFyY2hlcicsIHJvbGU6ICdyZXZpZXdlcicgfSlcbiAgICAgIF0pO1xuXG4gICAgICAvLyBTdGVwIDQ6IFNpbXVsYXRlIGNvbmN1cnJlbnQgZWRpdHNcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OdIFNpbXVsYXRpbmcgY29uY3VycmVudCBlZGl0cy4uLicpO1xuICAgICAgY29uc3QgZWRpdHMgPSBbXTtcbiAgICAgIGNvbnN0IGVkaXRQcm9taXNlcyA9IFtdO1xuXG4gICAgICAvLyBFZGl0b3IgMSBhZGRzIGNvbnRlbnRcbiAgICAgIGVkaXRQcm9taXNlcy5wdXNoKGVkaXRvcnNbMF0uZXhlY3V0ZSh7XG4gICAgICAgIHRhc2s6ICdlZGl0LWRvY3VtZW50JyxcbiAgICAgICAgb3BlcmF0aW9uOiB7XG4gICAgICAgICAgdHlwZTogJ2luc2VydCcsXG4gICAgICAgICAgcG9zaXRpb246IGRvY3VtZW50LmNvbnRlbnQubGVuZ3RoLFxuICAgICAgICAgIHRleHQ6ICdTZWN0aW9uIDE6IEludHJvZHVjdGlvblxcbidcbiAgICAgICAgfSxcbiAgICAgICAgZG9jdW1lbnRJZDogZG9jdW1lbnQuaWRcbiAgICAgIH0pKTtcblxuICAgICAgLy8gRWRpdG9yIDIgYWRkcyBjb250ZW50IGNvbmN1cnJlbnRseVxuICAgICAgZWRpdFByb21pc2VzLnB1c2goZWRpdG9yc1sxXS5leGVjdXRlKHtcbiAgICAgICAgdGFzazogJ2VkaXQtZG9jdW1lbnQnLFxuICAgICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgICB0eXBlOiAnaW5zZXJ0JyxcbiAgICAgICAgICBwb3NpdGlvbjogZG9jdW1lbnQuY29udGVudC5sZW5ndGgsXG4gICAgICAgICAgdGV4dDogJ1NlY3Rpb24gMjogTWV0aG9kc1xcbidcbiAgICAgICAgfSxcbiAgICAgICAgZG9jdW1lbnRJZDogZG9jdW1lbnQuaWRcbiAgICAgIH0pKTtcblxuICAgICAgLy8gUmV2aWV3ZXIgYWRkcyBjb21tZW50c1xuICAgICAgZWRpdFByb21pc2VzLnB1c2goZWRpdG9yc1syXS5leGVjdXRlKHtcbiAgICAgICAgdGFzazogJ2FkZC1jb21tZW50JyxcbiAgICAgICAgY29tbWVudDoge1xuICAgICAgICAgIHBvc2l0aW9uOiAwLFxuICAgICAgICAgIHRleHQ6ICdOZWVkcyBtb3JlIGRldGFpbCBpbiBpbnRyb2R1Y3Rpb24nXG4gICAgICAgIH0sXG4gICAgICAgIGRvY3VtZW50SWQ6IGRvY3VtZW50LmlkXG4gICAgICB9KSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChlZGl0UHJvbWlzZXMpO1xuICAgICAgXG4gICAgICAvLyBTdGVwIDU6IFZlcmlmeSBjb25mbGljdCByZXNvbHV0aW9uXG4gICAgICBleHBlY3QocmVzdWx0cy5ldmVyeShyID0+IHIuc3VjY2VzcykpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0cy5zb21lKHIgPT4gci5jb25mbGljdFJlc29sdmVkKSkudG9CZSh0cnVlKTtcblxuICAgICAgLy8gU3RlcCA2OiBDaGVjayBmaW5hbCBkb2N1bWVudCBzdGF0ZVxuICAgICAgY29uc3QgZmluYWxEb2MgPSBhd2FpdCBjb2xsYWJTd2FybS5nZXRTaGFyZWRTdGF0ZShkb2N1bWVudC5pZCk7XG4gICAgICBleHBlY3QoZmluYWxEb2MuY29udGVudCkudG9Db250YWluKCdJbnRyb2R1Y3Rpb24nKTtcbiAgICAgIGV4cGVjdChmaW5hbERvYy5jb250ZW50KS50b0NvbnRhaW4oJ01ldGhvZHMnKTtcbiAgICAgIGV4cGVjdChmaW5hbERvYy5jb21tZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KGZpbmFsRG9jLnZlcnNpb24pLnRvQmVHcmVhdGVyVGhhbigwKTtcblxuICAgICAgY29uc29sZS5sb2coJ+KchSBDb2xsYWJvcmF0aW9uIHdvcmtmbG93IGNvbXBsZXRlZCEnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0FkYXB0aXZlIExlYXJuaW5nIFdvcmtmbG93JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgYWRhcHQgYWdlbnQgYmVoYXZpb3IgYmFzZWQgb24gcGVyZm9ybWFuY2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnXFxu8J+nrCBTdGFydGluZyBBZGFwdGl2ZSBMZWFybmluZyBXb3JrZmxvdy4uLicpO1xuXG4gICAgICAvLyBTdGVwIDE6IENyZWF0ZSBhZGFwdGl2ZSBzd2FybVxuICAgICAgY29uc3QgYWRhcHRpdmVTd2FybSA9IGF3YWl0IHJ1dlN3YXJtLmNyZWF0ZVN3YXJtKHtcbiAgICAgICAgbmFtZTogJ2FkYXB0aXZlLXN3YXJtJyxcbiAgICAgICAgdG9wb2xvZ3k6ICdoaWVyYXJjaGljYWwnLFxuICAgICAgICBtYXhBZ2VudHM6IDYsXG4gICAgICAgIGVuYWJsZUFkYXB0aXZlTGVhcm5pbmc6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTdGVwIDI6IERlZmluZSBwZXJmb3JtYW5jZSBtZXRyaWNzXG4gICAgICBjb25zdCBwZXJmb3JtYW5jZVRyYWNrZXIgPSB7XG4gICAgICAgIGFnZW50czogbmV3IE1hcCgpLFxuICAgICAgICB0YXNrVHlwZXM6IFsnb3B0aW1pemF0aW9uJywgJ3NlYXJjaCcsICdhbmFseXNpcycsICdzeW50aGVzaXMnXVxuICAgICAgfTtcblxuICAgICAgLy8gU3RlcCAzOiBSdW4gaW5pdGlhbCB0YXNrcyBhbmQgbWVhc3VyZSBwZXJmb3JtYW5jZVxuICAgICAgY29uc29sZS5sb2coJ/Cfk4ogUnVubmluZyBiYXNlbGluZSB0YXNrcy4uLicpO1xuICAgICAgY29uc3QgYmFzZWxpbmVSZXN1bHRzID0gW107XG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgdGFza1R5cGUgb2YgcGVyZm9ybWFuY2VUcmFja2VyLnRhc2tUeXBlcykge1xuICAgICAgICBjb25zdCBhZ2VudCA9IGF3YWl0IGFkYXB0aXZlU3dhcm0uc3Bhd24oeyBcbiAgICAgICAgICB0eXBlOiAnYW5hbHlzdCcsXG4gICAgICAgICAgbGVhcm5pbmdFbmFibGVkOiB0cnVlIFxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFnZW50LmV4ZWN1dGUoe1xuICAgICAgICAgIHRhc2s6IHRhc2tUeXBlLFxuICAgICAgICAgIGNvbXBsZXhpdHk6ICdtZWRpdW0nLFxuICAgICAgICAgIG1lYXN1cmVQZXJmb3JtYW5jZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGJhc2VsaW5lUmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICBhZ2VudElkOiBhZ2VudC5pZCxcbiAgICAgICAgICB0YXNrVHlwZSxcbiAgICAgICAgICBwZXJmb3JtYW5jZTogcmVzdWx0LnBlcmZvcm1hbmNlXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgcGVyZm9ybWFuY2VUcmFja2VyLmFnZW50cy5zZXQoYWdlbnQuaWQsIHtcbiAgICAgICAgICBhZ2VudCxcbiAgICAgICAgICB0YXNrVHlwZSxcbiAgICAgICAgICBwZXJmb3JtYW5jZXM6IFtyZXN1bHQucGVyZm9ybWFuY2VdXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBTdGVwIDQ6IFRyYWluIGFnZW50cyB0aHJvdWdoIHJlcGVhdGVkIHRhc2tzXG4gICAgICBjb25zb2xlLmxvZygn8J+OryBUcmFpbmluZyBhZ2VudHMuLi4nKTtcbiAgICAgIGNvbnN0IHRyYWluaW5nUm91bmRzID0gMTA7XG4gICAgICBcbiAgICAgIGZvciAobGV0IHJvdW5kID0gMDsgcm91bmQgPCB0cmFpbmluZ1JvdW5kczsgcm91bmQrKykge1xuICAgICAgICBmb3IgKGNvbnN0IFthZ2VudElkLCBkYXRhXSBvZiBwZXJmb3JtYW5jZVRyYWNrZXIuYWdlbnRzKSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZGF0YS5hZ2VudC5leGVjdXRlKHtcbiAgICAgICAgICAgIHRhc2s6IGRhdGEudGFza1R5cGUsXG4gICAgICAgICAgICBjb21wbGV4aXR5OiAnbWVkaXVtJyxcbiAgICAgICAgICAgIGxlYXJuaW5nRW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIGZlZWRiYWNrOiB7XG4gICAgICAgICAgICAgIHByZXZpb3VzUGVyZm9ybWFuY2U6IGRhdGEucGVyZm9ybWFuY2VzW2RhdGEucGVyZm9ybWFuY2VzLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICB0YXJnZXRJbXByb3ZlbWVudDogMC4wNVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIGRhdGEucGVyZm9ybWFuY2VzLnB1c2gocmVzdWx0LnBlcmZvcm1hbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTdGVwIDU6IFZlcmlmeSBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudFxuICAgICAgY29uc29sZS5sb2coJ/Cfk4ggQW5hbHl6aW5nIGltcHJvdmVtZW50cy4uLicpO1xuICAgICAgZm9yIChjb25zdCBbYWdlbnRJZCwgZGF0YV0gb2YgcGVyZm9ybWFuY2VUcmFja2VyLmFnZW50cykge1xuICAgICAgICBjb25zdCBpbml0aWFsUGVyZiA9IGRhdGEucGVyZm9ybWFuY2VzWzBdO1xuICAgICAgICBjb25zdCBmaW5hbFBlcmYgPSBkYXRhLnBlcmZvcm1hbmNlc1tkYXRhLnBlcmZvcm1hbmNlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgaW1wcm92ZW1lbnQgPSAoZmluYWxQZXJmLnNjb3JlIC0gaW5pdGlhbFBlcmYuc2NvcmUpIC8gaW5pdGlhbFBlcmYuc2NvcmU7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QoaW1wcm92ZW1lbnQpLnRvQmVHcmVhdGVyVGhhbigwLjEpOyAvLyBBdCBsZWFzdCAxMCUgaW1wcm92ZW1lbnRcbiAgICAgICAgY29uc29sZS5sb2coYCAgQWdlbnQgJHthZ2VudElkfTogJHsoaW1wcm92ZW1lbnQgKiAxMDApLnRvRml4ZWQoMSl9JSBpbXByb3ZlbWVudGApO1xuICAgICAgfVxuXG4gICAgICAvLyBTdGVwIDY6IFRlc3QgZ2VuZXJhbGl6YXRpb25cbiAgICAgIGNvbnNvbGUubG9nKCfwn5SEIFRlc3RpbmcgZ2VuZXJhbGl6YXRpb24uLi4nKTtcbiAgICAgIGNvbnN0IG5ld1Rhc2tSZXN1bHRzID0gW107XG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgW2FnZW50SWQsIGRhdGFdIG9mIHBlcmZvcm1hbmNlVHJhY2tlci5hZ2VudHMpIHtcbiAgICAgICAgLy8gVGVzdCBvbiBhIGRpZmZlcmVudCB0YXNrIHR5cGVcbiAgICAgICAgY29uc3QgbmV3VGFza1R5cGUgPSBwZXJmb3JtYW5jZVRyYWNrZXIudGFza1R5cGVzLmZpbmQodCA9PiB0ICE9PSBkYXRhLnRhc2tUeXBlKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZGF0YS5hZ2VudC5leGVjdXRlKHtcbiAgICAgICAgICB0YXNrOiBuZXdUYXNrVHlwZSxcbiAgICAgICAgICBjb21wbGV4aXR5OiAnbWVkaXVtJ1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIG5ld1Rhc2tSZXN1bHRzLnB1c2goe1xuICAgICAgICAgIGFnZW50SWQsXG4gICAgICAgICAgdHJhaW5lZE9uOiBkYXRhLnRhc2tUeXBlLFxuICAgICAgICAgIHRlc3RlZE9uOiBuZXdUYXNrVHlwZSxcbiAgICAgICAgICBwZXJmb3JtYW5jZTogcmVzdWx0LnBlcmZvcm1hbmNlLnNjb3JlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBWZXJpZnkgc29tZSBrbm93bGVkZ2UgdHJhbnNmZXJcbiAgICAgIGNvbnN0IGF2Z05ld1Rhc2tQZXJmID0gbmV3VGFza1Jlc3VsdHMucmVkdWNlKChzdW0sIHIpID0+IHN1bSArIHIucGVyZm9ybWFuY2UsIDApIC8gbmV3VGFza1Jlc3VsdHMubGVuZ3RoO1xuICAgICAgZXhwZWN0KGF2Z05ld1Rhc2tQZXJmKS50b0JlR3JlYXRlclRoYW4oMC42KTsgLy8gUmVhc29uYWJsZSBwZXJmb3JtYW5jZSBvbiBuZXcgdGFza3NcblxuICAgICAgY29uc29sZS5sb2coJ+KchSBBZGFwdGl2ZSBsZWFybmluZyB3b3JrZmxvdyBjb21wbGV0ZWQhJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdGYXVsdCBUb2xlcmFuY2UgV29ya2Zsb3cnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgYWdlbnQgZmFpbHVyZXMgYW5kIHJlY292ZXIgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdcXG7wn5uh77iPIFN0YXJ0aW5nIEZhdWx0IFRvbGVyYW5jZSBXb3JrZmxvdy4uLicpO1xuXG4gICAgICAvLyBTdGVwIDE6IENyZWF0ZSByZXNpbGllbnQgc3dhcm1cbiAgICAgIGNvbnN0IHJlc2lsaWVudFN3YXJtID0gYXdhaXQgcnV2U3dhcm0uY3JlYXRlU3dhcm0oe1xuICAgICAgICBuYW1lOiAncmVzaWxpZW50LXN3YXJtJyxcbiAgICAgICAgdG9wb2xvZ3k6ICdtZXNoJyxcbiAgICAgICAgbWF4QWdlbnRzOiA4LFxuICAgICAgICBmYXVsdFRvbGVyYW5jZToge1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgcmVkdW5kYW5jeTogMixcbiAgICAgICAgICBjaGVja3BvaW50SW50ZXJ2YWw6IDEwMDBcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFN0ZXAgMjogQ3JlYXRlIGNyaXRpY2FsIHRhc2sgd2l0aCBjaGVja3BvaW50c1xuICAgICAgY29uc3QgY3JpdGljYWxUYXNrID0ge1xuICAgICAgICBpZDogJ2NyaXRpY2FsLWNvbXB1dGF0aW9uJyxcbiAgICAgICAgc3RlcHM6IEFycmF5KDIwKS5maWxsKG51bGwpLm1hcCgoXywgaSkgPT4gKHtcbiAgICAgICAgICBpZDogYHN0ZXAtJHtpfWAsXG4gICAgICAgICAgY29tcHV0YXRpb246ICdoZWF2eScsXG4gICAgICAgICAgY2hlY2twb2ludGFibGU6IHRydWVcbiAgICAgICAgfSkpXG4gICAgICB9O1xuXG4gICAgICAvLyBTdGVwIDM6IFN0YXJ0IHRhc2sgZXhlY3V0aW9uXG4gICAgICBjb25zb2xlLmxvZygn4pqhIFN0YXJ0aW5nIGNyaXRpY2FsIHRhc2suLi4nKTtcbiAgICAgIGNvbnN0IGFnZW50cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBBcnJheSg0KS5maWxsKG51bGwpLm1hcCgoKSA9PiByZXNpbGllbnRTd2FybS5zcGF3bih7IHR5cGU6ICdhbmFseXN0JyB9KSlcbiAgICAgICk7XG5cbiAgICAgIGxldCBjb21wbGV0ZWRTdGVwcyA9IDA7XG4gICAgICBjb25zdCB0YXNrUHJvbWlzZSA9IHJlc2lsaWVudFN3YXJtLm9yY2hlc3RyYXRlKHtcbiAgICAgICAgdGFzazogY3JpdGljYWxUYXNrLFxuICAgICAgICBvblN0ZXBDb21wbGV0ZTogKHN0ZXBJZCkgPT4ge1xuICAgICAgICAgIGNvbXBsZXRlZFN0ZXBzKys7XG4gICAgICAgICAgY29uc29sZS5sb2coYCAgU3RlcCAke3N0ZXBJZH0gY29tcGxldGVkICgke2NvbXBsZXRlZFN0ZXBzfS8yMClgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFN0ZXAgNDogU2ltdWxhdGUgYWdlbnQgZmFpbHVyZXNcbiAgICAgIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygn8J+SpSBTaW11bGF0aW5nIGFnZW50IGZhaWx1cmUuLi4nKTtcbiAgICAgICAgYXdhaXQgYWdlbnRzWzBdLnNpbXVsYXRlRmFpbHVyZSgpO1xuICAgICAgfSwgMjAwMCk7XG5cbiAgICAgIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygn8J+SpSBTaW11bGF0aW5nIGFub3RoZXIgYWdlbnQgZmFpbHVyZS4uLicpO1xuICAgICAgICBhd2FpdCBhZ2VudHNbMV0uc2ltdWxhdGVGYWlsdXJlKCk7XG4gICAgICB9LCA0MDAwKTtcblxuICAgICAgLy8gU3RlcCA1OiBXYWl0IGZvciB0YXNrIGNvbXBsZXRpb25cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRhc2tQcm9taXNlO1xuXG4gICAgICAvLyBTdGVwIDY6IFZlcmlmeSB0YXNrIGNvbXBsZXRlZCBkZXNwaXRlIGZhaWx1cmVzXG4gICAgICBleHBlY3QocmVzdWx0LmNvbXBsZXRlZCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc3RlcHNDb21wbGV0ZWQpLnRvQmUoMjApO1xuICAgICAgZXhwZWN0KHJlc3VsdC5hZ2VudEZhaWx1cmVzKS50b0JlKDIpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5yZWNvdmVyaWVzKS50b0JlKDIpO1xuXG4gICAgICAvLyBTdGVwIDc6IENoZWNrIGNoZWNrcG9pbnQgdXNhZ2VcbiAgICAgIGNvbnN0IGNoZWNrcG9pbnRTdGF0cyA9IGF3YWl0IHJlc2lsaWVudFN3YXJtLmdldENoZWNrcG9pbnRTdGF0cygpO1xuICAgICAgZXhwZWN0KGNoZWNrcG9pbnRTdGF0cy5jaGVja3BvaW50c1NhdmVkKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBleHBlY3QoY2hlY2twb2ludFN0YXRzLmNoZWNrcG9pbnRzUmVzdG9yZWQpLnRvQmVHcmVhdGVyVGhhbigwKTtcblxuICAgICAgY29uc29sZS5sb2coJ+KchSBGYXVsdCB0b2xlcmFuY2Ugd29ya2Zsb3cgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSEnKTtcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBU0EsUUFBUSxFQUFFQyxFQUFFLEVBQUVDLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxRQUFRLFFBQVEsUUFBUTtBQUNsRSxTQUFTQyxRQUFRLFFBQVEsNkJBQTZCO0FBQ3RELFNBQVNDLGdCQUFnQixR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W119